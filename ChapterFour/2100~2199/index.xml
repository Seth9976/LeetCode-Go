<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode Cookbook</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/</link><description>Recent content on LeetCode Cookbook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2164.Sort-Even-and-Odd-Indices-Independently/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2164.Sort-Even-and-Odd-Indices-Independently/</guid><description>2164. Sort Even and Odd Indices Independently # 题目 # You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:
Sort the values at odd indices of nums in non-increasing order. For example, if nums = [4,**1**,2,**3**] before this step, it becomes [4,**3**,2,**1**] after. The values at odd indices 1 and 3 are sorted in non-increasing order. Sort the values at even indices of nums in non-decreasing order.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2165.Smallest-Value-of-the-Rearranged-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2165.Smallest-Value-of-the-Rearranged-Number/</guid><description>2165. Smallest Value of the Rearranged Number # 题目 # You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.
Return the rearranged number with minimal value.
Note that the sign of the number does not change after rearranging the digits.
Example 1:
Input: num = 310 Output: 103 Explanation: The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2166.Design-Bitset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2166.Design-Bitset/</guid><description>2166. Design Bitset # 题目 # A Bitset is a data structure that compactly stores bits.
Implement the Bitset class:
Bitset(int size) Initializes the Bitset with size bits, all of which are 0. void fix(int idx) Updates the value of the bit at the index idx to 1. If the value was already 1, no change occurs. void unfix(int idx) Updates the value of the bit at the index idx to 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods/</guid><description>2167. Minimum Time to Remove All Cars Containing Illegal Goods # 题目 # You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.
As the train conductor, you would like to get rid of all the cars containing illegal goods.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2169.Count-Operations-to-Obtain-Zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2169.Count-Operations-to-Obtain-Zero/</guid><description>2169. Count Operations to Obtain Zero # 题目 # You are given two non-negative integers num1 and num2.
In one operation, if num1 &amp;gt;= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.
For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2170.Minimum-Operations-to-Make-the-Array-Alternating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2170.Minimum-Operations-to-Make-the-Array-Alternating/</guid><description>2170. Minimum Operations to Make the Array Alternating # 题目 # You are given a 0-indexed array nums consisting of n positive integers.
The array nums is called alternating if:
nums[i - 2] == nums[i], where 2 &amp;lt;= i &amp;lt;= n - 1. nums[i - 1] != nums[i], where 1 &amp;lt;= i &amp;lt;= n - 1. In one operation, you can choose an index i and change nums[i] into any positive integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2171.Removing-Minimum-Number-of-Magic-Beans/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2171.Removing-Minimum-Number-of-Magic-Beans/</guid><description>2171. Removing Minimum Number of Magic Beans # 题目 # You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag.
Remove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it to any of the bags.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2180.Count-Integers-With-Even-Digit-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2180.Count-Integers-With-Even-Digit-Sum/</guid><description>2180. Count Integers With Even Digit Sum # 题目 # Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.
The digit sum of a positive integer is the sum of all its digits.
Example 1:
Input: num = 4 Output: 2 Explanation: The only integers less than or equal to 4 whose digit sums are even are 2 and 4.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2181.Merge-Nodes-in-Between-Zeros/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2181.Merge-Nodes-in-Between-Zeros/</guid><description>2181. Merge Nodes in Between Zeros # 题目 # You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.
For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2182.Construct-String-With-Repeat-Limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2182.Construct-String-With-Repeat-Limit/</guid><description>2182. Construct String With Repeat Limit # 题目 # You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.
Return the lexicographically largest repeatLimitedString possible.
A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2183.Count-Array-Pairs-Divisible-by-K/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2183.Count-Array-Pairs-Divisible-by-K/</guid><description>2183. Count Array Pairs Divisible by K # 题目 # Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that:
0 &amp;lt;= i &amp;lt; j &amp;lt;= n - 1 and nums[i] * nums[j] is divisible by k. Example 1:
Input: nums = [1,2,3,4,5], k = 2 Output: 7 Explanation: The 7 pairs of indices whose corresponding products are divisible by 2 are (0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4).</description></item></channel></rss>