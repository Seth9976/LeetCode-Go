<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode Cookbook</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/</link><description>Recent content on LeetCode Cookbook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0300.Longest-Increasing-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0300.Longest-Increasing-Subsequence/</guid><description>300. Longest Increasing Subsequence # 题目 # Given an unsorted array of integers, find the length of longest increasing subsequence.
Example:
Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note:
There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n^2) complexity. Follow up: Could you improve it to O(n log n) time complexity?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0301.Remove-Invalid-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0301.Remove-Invalid-Parentheses/</guid><description>301. Remove Invalid Parentheses # 题目 # Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.
Return all the possible results. You may return the answer in any order.
Example 1:
Input: s = &amp;quot;()())()&amp;quot; Output: [&amp;quot;(())()&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: s = &amp;quot;(a)())()&amp;quot; Output: [&amp;quot;(a())()&amp;quot;,&amp;quot;(a)()()&amp;quot;] Example 3:
Input: s = &amp;quot;)(&amp;quot; Output: [&amp;quot;&amp;quot;] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0303.Range-Sum-Query-Immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0303.Range-Sum-Query-Immutable/</guid><description>303. Range Sum Query - Immutable # 题目 # Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
Example:
Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note:
You may assume that the array does not change. There are many calls to sumRange function.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0304.Range-Sum-Query-2D-Immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0304.Range-Sum-Query-2D-Immutable/</guid><description>304. Range Sum Query 2D - Immutable # 题目 # Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.
Example:
Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -&amp;gt; 8 sumRegion(1, 1, 2, 2) -&amp;gt; 11 sumRegion(1, 2, 2, 4) -&amp;gt; 12 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0306.Additive-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0306.Additive-Number/</guid><description>306. Additive Number # 题目 # Additive number is a string whose digits can form additive sequence.
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.
Given a string containing only digits '0'-'9', write a function to determine if it&amp;rsquo;s an additive number.
Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0307.Range-Sum-Query-Mutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0307.Range-Sum-Query-Mutable/</guid><description>307. Range Sum Query - Mutable # 题目 # Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
The update(i, val) function modifies nums by updating the element at index i to val.
Example:
Given nums = [1, 3, 5] sumRange(0, 2) -&amp;gt; 9 update(1, 2) sumRange(0, 2) -&amp;gt; 8 Note:
The array is only modifiable by the update function.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</guid><description>309. Best Time to Buy and Sell Stock with Cooldown # 题目 # Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0315.Count-of-Smaller-Numbers-After-Self/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0315.Count-of-Smaller-Numbers-After-Self/</guid><description>315. Count of Smaller Numbers After Self # 题目 # You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].
Example:
Input: [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0318.Maximum-Product-of-Word-Lengths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0318.Maximum-Product-of-Word-Lengths/</guid><description>318. Maximum Product of Word Lengths # 题目 # Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.
Example 1:
Input: [&amp;quot;abcw&amp;quot;,&amp;quot;baz&amp;quot;,&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;,&amp;quot;xtfn&amp;quot;,&amp;quot;abcdef&amp;quot;] Output: 16 Explanation: The two words can be &amp;quot;abcw&amp;quot;, &amp;quot;xtfn&amp;quot;. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0319.Bulb-Switcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0319.Bulb-Switcher/</guid><description>319. Bulb Switcher # 题目 # There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.
On the third round, you toggle every third bulb (turning on if it&amp;rsquo;s off or turning off if it&amp;rsquo;s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.
Return the number of bulbs that are on after n rounds.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0322.Coin-Change/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0322.Coin-Change/</guid><description>322. Coin Change # 题目 # You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
Example 1:
Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0324.Wiggle-Sort-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0324.Wiggle-Sort-II/</guid><description>324. Wiggle Sort II # 题目 # Given an unsorted array nums, reorder it such that nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip;.
Example 1:
Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2:
Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0326.Power-of-Three/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0326.Power-of-Three/</guid><description>326. Power of Three # 题目 # Given an integer, write a function to determine if it is a power of three.
Example 1:
Input: 27 Output: true Example 2:
Input: 0 Output: false Example 3:
Input: 9 Output: true Example 4:
Input: 45 Output: false Follow up:
Could you do it without using any loop / recursion?
题目大意 # 给定一个整数，写一个函数来判断它是否是 3 的幂次方。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0327.Count-of-Range-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0327.Count-of-Range-Sum/</guid><description>327. Count of Range Sum # 题目 # Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.
Note:A naive algorithm of O(n2) is trivial. You MUST do better than that.
Example:
Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3 Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0328.Odd-Even-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0328.Odd-Even-Linked-List/</guid><description>328. Odd Even Linked List # 题目 # Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.
You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.
Example 1:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0329.Longest-Increasing-Path-in-a-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0329.Longest-Increasing-Path-in-a-Matrix/</guid><description>329. Longest Increasing Path in a Matrix # 题目 # Given an integer matrix, find the length of the longest increasing path.
From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).
Example 1:
Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0331.Verify-Preorder-Serialization-of-a-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0331.Verify-Preorder-Serialization-of-a-Binary-Tree/</guid><description>331. Verify Preorder Serialization of a Binary Tree # 题目 # One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node&amp;rsquo;s value. If it is a null node, we record using a sentinel value such as #.
_9_ / \ 3 2 / \ / \ 4 1 # 6 / \ / \ / \ # # # # # # For example, the above binary tree can be serialized to the string &amp;ldquo;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;rdquo;, where # represents a null node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0337.House-Robber-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0337.House-Robber-III/</guid><description>337. House Robber III # 题目 # The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;ldquo;root.&amp;rdquo; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;ldquo;all houses in this place forms a binary tree&amp;rdquo;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0338.Counting-Bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0338.Counting-Bits/</guid><description>338. Counting Bits # 题目 # Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.
Example 1:
Input: 2 Output: [0,1,1] Example 2:
Input: 5 Output: [0,1,1,2,1,2] Follow up:
It is very easy to come up with a solution with run time O(n*sizeof(integer)).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0341.Flatten-Nested-List-Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0341.Flatten-Nested-List-Iterator/</guid><description>341. Flatten Nested List Iterator # 题目 # Given a nested list of integers, implement an iterator to flatten it.
Each element is either an integer, or a list &amp;ndash; whose elements may also be integers or other lists.
Example 1:
Input:[[1,1],2,[1,1]] Output:[1,1,2,1,1] Explanation:By callingnext repeatedly untilhasNext returns false, the order of elements returned bynext should be:[1,1,2,1,1]. Example 2:
Input:[1,[4,[6]]] Output:[1,4,6] Explanation:By callingnext repeatedly untilhasNext returns false, the order of elements returned bynext should be:[1,4,6].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0342.Power-of-Four/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0342.Power-of-Four/</guid><description>342. Power of Four # 题目 # Given an integer (signed 32 bits), write a function to check whether it is a power of 4.
Example 1:
Input: 16 Output: true Example 2:
Input: 5 Output: false Follow up: Could you solve it without loops/recursion?
题目大意 # 给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。
解题思路 # 判断一个数是不是 4 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。 证明 (4^n - 1) % 3 == 0，(1) 4^n - 1 = (2^n + 1) * (2^n - 1)(2) 在任何连续的 3 个数中 (2^n-1)，(2^n)，(2^n+1)，一定有一个数是 3 的倍数。(2^n) 肯定不是 3 的倍数，那么 (2^n-1) 或者 (2^n+1) 中一定有一个是 3 的倍数。所以 4^n-1 一定是 3 的倍数。 代码 # package leetcode // 解法一 数论 func isPowerOfFour(num int) bool { return num &amp;gt; 0 &amp;amp;&amp;amp; (num&amp;amp;(num-1)) == 0 &amp;amp;&amp;amp; (num-1)%3 == 0 } // 解法二 循环 func isPowerOfFour1(num int) bool { for num &amp;gt;= 4 { if num%4 == 0 { num = num / 4 } else { return false } } return num == 1 } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0343.Integer-Break/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0343.Integer-Break/</guid><description>343. Integer Break # 题目 # Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.
Example 1:
Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1. Example 2:
Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0344.Reverse-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0344.Reverse-String/</guid><description>344. Reverse String # 题目 # Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2:
Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;] 题目大意 # 题目要求我们反转一个字符串。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0345.Reverse-Vowels-of-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0345.Reverse-Vowels-of-a-String/</guid><description>345. Reverse Vowels of a String # 题目 # Write a function that takes a string as input and reverse only the vowels of a string.
Example 1:
Input: &amp;quot;hello&amp;quot; Output: &amp;quot;holle&amp;quot; Example 2:
Input: &amp;quot;leetcode&amp;quot; Output: &amp;quot;leotcede&amp;quot; 题目大意 # 题目要求我们反转字符串中的元音字母。需要注意字母大小写。
解题思路 # 这一题的解题思路是用 2 个指针，指针对撞的思路，来不断交换首尾元素，即可。这一题和第 344 题思路一样。
代码 # package leetcode func reverseVowels(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i &amp;lt; j; { if !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0347.Top-K-Frequent-Elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0347.Top-K-Frequent-Elements/</guid><description>347. Top K Frequent Elements # 题目 # Given a non-empty array of integers, return the k most frequent elements.
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:
Input: nums = [1], k = 1 Output: [1] Note:
You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0349.Intersection-of-Two-Arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0349.Intersection-of-Two-Arrays/</guid><description>349. Intersection of Two Arrays # 题目 # Given two arrays, write a function to compute their intersection.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note:
Each element in the result must be unique. The result can be in any order. 题目大意 # 找到两个数组的交集元素，如果交集元素同一个数字出现了多次，只输出一次。
解题思路 # 把数组一的每个数字都存进字典中，然后在数组二中依次判断字典中是否存在，如果存在，在字典中删除它(因为输出要求只输出一次)。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0350.Intersection-of-Two-Arrays-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0350.Intersection-of-Two-Arrays-II/</guid><description>350. Intersection of Two Arrays II # 题目 # Given two arrays, write a function to compute their intersection.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note:
Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0352.Data-Stream-as-Disjoint-Intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0352.Data-Stream-as-Disjoint-Intervals/</guid><description>352. Data Stream as Disjoint Intervals # 题目 # Given a data stream input of non-negative integers a1, a2, &amp;hellip;, an, summarize the numbers seen so far as a list of disjoint intervals.
Implement the SummaryRanges class:
SummaryRanges() Initializes the object with an empty stream. void addNum(int val) Adds the integer val to the stream. int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0354.Russian-Doll-Envelopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0354.Russian-Doll-Envelopes/</guid><description>354. Russian Doll Envelopes # 题目 # You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.
What is the maximum number of envelopes can you Russian doll? (put one inside other)</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0357.Count-Numbers-with-Unique-Digits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0357.Count-Numbers-with-Unique-Digits/</guid><description>357. Count Numbers with Unique Digits # 题目 # Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &amp;lt; 10n.
Example:
Input: 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x &amp;lt; 100, excluding 11,22,33,44,55,66,77,88,99 题目大意 # 给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &amp;lt; 10^n 。
解题思路 # 输出 n 位数中不出现重复数字的数字的个数 这道题摸清楚规律以后，可以直接写出最终所有答案，答案只有 11 个。 考虑不重复数字是如生成的。如果只是一位数，不存在重复的数字，结果是 10 。如果是二位数，第一位一定不能取 0，那么第一位有 1-9，9种取法，第二位为了和第一位不重复，只能有 0-9，10种取法中减去第一位取的数字，那么也是 9 种取法。以此类推，如果是三位数，第三位是 8 种取法；四位数，第四位是 7 种取法；五位数，第五位是 6 种取法；六位数，第六位是 5 种取法；七位数，第七位是 4 种取法；八位数，第八位是 3 种取法；九位数，第九位是 2 种取法；十位数，第十位是 1 种取法；十一位数，第十一位是 0 种取法；十二位数，第十二位是 0 种取法；那么第 11 位数以后，每个数都是重复数字的数字。知道这个规律以后，可以累积上面的结果，把结果直接存在数组里面，暴力打表即可。O(1) 的时间复杂度。 代码 # package leetcode // 暴力打表法 func countNumbersWithUniqueDigits1(n int) int { res := []int{1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691} if n &amp;gt;= 10 { return res[10] } return res[n] } // 打表方法 func countNumbersWithUniqueDigits(n int) int { if n == 0 { return 1 } res, uniqueDigits, availableNumber := 10, 9, 9 for n &amp;gt; 1 &amp;amp;&amp;amp; availableNumber &amp;gt; 0 { uniqueDigits = uniqueDigits * availableNumber res += uniqueDigits availableNumber-- n-- } return res } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0367.Valid-Perfect-Square/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0367.Valid-Perfect-Square/</guid><description>367. Valid Perfect Square # 题目 # Given a positive integer num, write a function which returns True if num is a perfect square else False.
Note: Do not use any built-in library function such as sqrt.
Example 1:
Input: 16 Output: true Example 2:
Input: 14 Output: false 题目大意 # 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。
说明：不要使用任何内置的库函数，如 sqrt。
解题思路 # 给出一个数，要求判断这个数是不是完全平方数。 可以用二分搜索来解答这道题。判断完全平方数，根据它的定义来，是否能被开根号，即找到一个数的平方是否可以等于待判断的数字。从 [1, n] 区间内进行二分，若能找到则返回 true，找不到就返回 false 。 代码 # package leetcode func isPerfectSquare(num int) bool { low, high := 1, num for low &amp;lt;= high { mid := low + (high-low)&amp;gt;&amp;gt;1 if mid*mid == num { return true } else if mid*mid &amp;lt; num { low = mid + 1 } else { high = mid - 1 } } return false } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0368.Largest-Divisible-Subset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0368.Largest-Divisible-Subset/</guid><description>368. Largest Divisible Subset # 题目 # Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:
answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them.
Example 1:
Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0371.Sum-of-Two-Integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0371.Sum-of-Two-Integers/</guid><description>371. Sum of Two Integers # 题目 # Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example 1:
Input: a = 1, b = 2 Output: 3 Example 2:
Input: a = -2, b = 3 Output: 1 题目大意 # 不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
解题思路 # 要求不用加法和减法运算符计算 a+b。这一题需要用到 ^ 和 &amp;amp; 运算符的性质，两个数 ^ 可以实现两个数不带进位的二进制加法。这里需要实现加法，肯定需要进位。所以如何找到进位是本题的关键。 在二进制中，只有 1 和 1 加在一起才会进位，0 和 0，0 和 1，1 和 0，这三种情况都不会进位，规律就是 a &amp;amp; b 为 0 的时候就不用进位，为 1 的时候代表需要进位。进位是往前进一位，所以还需要左移操作，所以加上的进位为 (a&amp;amp;b)&amp;lt;&amp;lt;1。 代码 # package leetcode func getSum(a int, b int) int { if a == 0 { return b } if b == 0 { return a } // (a &amp;amp; b)&amp;lt;&amp;lt;1 计算的是进位 // a ^ b 计算的是不带进位的加法 return getSum((a&amp;amp;b)&amp;lt;&amp;lt;1, a^b) } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0372.Super-Pow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0372.Super-Pow/</guid><description>372. Super Pow # 题目 # Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.
Example 1:
Input: a = 2, b = [3] Output: 8 Example 2:
Input: a = 2, b = [1,0] Output: 1024 题目大意 # 你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0373.Find-K-Pairs-with-Smallest-Sums/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0373.Find-K-Pairs-with-Smallest-Sums/</guid><description>373. Find K Pairs with Smallest Sums # 题目 # You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.
Define a pair (u,v) which consists of one element from the first array and one element from the second array.
Find the k pairs (u1,v1),(u2,v2) &amp;hellip;(uk,vk) with the smallest sums.
Example 1:
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0374.Guess-Number-Higher-or-Lower/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0374.Guess-Number-Higher-or-Lower/</guid><description>374. Guess Number Higher or Lower # 题目 # We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API int guess(int num), which returns 3 possible results:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0376.Wiggle-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0376.Wiggle-Subsequence/</guid><description>376. Wiggle Subsequence # 题目 # Given an integer array nums, return the length of the longest wiggle sequence.
A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) are alternately positive and negative.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0377.Combination-Sum-IV/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0377.Combination-Sum-IV/</guid><description>377. Combination Sum IV # 题目 # Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.
The answer is guaranteed to fit in a 32-bit integer.
Example 1:
Input: nums = [1,2,3], target = 4 Output: 7 Explanation: The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0378.Kth-Smallest-Element-in-a-Sorted-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0378.Kth-Smallest-Element-in-a-Sorted-Matrix/</guid><description>378. Kth Smallest Element in a Sorted Matrix # 题目 # Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
Example:
matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0382.Linked-List-Random-Node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0382.Linked-List-Random-Node/</guid><description>382. Linked List Random Node # 题目 # Given a singly linked list, return a random node&amp;rsquo;s value from the linked list. Each node must have the same probability of being chosen.
Implement the Solution class:
Solution(ListNode head) Initializes the object with the integer array nums. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be choosen.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0383.Ransom-Note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0383.Ransom-Note/</guid><description>383. Ransom Note # 题目 # Given two stings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote.
Example 1:
Input: ransomNote = &amp;quot;a&amp;quot;, magazine = &amp;quot;b&amp;quot; Output: false Example 2:
Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;ab&amp;quot; Output: false Example 3:
Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;aab&amp;quot; Output: true Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0384.Shuffle-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0384.Shuffle-an-Array/</guid><description>384.Shuffle an Array # 题目 # Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.
Implement the Solution class:
Solution(int[] nums) Initializes the object with the integer array nums. int[] reset() Resets the array to its original configuration and returns it. int[] shuffle() Returns a random shuffling of the array.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0385.Mini-Parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0385.Mini-Parser/</guid><description>385. Mini Parser # 题目 # Given a nested list of integers represented as a string, implement a parser to deserialize it.
Each element is either an integer, or a list &amp;ndash; whose elements may also be integers or other lists.
Note: You may assume that the string is well-formed:
String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0386.Lexicographical-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0386.Lexicographical-Numbers/</guid><description>386. Lexicographical Numbers # 题目 # Given an integer n, return 1 - n in lexicographical order.
For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].
Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.
题目大意 # 给定一个整数 n, 返回从 1 到 n 的字典顺序。例如，给定 n =13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。
请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。
解题思路 # 给出一个数字 n ，要求按照字典序对 1-n 这 n 个数排序。 DFS 暴力求解即可。 代码 # package leetcode func lexicalOrder(n int) []int { res := make([]int, 0, n) dfs386(1, n, &amp;amp;res) return res } func dfs386(x, n int, res *[]int) { limit := (x + 10) / 10 * 10 for x &amp;lt;= n &amp;amp;&amp;amp; x &amp;lt; limit { *res = append(*res, x) if x*10 &amp;lt;= n { dfs386(x*10, n, res) } x++ } } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0387.First-Unique-Character-in-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0387.First-Unique-Character-in-a-String/</guid><description>387. First Unique Character in a String # 题目 # Given a string, find the first non-repeating character in it and return it&amp;rsquo;s index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot;, return 2. Note: You may assume the string contain only lowercase letters.
题目大意 # 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
解题思路 # 简单题，要求输出第一个没有重复的字符。 解法二这个思路只超过 81% 的用户，但是如果测试样例中 s 的字符串很长，但是满足条件的字符都在靠后的位置的话，这个思路应该会更有优势。通过记录每个字符的第一次出现的位置和最后一次出现的位置。第一次对 s 进行一次遍历。第二次仅仅对数组进行遍历就可以了。 代码 # package leetcode // 解法 一 func firstUniqChar(s string) int { result := make([]int, 26) for i := 0; i &amp;lt; len(s); i++ { result[s[i]-&amp;#39;a&amp;#39;]++ } for i := 0; i &amp;lt; len(s); i++ { if result[s[i]-&amp;#39;a&amp;#39;] == 1 { return i } } return -1 } // 解法 二 // 执行用时: 8 ms // 内存消耗: 5.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0389.Find-the-Difference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0389.Find-the-Difference/</guid><description>389. Find the Difference # 题目 # Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t.
Example:
Input: s = &amp;quot;abcd&amp;quot; t = &amp;quot;abcde&amp;quot; Output: e Explanation: 'e' is the letter that was added. 题目大意 # 给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0390.Elimination-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0390.Elimination-Game/</guid><description>390. Elimination Game # 题目 # You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:
Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0391.Perfect-Rectangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0391.Perfect-Rectangle/</guid><description>391. Perfect Rectangle # 题目 # Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).
Return true if all the rectangles together form an exact cover of a rectangular region.
Example1:
Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]] Output: true Explanation: All 5 rectangles together form an exact cover of a rectangular region.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0392.Is-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0392.Is-Subsequence/</guid><description>392. Is Subsequence # 题目 # Given a string s and a string t, check if s is subsequence of t.
You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&amp;lt;=100).
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0393.UTF-8-Validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0393.UTF-8-Validation/</guid><description>393. UTF-8 Validation # 题目 # A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one&amp;rsquo;s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10. This is how the UTF-8 encoding would work:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0394.Decode-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0394.Decode-String/</guid><description>394. Decode String # 题目 # Given an encoded string, return its decoded string.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0395.Longest-Substring-with-At-Least-K-Repeating-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0395.Longest-Substring-with-At-Least-K-Repeating-Characters/</guid><description>395. Longest Substring with At Least K Repeating Characters # 题目 # Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.
Example 1:
Input: s = &amp;quot;aaabb&amp;quot;, k = 3 Output: 3 Explanation: The longest substring is &amp;quot;aaa&amp;quot;, as 'a' is repeated 3 times.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0396.Rotate-Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0396.Rotate-Function/</guid><description>396. Rotate Function # 题目 # You are given an integer array nums of length n.
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]. Return the maximum value of F(0), F(1), .</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0397.Integer-Replacement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0397.Integer-Replacement/</guid><description>397. Integer Replacement # 题目 # Given a positive integer n and you can do operations as follow:
If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1. What is the minimum number of replacements needed for n to become 1?
Example 1:
Input: 8 Output: 3 Explanation: 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0399.Evaluate-Division/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0399.Evaluate-Division/</guid><description>399. Evaluate Division # 题目 # Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.
Example:
Given a / b = 2.0, b / c = 3.0.queries are: a / c = ?, b / a = ?</description></item></channel></rss>