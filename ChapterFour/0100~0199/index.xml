<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LeetCode Cookbook</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/</link><description>Recent content on LeetCode Cookbook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0100.Same-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0100.Same-Tree/</guid><description>100. Same Tree # 题目 # Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2:
Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0101.Symmetric-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0101.Symmetric-Tree/</guid><description>101. Symmetric Tree # 题目 # Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not:
1 / \ 2 2 \ \ 3 3 Note:
Bonus points if you could solve it both recursively and iteratively.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0102.Binary-Tree-Level-Order-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0102.Binary-Tree-Level-Order-Traversal/</guid><description>102. Binary Tree Level Order Traversal # 题目 # Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its level order traversal as:
[ [3], [9,20], [15,7] ] 题目大意 # 按层序从上到下遍历一颗树。
解题思路 # 用一个队列即可实现。
代码 # package leetcode import ( &amp;#34;github.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0103.Binary-Tree-Zigzag-Level-Order-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0103.Binary-Tree-Zigzag-Level-Order-Traversal/</guid><description>103. Binary Tree Zigzag Level Order Traversal # 题目 # Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).
For Example: Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as:
[ [3], [20,9], [15,7] ] 题目大意 # 按照 Z 字型层序遍历一棵树。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0104.Maximum-Depth-of-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0104.Maximum-Depth-of-Binary-Tree/</guid><description>104. Maximum Depth of Binary Tree # 题目 # Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its depth = 3.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</guid><description>105. Construct Binary Tree from Preorder and Inorder Traversal # 题目 # Given preorder and inorder traversal of a tree, construct the binary tree.
Note:You may assume that duplicates do not exist in the tree.
For example, given
preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:
3 / \ 9 20 / \ 15 7 题目大意 # 根据一棵树的前序遍历与中序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
解题思路 # 给出 2 个数组，根据 preorder 和 inorder 数组构造一颗树。 利用递归思想，从 preorder 可以得到根节点，从 inorder 中得到左子树和右子树。只剩一个节点的时候即为根节点。不断的递归直到所有的树都生成完成。 代码 # package leetcode import ( &amp;#34;github.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0106.Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0106.Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</guid><description>106. Construct Binary Tree from Inorder and Postorder Traversal # 题目 # Given inorder and postorder traversal of a tree, construct the binary tree.
Note: You may assume that duplicates do not exist in the tree.
For example, given
inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:
3 / \ 9 20 / \ 15 7 题目大意 # 根据一棵树的中序遍历与后序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0107.Binary-Tree-Level-Order-Traversal-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0107.Binary-Tree-Level-Order-Traversal-II/</guid><description>107. Binary Tree Level Order Traversal II # 题目 # Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root).
For Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as:
[ [15,7], [9,20], [3] ] 题目大意 # 按层序从下到上遍历一颗树。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0108.Convert-Sorted-Array-to-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0108.Convert-Sorted-Array-to-Binary-Search-Tree/</guid><description>108. Convert Sorted Array to Binary Search Tree # 题目 # Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 题目大意 # 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0109.Convert-Sorted-List-to-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0109.Convert-Sorted-List-to-Binary-Search-Tree/</guid><description>109. Convert Sorted List to Binary Search Tree # 题目 # Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 题目大意 # 将链表转化为高度平衡的二叉搜索树。高度平衡的定义：每个结点的 2 个子结点的深度不能相差超过 1 。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0110.Balanced-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0110.Balanced-Binary-Tree/</guid><description>110. Balanced Binary Tree # 题目 # Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example 1:
Given the following tree [3,9,20,null,null,15,7]:
3 / \ 9 20 / \ 15 7 Return true.
Example 2:
Given the following tree [1,2,2,3,3,null,null,4,4]:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0111.Minimum-Depth-of-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0111.Minimum-Depth-of-Binary-Tree/</guid><description>111. Minimum Depth of Binary Tree # 题目 # Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its minimum depth = 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0112.Path-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0112.Path-Sum/</guid><description>112. Path Sum # 题目 # Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
Note: A leaf is a node with no children.
Example:
Given the below binary tree and sum = 22,
5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0113.Path-Sum-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0113.Path-Sum-II/</guid><description>113. Path Sum II # 题目 # Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum.
Note: A leaf is a node with no children.
Example:
Given the below binary tree and sum = 22,
5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return:
[ [5,4,11,2], [5,8,4,5] ] 题目大意 # 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0114.Flatten-Binary-Tree-to-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0114.Flatten-Binary-Tree-to-Linked-List/</guid><description>114. Flatten Binary Tree to Linked List # 题目 # Given a binary tree, flatten it to a linked list in-place.
For example, given the following tree:
1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like:
1 \ 2 \ 3 \ 4 \ 5 \ 6 题目大意 # 给定一个二叉树，原地将它展开为链表。
解题思路 # 要求把二叉树“打平”，按照先根遍历的顺序，把树的结点都放在右结点中。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0115.Distinct-Subsequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0115.Distinct-Subsequences/</guid><description>115. Distinct Subsequences # 题目 # Given two strings s and t, return the number of distinct subsequences of s which equals t.
A string&amp;rsquo;s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters&amp;rsquo; relative positions. (i.e., &amp;quot;ACE&amp;quot; is a subsequence of &amp;quot;ABCDE&amp;quot; while &amp;quot;AEC&amp;quot; is not).
It is guaranteed the answer fits on a 32-bit signed integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0116.Populating-Next-Right-Pointers-in-Each-Node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0116.Populating-Next-Right-Pointers-in-Each-Node/</guid><description>116. Populating Next Right Pointers in Each Node # 题目 # You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0118.Pascals-Triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0118.Pascals-Triangle/</guid><description>118. Pascal&amp;rsquo;s Triangle # 题目 # Given a non-negative integer numRows, generate the first numRows of Pascal&amp;rsquo;s triangle.
Note: In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Example:
Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 题目大意 # 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。
解题思路 # 给定一个 n，要求打印杨辉三角的前 n 行。 简单题。按照杨辉三角的生成规则循环打印即可。 代码 # package leetcode func generate(numRows int) [][]int { result := [][]int{} for i := 0; i &amp;lt; numRows; i++ { row := []int{} for j := 0; j &amp;lt; i+1; j++ { if j == 0 || j == i { row = append(row, 1) } else if i &amp;gt; 1 { row = append(row, result[i-1][j-1]+result[i-1][j]) } } result = append(result, row) } return result } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0119.Pascals-Triangle-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0119.Pascals-Triangle-II/</guid><description>119. Pascal&amp;rsquo;s Triangle II # 题目 # Given an integer rowIndex, return the rowIndexth row of the Pascal&amp;rsquo;s triangle.
Notice that the row index starts from 0.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Follow up:
Could you optimize your algorithm to use only O(k) extra space?
Example 1:
Input: rowIndex = 3 Output: [1,3,3,1] Example 2:
Input: rowIndex = 0 Output: [1] Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0120.Triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0120.Triangle/</guid><description>120. Triangle # 题目 # Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
For example, given the following triangle
[ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0121.Best-Time-to-Buy-and-Sell-Stock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0121.Best-Time-to-Buy-and-Sell-Stock/</guid><description>121. Best Time to Buy and Sell Stock # 题目 # Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0122.Best-Time-to-Buy-and-Sell-Stock-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0122.Best-Time-to-Buy-and-Sell-Stock-II/</guid><description>122. Best Time to Buy and Sell Stock II # 题目 # Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0124.Binary-Tree-Maximum-Path-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0124.Binary-Tree-Maximum-Path-Sum/</guid><description>124. Binary Tree Maximum Path Sum # 题目 # Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3] 1 / \ 2 3 Output: 6 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0125.Valid-Palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0125.Valid-Palindrome/</guid><description>125. Valid Palindrome # 题目 # Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
For example,
&amp;quot;A man, a plan, a canal: Panama&amp;quot; is a palindrome. &amp;quot;race a car&amp;quot; is not a palindrome. Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.
For the purpose of this problem, we define empty string as valid palindrome.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0126.Word-Ladder-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0126.Word-Ladder-II/</guid><description>126. Word Ladder II # 题目 # Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:
Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note:
Return an empty list if there is no such transformation sequence.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0127.Word-Ladder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0127.Word-Ladder/</guid><description>127. Word Ladder # 题目 # Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note:
Return 0 if there is no such transformation sequence.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0128.Longest-Consecutive-Sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0128.Longest-Consecutive-Sequence/</guid><description>128. Longest Consecutive Sequence # 题目 # Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
Example:
Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 题目大意 # 给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。
解题思路 # 给出一个数组，要求找出最长连续序列，输出这个最长的长度。要求时间复杂度为 O(n)。 这一题可以先用暴力解决解决，代码见解法三。思路是把每个数都存在 map 中，先删去 map 中没有前一个数 nums[i]-1 也没有后一个数 nums[i]+1 的数 nums[i]，这种数前后都不连续。然后在 map 中找到前一个数 nums[i]-1 不存在，但是后一个数 nums[i]+1 存在的数，这种数是连续序列的起点，那么不断的往后搜，直到序列“断”了。最后输出最长序列的长度。 这一题最优的解法是解法一，针对每一个 map 中不存在的数 n，插入进去都做 2 件事情。第一件事，先查看 n - 1 和 n + 1 是否都存在于 map 中，如果都存在，代表存在连续的序列，那么就更新 left，right 边界。那么 n 对应的这个小的子连续序列长度为 sum = left + right + 1。第二件事就是更新 left 和 right 左右边界对应的 length = sum。 这一题还可以用并查集解决，见解法二。利用每个数在 nums 中的下标，把下标和下标进行 union()，具体做法是看前一个数 nums[i]-1 和后一个数 nums[i]+1 在 map 中是否存在，如果存在就 union()，最终输出整个并查集中包含最多元素的那个集合的元素总数。 代码 # package leetcode import ( &amp;#34;github.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0129.Sum-Root-to-Leaf-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0129.Sum-Root-to-Leaf-Numbers/</guid><description>129. Sum Root to Leaf Numbers # 题目 # Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
An example is the root-to-leaf path 1-&amp;gt;2-&amp;gt;3 which represents the number 123.
Find the total sum of all root-to-leaf numbers.
Note: A leaf is a node with no children.
Example:
Input: [1,2,3] 1 / \ 2 3 Output: 25 Explanation: The root-to-leaf path 1-&amp;gt;2 represents the number 12.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0130.Surrounded-Regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0130.Surrounded-Regions/</guid><description>130. Surrounded Regions # 题目 # Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.
A region is captured by flipping all 'O's into 'X's in that surrounded region.
Example:
X X X X X O O X X X O X X O X X After running your function, the board should be:
X X X X X X X X X X X X X O X X Explanation:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0131.Palindrome-Partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0131.Palindrome-Partitioning/</guid><description>131. Palindrome Partitioning # 题目 # Given a string s, partition s such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of s.
Example:
Input: &amp;quot;aab&amp;quot; Output: [ [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;], [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;] ] 题目大意 # 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。
解题思路 # 要求输出一个字符串可以被拆成回文串的所有解，DFS 递归求解即可。 代码 # package leetcode // 解法一 func partition131(s string) [][]string { if s == &amp;#34;&amp;#34; { return [][]string{} } res, pal := [][]string{}, []string{} findPalindrome(s, 0, &amp;#34;&amp;#34;, true, pal, &amp;amp;res) return res } func findPalindrome(str string, index int, s string, isPal bool, pal []string, res *[][]string) { if index == len(str) { if isPal { tmp := make([]string, len(pal)) copy(tmp, pal) *res = append(*res, tmp) } return } if index == 0 { s = string(str[index]) pal = append(pal, s) findPalindrome(str, index+1, s, isPal &amp;amp;&amp;amp; isPalindrome131(s), pal, res) } else { temp := pal[len(pal)-1] s = pal[len(pal)-1] + string(str[index]) pal[len(pal)-1] = s findPalindrome(str, index+1, s, isPalindrome131(s), pal, res) pal[len(pal)-1] = temp if isPalindrome131(temp) { pal = append(pal, string(str[index])) findPalindrome(str, index+1, temp, isPal &amp;amp;&amp;amp; isPalindrome131(temp), pal, res) pal = pal[:len(pal)-1] } } return } func isPalindrome131(s string) bool { slen := len(s) for i, j := 0, slen-1; i &amp;lt; j; i, j = i+1, j-1 { if s[i] !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0135.Candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0135.Candy/</guid><description>135. Candy # 题目 # There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.
You are giving candies to these children subjected to the following requirements:
Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0136.Single-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0136.Single-Number/</guid><description>136. Single Number # 题目 # Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:
Input: [4,1,2,1,2] Output: 4 题目大意 # 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。
解题思路 # 题目要求不能使用辅助空间，并且时间复杂度只能是线性的。 题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。于是最终做法是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。利用的性质是 x^x = 0。 代码 # package leetcode func singleNumber(nums []int) int { result := 0 for i := 0; i &amp;lt; len(nums); i++ { result ^= nums[i] } return result } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0137.Single-Number-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0137.Single-Number-II/</guid><description>137. Single Number II # 题目 # Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,3,2] Output: 3 Example 2:
Input: [0,1,0,1,0,1,99] Output: 99 题目大意 # 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。
解题思路 # 这一题是第 136 题的加强版。这类题也可以扩展，在数组中每个元素都出现 5 次，找出只出现 1 次的数。 本题中要求找出只出现 1 次的数，出现 3 次的数都要被消除。第 136 题是消除出现 2 次的数。这一题也会相当相同的解法，出现 3 次的数也要被消除。定义状态，00、10、01，这 3 个状态。当一个数出现 3 次，那么它每个位置上的 1 出现的次数肯定是 3 的倍数，所以当 1 出现 3 次以后，就归零清除。如何能做到这点呢？仿造三进制(00，01，10) 就可以做到。 变量 ones 中记录遍历中每个位上出现 1 的个数。将它与 A[i] 进行异或，目的是： 每位上两者都是 1 的，表示历史统计结果 ones 出现1次、A[i]中又出现 1 次，则是出现 2 次，需要进位到 twos 变量中。 每位上两者分别为 0、1 的，加入到 ones 统计结果中。 最后还要 &amp;amp; ^twos ，是为了能做到三进制，出现 3 次就清零。例如 ones = x，那么 twos = 0，当 twos = x，那么 ones = 0； 变量 twos 中记录遍历中每个位上出现 1 ，2次 的个数。与 A[i] 进行异或的目的和上述描述相同，不再赘述。 在 golang 中，&amp;amp;^ 表示 AND NOT 的意思。这里的 ^ 作为一元操作符，表示按位取反 (^0001 0100 = 1110 1011)，X &amp;amp;^ Y 的意思是将 X 中与 Y 相异的位保留，相同的位清零。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0138.Copy-List-With-Random-Pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0138.Copy-List-With-Random-Pointer/</guid><description>138. Copy List with Random Pointer # 题目 # A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a  deep copy of the list.
The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:
val: an integer representing Node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0141.Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0141.Linked-List-Cycle/</guid><description>141. Linked List Cycle # 题目 # Given a linked list, determine if it has a cycle in it.
Follow up:
Can you solve it without using extra space?
题目大意 # 判断链表是否有环，不能使用额外的空间。
解题思路 # 给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。
代码 # package leetcode import ( &amp;#34;github.com/halfrost/leetcode-go/structures&amp;#34; ) // ListNode define type ListNode = structures.ListNode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func hasCycle(head *ListNode) bool { fast := head slow := head for fast !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0142.Linked-List-Cycle-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0142.Linked-List-Cycle-II/</guid><description>142. Linked List Cycle II # 题目 # Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Note: Do not modify the linked list.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0143.Reorder-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0143.Reorder-List/</guid><description>143. Reorder List # 题目 # Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…
You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.
Example 1:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, reorder it to 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. Example 2:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, reorder it to 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3. 题目大意 # 按照指定规则重新排序链表：第一个元素和最后一个元素排列在一起，接着第二个元素和倒数第二个元素排在一起，接着第三个元素和倒数第三个元素排在一起。
解题思路 # 最近简单的方法是先把链表存储到数组里，然后找到链表中间的结点，按照规则拼接即可。这样时间复杂度是 O(n)，空间复杂度是 O(n)。
更好的做法是结合之前几道题的操作：链表逆序，找中间结点。
先找到链表的中间结点，然后利用逆序区间的操作，如 第 92 题 里的 reverseBetween() 操作，只不过这里的反转区间是从中点一直到末尾。最后利用 2 个指针，一个指向头结点，一个指向中间结点，开始拼接最终的结果。这种做法的时间复杂度是 O(n)，空间复杂度是 O(1)。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0144.Binary-Tree-Preorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0144.Binary-Tree-Preorder-Traversal/</guid><description>144. Binary Tree Preorder Traversal # 题目 # Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively?
题目大意 # 先根遍历一颗树。
解题思路 # 两种递归的实现方法，见代码。
代码 # package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 递归 func preorderTraversal(root *TreeNode) []int { res := []int{} if root !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0145.Binary-Tree-Postorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0145.Binary-Tree-Postorder-Traversal/</guid><description>145. Binary Tree Postorder Traversal # 题目 # Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively?
题目大意 # 后根遍历一颗树。
解题思路 # 递归的实现方法，见代码。
代码 # package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func postorderTraversal(root *TreeNode) []int { var result []int postorder(root, &amp;amp;result) return result } func postorder(root *TreeNode, output *[]int) { if root !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0146.LRU-Cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0146.LRU-Cache/</guid><description>146. LRU Cache # 题目 # Design a data structure that follows the constraints of a  Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return 1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0147.Insertion-Sort-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0147.Insertion-Sort-List/</guid><description>147. Insertion Sort List # 题目 # Sort a linked list using insertion sort.
A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list
Algorithm of Insertion Sort:
Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0148.Sort-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0148.Sort-List/</guid><description>148. Sort List # 题目 # Sort a linked list in O(n log n) time using constant space complexity.
Example 1:
Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 Example 2:
Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0 Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5 题目大意 # 链表的排序，要求时间复杂度必须是 O(n log n)，空间复杂度是 O(1)
解题思路 # 这道题只能用归并排序才能符合要求。归并排序需要的 2 个操作在其他题目已经出现过了，取中间点是第 876 题，合并 2 个有序链表是第 21 题。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { length := 0 cur := head for cur !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0150.Evaluate-Reverse-Polish-Notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0150.Evaluate-Reverse-Polish-Notation/</guid><description>150. Evaluate Reverse Polish Notation # 题目 # Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, /. Each operand may be an integer or another expression.
Note:
Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&amp;rsquo;t be any divide by zero operation.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0151.Reverse-Words-in-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0151.Reverse-Words-in-a-String/</guid><description>151. Reverse Words in a String # 题目 # Given an input string, reverse the string word by word.
Example 1:
Input: &amp;quot;the sky is blue&amp;quot; Output: &amp;quot;blue is sky the&amp;quot; Example 2:
Input: &amp;quot; hello world! &amp;quot; Output: &amp;quot;world! hello&amp;quot; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3:
Input: &amp;quot;a good example&amp;quot; Output: &amp;quot;example good a&amp;quot; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0152.Maximum-Product-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0152.Maximum-Product-Subarray/</guid><description>152. Maximum Product Subarray # 题目 # Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.
Example 1:
Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2:
Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. 题目大意 # 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0153.Find-Minimum-in-Rotated-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0153.Find-Minimum-in-Rotated-Sorted-Array/</guid><description>153. Find Minimum in Rotated Sorted Array # 题目 # Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
You may assume no duplicate exists in the array.
Example 1:
Input: [3,4,5,1,2] Output: 1 Example 2:
Input: [4,5,6,7,0,1,2] Output: 0 题目大意 # 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。
你可以假设数组中不存在重复元素。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0154.Find-Minimum-in-Rotated-Sorted-Array-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0154.Find-Minimum-in-Rotated-Sorted-Array-II/</guid><description>154. Find Minimum in Rotated Sorted Array II # 题目 # Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
The array may contain duplicates.
Example 1:
Input: [1,3,5] Output: 1 Example 2:
Input: [2,2,2,0,1] Output: 0 Note:
This is a follow up problem to Find Minimum in Rotated Sorted Array.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0155.Min-Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0155.Min-Stack/</guid><description>155. Min Stack # 题目 # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
push(x) &amp;ndash; Push element x onto stack. pop() &amp;ndash; Removes the element on top of the stack. top() &amp;ndash; Get the top element. getMin() &amp;ndash; Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0160.Intersection-of-Two-Linked-Lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0160.Intersection-of-Two-Linked-Lists/</guid><description>160. Intersection of Two Linked Lists # 题目 # Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
begin to intersect at node c1.
Example 1:
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0162.Find-Peak-Element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0162.Find-Peak-Element/</guid><description>162. Find Peak Element # 题目 # A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -∞.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0164.Maximum-Gap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0164.Maximum-Gap/</guid><description>164. Maximum Gap # 题目 # Given an unsorted array, find the maximum difference between the successive elements in its sorted form.
Return 0 if the array contains less than 2 elements.
Example 1:
Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2:
Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0167.Two-Sum-II-Input-array-is-sorted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0167.Two-Sum-II-Input-array-is-sorted/</guid><description>167. Two Sum II - Input array is sorted # 题目 # Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
Note:
Your returned answers (both index1 and index2) are not zero-based.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0168.Excel-Sheet-Column-Title/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0168.Excel-Sheet-Column-Title/</guid><description>168. Excel Sheet Column Title # 题目 # Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:
1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ... Example 1:
Input: 1 Output: &amp;quot;A&amp;quot; Example 2:
Input: 28 Output: &amp;quot;AB&amp;quot; Example 3:
Input: 701 Output: &amp;quot;ZY&amp;quot; 题目大意 # 给定一个正整数，返回它在 Excel 表中相对应的列名称。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0169.Majority-Element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0169.Majority-Element/</guid><description>169. Majority Element # 题目 # Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example 1:
Input: [3,2,3] Output: 3 Example 2:
Input: [2,2,1,1,1,2,2] Output: 2 题目大意 # 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0171.Excel-Sheet-Column-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0171.Excel-Sheet-Column-Number/</guid><description>171. Excel Sheet Column Number # 题目 # Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... Example 1:
Input: &amp;quot;A&amp;quot; Output: 1 Example 2:
Input: &amp;quot;AB&amp;quot; Output: 28 Example 3:
Input: &amp;quot;ZY&amp;quot; Output: 701 题目大意 # 给定一个 Excel 表格中的列名称，返回其相应的列序号。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0172.Factorial-Trailing-Zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0172.Factorial-Trailing-Zeroes/</guid><description>172. Factorial Trailing Zeroes # 题目 # Given an integer n, return the number of trailing zeroes in n!.
Example 1:
Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2:
Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.
题目大意 # 给定一个整数 n，返回 n! 结果尾数中零的数量。说明: 你算法的时间复杂度应为 O(log n) 。
解题思路 # 给出一个数 n，要求 n！末尾 0 的个数。 这是一道数学题。计算 N 的阶乘有多少个后缀 0，即计算 N!</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0173.Binary-Search-Tree-Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0173.Binary-Search-Tree-Iterator/</guid><description>173. Binary Search Tree Iterator # 题目 # Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Example:
BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0174.Dungeon-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0174.Dungeon-Game/</guid><description>174. Dungeon Game # 题目 # The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.
The knight has an initial health point represented by a positive integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0179.Largest-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0179.Largest-Number/</guid><description>179. Largest Number # 题目 # Given a list of non negative integers, arrange them such that they form the largest number.
Example 1:
Input: [10,2] Output: &amp;quot;210&amp;quot; Example 2:
Input: [3,30,34,5,9] Output: &amp;quot;9534330&amp;quot; Note:
The result may be very large, so you need to return a string instead of an integer.
题目大意 # 给出一个数组，要求排列这些数组里的元素，使得最终排列出来的数字是最大的。
解题思路 # 这一题很容易想到把数字都转化为字符串，利用字符串比较，来排序，这样 9 开头的一定排在最前面。不过这样做有一个地方是错误的，比如：&amp;ldquo;3&amp;rdquo; 和 &amp;ldquo;30&amp;rdquo; 比较，&amp;ldquo;30&amp;rdquo; 比 &amp;ldquo;3&amp;rdquo; 的字符序要大，这样排序以后就出错了。实际上就这道题而言， &amp;ldquo;3&amp;rdquo; 应该排在 &amp;ldquo;30&amp;rdquo; 前面。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0187.Repeated-DNA-Sequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0187.Repeated-DNA-Sequences/</guid><description>187. Repeated DNA Sequences # 题目 # All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for Example: &amp;ldquo;ACGAATTCCG&amp;rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.
Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.
Example:
Input: s = &amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot; Output: [&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;] 题目大意 # 所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0189.Rotate-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0189.Rotate-Array/</guid><description>189. Rotate Array # 题目 # Given an array, rotate the array to the right by k steps, where k is non-negative.
Follow up:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0190.Reverse-Bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0190.Reverse-Bits/</guid><description>190. Reverse Bits # 题目 # Reverse bits of a given 32 bits unsigned integer.
Example 1:
Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2:
Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001. Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0191.Number-of-1-Bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0191.Number-of-1-Bits/</guid><description>191. Number of 1 Bits # 题目 # Write a function that takes an unsigned integer and return the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Example 1:
Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2:
Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0198.House-Robber/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0198.House-Robber/</guid><description>198. House Robber # 题目 # You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0199.Binary-Tree-Right-Side-View/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0199.Binary-Tree-Right-Side-View/</guid><description>199. Binary Tree Right Side View # 题目 # Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- 题目大意 # 从右边看一个树，输出看到的数字。注意有遮挡。
解题思路 # 这一题是按层序遍历的变种题。按照层序把每层的元素都遍历出来，然后依次取每一层的最右边的元素即可。用一个队列即可实现。 第 102 题和第 107 题都是按层序遍历的。 代码 # package leetcode /** * Definition for a binary tree node.</description></item></channel></rss>