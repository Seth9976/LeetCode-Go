<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>序 on LeetCode Cookbook</title><link>https://Seth9976.github.io/LeetCode-Go/</link><description>Recent content in 序 on LeetCode Cookbook</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://Seth9976.github.io/LeetCode-Go/index.xml" rel="self" type="application/rss+xml"/><item><title>1.1 数据结构知识</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterOne/Data_Structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterOne/Data_Structure/</guid><description>数据结构知识 # 以下是笔者整理的数据结构相关的知识。希望能把常见的数据结构都枚举穷尽。如有遗漏，欢迎大家赐教，提 PR。相关题目还在慢慢整理中，讲解的文章还在创作中。
刷题只是提升算法能力的手段，最终目的应该是提升自我的思维能力，知识需要凝结成块，那么就把这些总结在第一章这两节中，让它得到升华吧~希望读者在刷完题之后再回过头来看这个表格，能很清晰的梳理自己的知识体系，查缺补漏，尽早完善。
数据结构 变种 相关题目 讲解文章 顺序线性表：向量 Vector 单链表
Singly Linked List 1. 双向链表 Double Linked Lists
2. 静态链表 Static List
3. 对称矩阵 Symmetric Matrix
4. 稀疏矩阵 Sparse Matrix 哈希表
Hash Table 1. 散列函数 Hash Function
2. 解决碰撞/填充因子 Collision Resolution
栈和队列
Stack &amp;amp; Queue 1.</description></item><item><title>2.01 Array</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Array/</guid><description>Array # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0001 Two Sum Go Easy O(n) O(n) 49.7% 0004 Median of Two Sorted Arrays Go Hard 36.2% 0011 Container With Most Water Go Medium O(n) O(1) 54.0% 0015 3Sum Go Medium O(n^2) O(n) ❤️ 32.6% 0016 3Sum Closest Go Medium O(n^2) O(1) ❤️ 45.</description></item><item><title>3.1 Segment Tree</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterThree/Segment_Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterThree/Segment_Tree/</guid><description>线段树 Segment Tree # 线段树 Segment tree 是一种二叉树形数据结构，1977年由 Jon Louis Bentley 发明，用以存储区间或线段，并且允许快速查询结构内包含某一点的所有区间。
一个包含 \(n \) 个区间的线段树，空间复杂度为 \( O(n) \) ，查询的时间复杂度则为 \(O(log n&amp;#43;k) \) ，其中 \( k \) 是符合条件的区间数量。线段树的数据结构也可推广到高维度。
一. 什么是线段树 # 以一维的线段树为例。
令 S 是一维线段的集合。将这些线段的端点坐标由小到大排序，令其为 \(x_{1},x_{2},\cdots ,x_{m} \) 。我们将被这些端点切分的每一个区间称为“单位区间”（每个端点所在的位置会单独成为一个单位区间），从左到右包含：
\[ (-\infty ,x_{1}),[x_{1},x_{1}],(x_{1},x_{2}),[x_{2},x_{2}],...,(x_{m-1},x_{m}),[x_{m},x_{m}],(x_{m},&amp;#43;\infty )\] 线段树的结构为一个二叉树，每个节点都代表一个坐标区间，节点 N 所代表的区间记为 Int(N)，则其需符合以下条件：
其每一个叶节点，从左到右代表每个单位区间。 其内部节点代表的区间是其两个儿子代表的区间之并集。 每个节点（包含叶子）中有一个存储线段的数据结构。若一个线段 S 的坐标区间包含 Int(N) 但不包含 Int(parent(N))，则节点 N 中会存储线段 S。 线段树是二叉树，其中每个节点代表一个区间。通常，一个节点将存储一个或多个合并的区间的数据，以便可以执行查询操作。</description></item><item><title>1.2 算法知识</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterOne/Algorithm/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterOne/Algorithm/</guid><description>算法知识 # 以下是笔者整理的算法相关的知识。希望能把常见的算法都枚举穷尽。如有遗漏，欢迎大家赐教，提 PR。相关题目还在慢慢整理中，讲解的文章还在创作中。
刷题只是提升算法能力的手段，最终目的应该是提升自我的思维能力，知识需要凝结成块，那么就把这些总结在第一章这两节中，让它得到升华吧~希望读者在刷完题之后再回过头来看这个表格，能很清晰的梳理自己的知识体系，查缺补漏，尽早完善。
算法 具体类型 相关题目 讲解文章 排序算法 1. 冒泡排序
2. 插入排序
3. 选择排序
4. 希尔 Shell 排序
5. 快速排序
6. 归并排序
7. 堆排序
8. 线性排序算法
9. 自省排序
10. 间接排序
11. 计数排序
12. 基数排序
13. 桶排序
14. 外部排序 - k 路归并败者树
15. 外部排序 - 最佳归并树 递归与分治 1. 二分搜索/查找
2. 大整数的乘法
3. Strassen 矩阵乘法</description></item><item><title>2.02 String</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/String/</guid><description>String # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0003 Longest Substring Without Repeating Characters Go Medium O(n) O(1) ❤️ 33.8% 0005 Longest Palindromic Substring Go Medium 32.4% 0006 Zigzag Conversion Go Medium 44.8% 0008 String to Integer (atoi) Go Medium 16.6% 0012 Integer to Roman Go Medium 62.</description></item><item><title>3.2 UnionFind</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterThree/UnionFind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterThree/UnionFind/</guid><description>并查集 UnionFind # package template // UnionFind defind // 路径压缩 + 秩优化 type UnionFind struct { parent, rank []int count int } // Init define func (uf *UnionFind) Init(n int) { uf.count = n uf.parent = make([]int, n) uf.rank = make([]int, n) for i := range uf.parent { uf.parent[i] = i } } // Find define func (uf *UnionFind) Find(p int) int { root := p for root != uf.</description></item><item><title>1.3 时间复杂度</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterOne/Time_Complexity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterOne/Time_Complexity/</guid><description>时间复杂度和空间复杂度 # 一. 时间复杂度数据规模 # 1s 内能解决问题的数据规模：10^6 ~ 10^7
O(n^2) 算法可以处理 10^4 级别的数据规模(保守估计，处理 1000 级别的问题肯定没问题) O(n) 算法可以处理 10^8 级别的数据规模(保守估计，处理 10^7 级别的问题肯定没问题) O(nlog n) 算法可以处理 10^7 级别的数据规模(保守估计，处理 10^6 级别的问题肯定没问题) 数据规模 时间复杂度 算法举例 1 10 O(n!) permutation 排列 2 20~30 O(2^n) combination 组合 3 50 O(n^4) DFS 搜索、DP 动态规划 4 100 O(n^3) 任意两点最短路径、DP 动态规划 5 1000 O(n^2) 稠密图、DP 动态规划 6 10^6 O(nlog n) 排序，堆，递归与分治 7 10^7 O(n) DP 动态规划、图遍历、拓扑排序、树遍历 8 10^9 O(sqrt(n)) 筛素数、求平方根 9 10^10 O(log n) 二分搜索 10 +∞ O(1) 数学相关算法 &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash; 一些具有迷惑性的例子：</description></item><item><title>2.03 ✅ Two Pointers</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Two_Pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Two_Pointers/</guid><description>Two Pointers # 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。 left, right := 0, -1 for left &amp;lt; len(s) { if right+1 &amp;lt; len(s) &amp;amp;&amp;amp; freq[s[right+1]-&amp;#39;a&amp;#39;] == 0 { freq[s[right+1]-&amp;#39;a&amp;#39;]++ right++ } else { freq[s[left]-&amp;#39;a&amp;#39;]-- left++ } result = max(result, right-left+1) } 快慢指针可以查找重复数字，时间复杂度 O(n)，第 287 题。 替换字母以后，相同字母能出现连续最长的长度。第 424 题。 SUM 问题集。第 1 题，第 15 题，第 16 题，第 18 题，第 167 题，第 923 题，第 1074 题。 No.</description></item><item><title>3.3 LRUCache</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterThree/LRUCache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterThree/LRUCache/</guid><description>最近最少使用 LRUCache # LRU 是 Least Recently Used 的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。如上图，要插入 F 的时候，此时需要淘汰掉原来的一个页面。
根据 LRU 的策略，每次都淘汰最近最久未使用的页面，所以先淘汰 A 页面。再插入 C 的时候，发现缓存中有 C 页面，这个时候需要把 C 页面放到首位，因为它被使用了。以此类推，插入 G 页面，G 页面是新页面，不在缓存中，所以淘汰掉 B 页面。插入 H 页面，H 页面是新页面，不在缓存中，所以淘汰掉 D 页面。插入 E 的时候，发现缓存中有 E 页面，这个时候需要把 E 页面放到首位。插入 I 页面，I 页面是新页面，不在缓存中，所以淘汰掉 F 页面。
可以发现，LRU 更新和插入新页面都发生在链表首，删除页面都发生在链表尾。
解法一 Get O(1) / Put O(1) # LRU 要求查询尽量高效，O(1) 内查询。那肯定选用 map 查询。修改，删除也要尽量 O(1) 完成。搜寻常见的数据结构，链表，栈，队列，树，图。树和图排除，栈和队列无法任意查询中间的元素，也排除。所以选用链表来实现。但是如果选用单链表，删除这个结点，需要 O(n) 遍历一遍找到前驱结点。所以选用双向链表，在删除的时候也能 O(1) 完成。
由于 Go 的 container 包中的 list 底层实现是双向链表，所以可以直接复用这个数据结构。定义 LRUCache 的数据结构如下：</description></item><item><title>2.04 ✅ Linked List</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Linked_List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Linked_List/</guid><description>Linked List # 巧妙的构造虚拟头结点。可以使遍历处理逻辑更加统一。 灵活使用递归。构造递归条件，使用递归可以巧妙的解题。不过需要注意有些题目不能使用递归，因为递归深度太深会导致超时和栈溢出。 链表区间逆序。第 92 题。 链表寻找中间节点。第 876 题。链表寻找倒数第 n 个节点。第 19 题。只需要一次遍历就可以得到答案。 合并 K 个有序链表。第 21 题，第 23 题。 链表归类。第 86 题，第 328 题。 链表排序，时间复杂度要求 O(n * log n)，空间复杂度 O(1)。只有一种做法，归并排序，至顶向下归并。第 148 题。 判断链表是否存在环，如果有环，输出环的交叉点的下标；判断 2 个链表是否有交叉点，如果有交叉点，输出交叉点。第 141 题，第 142 题，第 160 题。 No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0002 Add Two Numbers Go Medium O(n) O(1) 40.</description></item><item><title>3.4 LFUCache</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterThree/LFUCache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterThree/LFUCache/</guid><description>最不经常最少使用 LFUCache # LFU 是 Least Frequently Used 的缩写，即最不经常最少使用，也是一种常用的页面置换算法，选择访问计数器最小的页面予以淘汰。如下图，缓存中每个页面带一个访问计数器。
根据 LFU 的策略，每访问一次都要更新访问计数器。当插入 B 的时候，发现缓存中有 B，所以增加访问计数器的计数，并把 B 移动到访问计数器从大到小排序的地方。再插入 D，同理先更新计数器，再移动到它排序以后的位置。当插入 F 的时候，缓存中不存在 F，所以淘汰计数器最小的页面的页面，所以淘汰 A 页面。此时 F 排在最下面，计数为 1。
这里有一个比 LRU 特别的地方。如果淘汰的页面访问次数有多个相同的访问次数，选择最靠尾部的。如上图中，A、B、C 三者的访问次数相同，都是 1 次。要插入 F，F 不在缓存中，此时要淘汰 A 页面。F 是新插入的页面，访问次数为 1，排在 C 的前面。也就是说相同的访问次数，按照新旧顺序排列，淘汰掉最旧的页面。这一点是和 LRU 最大的不同的地方。
可以发现，LFU 更新和插入新页面可以发生在链表中任意位置，删除页面都发生在表尾。
解法一 Get O(1) / Put O(1) # LFU 同样要求查询尽量高效，O(1) 内查询。依旧选用 map 查询。修改和删除也需要 O(1) 完成，依旧选用双向链表，继续复用 container 包中的 list 数据结构。LFU 需要记录访问次数，所以每个结点除了存储 key，value，需要再多存储 frequency 访问次数。</description></item><item><title>2.05 ✅ Stack</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Stack/</guid><description>Stack # 括号匹配问题及类似问题。第 20 题，第 921 题，第 1021 题。 栈的基本 pop 和 push 操作。第 71 题，第 150 题，第 155 题，第 224 题，第 225 题，第 232 题，第 946 题，第 1047 题。 利用栈进行编码问题。第 394 题，第 682 题，第 856 题，第 880 题。 单调栈。利用栈维护一个单调递增或者递减的下标数组。第 84 题，第 456 题，第 496 题，第 503 题，第 739 题，第 901 题，第 907 题，第 1019 题。 No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0020 Valid Parentheses Go Easy O(log n) O(1) 40.</description></item><item><title>3.5 Binary Indexed Tree</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterThree/Binary_Indexed_Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterThree/Binary_Indexed_Tree/</guid><description>树状数组 Binary Indexed Tree (二叉索引树) # 树状数组或二叉索引树（Binary Indexed Tree），又以其发明者命名为 Fenwick 树，最早由 Peter M. Fenwick 于 1994 年以 A New Data Structure for Cumulative Frequency Tables 为题发表在 SOFTWARE PRACTICE AND EXPERIENCE 上。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和，区间和。针对区间问题，除了常见的线段树解法，还可以考虑树状数组。它可以以 O(log n) 的时间得到任意前缀和 \( \sum_{i=1}^{j}A[i],1&amp;lt;=j&amp;lt;=N \) ，并同时支持在 O(log n)时间内支持动态单点值的修改(增加或者减少)。空间复杂度 O(n)。
利用数组实现前缀和，查询本来是 O(1)，但是对于频繁更新的数组，每次重新计算前缀和，时间复杂度 O(n)。此时树状数组的优势便立即显现。
一. 一维树状数组概念 # 树状数组名字虽然又有树，又有数组，但是它实际上物理形式还是数组，不过每个节点的含义是树的关系，如上图。树状数组中父子节点下标关系是 \(parent = son &amp;#43; 2^{k}\) ，其中 k 是子节点下标对应二进制末尾 0 的个数。
例如上图中 A 和 B 都是数组。A 数组正常存储数据，B 数组是树状数组。B4，B6，B7 是 B8 的子节点。4 的二进制是 100，4 + \(2^{2}\) = 8，所以 8 是 4 的父节点。同理，7 的二进制 111，7 + \(2^{0}\) = 8，8 也是 7 的父节点。</description></item><item><title>2.06 Tree</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Tree/</guid><description>Tree # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0094 Binary Tree Inorder Traversal Go Easy O(n) O(1) 73.8% 0095 Unique Binary Search Trees II Go Medium 52.3% 0096 Unique Binary Search Trees Go Medium O(n^2) O(n) 59.6% 0098 Validate Binary Search Tree Go Medium O(n) O(1) 32.0% 0099 Recover Binary Search Tree Go Medium O(n) O(1) 51.</description></item><item><title>2.07 Dynamic Programming</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Dynamic_Programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Dynamic_Programming/</guid><description>Dynamic Programming # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0005 Longest Palindromic Substring Go Medium 32.4% 0022 Generate Parentheses Go Medium 72.5% 0032 Longest Valid Parentheses Go Hard 32.8% 0042 Trapping Rain Water Go Hard 59.3% 0045 Jump Game II Go Medium 39.</description></item><item><title>2.08 ✅ Backtracking</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Backtracking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Backtracking/</guid><description>Backtracking # 排列问题 Permutations。第 46 题，第 47 题。第 60 题，第 526 题，第 996 题。 组合问题 Combination。第 39 题，第 40 题，第 77 题，第 216 题。 排列和组合杂交问题。第 1079 题。 N 皇后终极解法(二进制解法)。第 51 题，第 52 题。 数独问题。第 37 题。 四个方向搜索。第 79 题，第 212 题，第 980 题。 子集合问题。第 78 题，第 90 题。 Trie。第 208 题，第 211 题。 BFS 优化。第 126 题，第 127 题。 DFS 模板。(只是一个例子，不对应任何题) func combinationSum2(candidates []int, target int) [][]int { if len(candidates) == 0 { return [][]int{} } c, res := []int{}, [][]int{} sort.</description></item><item><title>2.09 Depth First Search</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Depth_First_Search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Depth_First_Search/</guid><description>Depth First Search # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0094 Binary Tree Inorder Traversal Go Easy 73.8% 0098 Validate Binary Search Tree Go Medium O(n) O(1) 32.0% 0099 Recover Binary Search Tree Go Medium O(n) O(1) 51.0% 0100 Same Tree Go Easy O(n) O(1) 58.2% 0101 Symmetric Tree Go Easy O(n) O(1) 54.</description></item><item><title>2.10 Breadth First Search</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Breadth_First_Search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Breadth_First_Search/</guid><description>Breadth First Search # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0100 Same Tree Go Easy 58.2% 0101 Symmetric Tree Go Easy O(n) O(1) 54.3% 0102 Binary Tree Level Order Traversal Go Medium O(n) O(1) 64.4% 0103 Binary Tree Zigzag Level Order Traversal Go Medium O(n) O(n) 56.9% 0104 Maximum Depth of Binary Tree Go Easy 73.</description></item><item><title>2.11 Binary Search</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Binary_Search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Binary_Search/</guid><description>Binary Search # 二分搜索的经典写法。需要注意的三点： 循环退出条件，注意是 low &amp;lt;= high，而不是 low &amp;lt; high。 mid 的取值，mid := low + (high-low)&amp;raquo;1 low 和 high 的更新。low = mid + 1，high = mid - 1。 func binarySearchMatrix(nums []int, target int) int { low, high := 0, len(nums)-1 for low &amp;lt;= high { mid := low + (high-low)&amp;gt;&amp;gt;1 if nums[mid] == target { return mid } else if nums[mid] &amp;gt; target { high = mid - 1 } else { low = mid + 1 } } return -1 } 二分搜索的变种写法。有 4 个基本变种: 查找第一个与 target 相等的元素，时间复杂度 O(logn) 查找最后一个与 target 相等的元素，时间复杂度 O(logn) 查找第一个大于等于 target 的元素，时间复杂度 O(logn) 查找最后一个小于等于 target 的元素，时间复杂度 O(logn) // 二分查找第一个与 target 相等的元素，时间复杂度 O(logn) func searchFirstEqualElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low &amp;lt;= high { mid := low + ((high - low) &amp;gt;&amp;gt; 1) if nums[mid] &amp;gt; target { high = mid - 1 } else if nums[mid] &amp;lt; target { low = mid + 1 } else { if (mid == 0) || (nums[mid-1] !</description></item><item><title>2.12 Math</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Math/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Math/</guid><description>Math # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0002 Add Two Numbers Go Medium O(n) O(1) 40.4% 0007 Reverse Integer Go Medium 27.5% 0009 Palindrome Number Go Easy 53.5% 0012 Integer to Roman Go Medium 62.0% 0013 Roman to Integer Go Easy 58.</description></item><item><title>2.13 Hash Table</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Hash_Table/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Hash_Table/</guid><description>Hash Table # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0001 Two Sum Go Easy O(n) O(n) 49.7% 0003 Longest Substring Without Repeating Characters Go Medium O(n) O(1) ❤️ 33.8% 0012 Integer to Roman Go Medium 62.0% 0013 Roman to Integer Go Easy 58.6% 0017 Letter Combinations of a Phone Number Go Medium 56.</description></item><item><title>2.14 ✅ Sorting</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Sorting/</guid><description>Sorting # 深刻的理解多路快排。第 75 题。 链表的排序，插入排序(第 147 题)和归并排序(第 148 题) 桶排序和基数排序。第 164 题。 &amp;ldquo;摆动排序&amp;rdquo;。第 324 题。 两两不相邻的排序。第 767 题，第 1054 题。 &amp;ldquo;饼子排序&amp;rdquo;。第 969 题。 No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0015 3Sum Go Medium 32.6% 0016 3Sum Closest Go Medium 45.8% 0018 4Sum Go Medium 35.</description></item><item><title>2.15 ✅ Bit Manipulation</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Bit_Manipulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Bit_Manipulation/</guid><description>Bit Manipulation # 异或的特性。第 136 题，第 268 题，第 389 题，第 421 题， x ^ 0 = x x ^ 11111……1111 = ~x x ^ (~x) = 11111……1111 x ^ x = 0 a ^ b = c =&amp;gt; a ^ c = b =&amp;gt; b ^ c = a (交换律) a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ c (结合律) 构造特殊 Mask，将特殊位置放 0 或 1。 将 x 最右边的 n 位清零， x &amp;amp; ( ~0 &amp;lt;&amp;lt; n ) 获取 x 的第 n 位值(0 或者 1)，(x &amp;gt;&amp;gt; n) &amp;amp; 1 获取 x 的第 n 位的幂值，x &amp;amp; (1 &amp;lt;&amp;lt; (n - 1)) 仅将第 n 位置为 1，x | (1 &amp;lt;&amp;lt; n) 仅将第 n 位置为 0，x &amp;amp; (~(1 &amp;lt;&amp;lt; n)) 将 x 最高位至第 n 位(含)清零，x &amp;amp; ((1 &amp;lt;&amp;lt; n) - 1) 将第 n 位至第 0 位(含)清零，x &amp;amp; (~((1 &amp;lt;&amp;lt; (n + 1)) - 1)） 有特殊意义的 &amp;amp; 位操作运算。第 260 题，第 201 题，第 318 题，第 371 题，第 397 题，第 461 题，第 693 题， X &amp;amp; 1 == 1 判断是否是奇数(偶数) X &amp;amp; = (X - 1) 将最低位(LSB)的 1 清零 X &amp;amp; -X 得到最低位(LSB)的 1 X &amp;amp; ~X = 0 No.</description></item><item><title>2.16 ✅ Union Find</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Union_Find/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Union_Find/</guid><description>Union Find # 灵活使用并查集的思想，熟练掌握并查集的 模板，模板中有两种并查集的实现方式，一种是路径压缩 + 秩优化的版本，另外一种是计算每个集合中元素的个数 + 最大集合元素个数的版本，这两种版本都有各自使用的地方。能使用第一类并查集模板的题目有：第 128 题，第 130 题，第 547 题，第 684 题，第 721 题，第 765 题，第 778 题，第 839 题，第 924 题，第 928 题，第 947 题，第 952 题，第 959 题，第 990 题。能使用第二类并查集模板的题目有：第 803 题，第 952 题。第 803 题秩优化和统计集合个数这些地方会卡时间，如果不优化，会 TLE。 并查集是一种思想，有些题需要灵活使用这种思想，而不是死套模板，如第 399 题，这一题是 stringUnionFind，利用并查集思想实现的。这里每个节点是基于字符串和 map 的，而不是单纯的用 int 节点编号实现的。 有些题死套模板反而做不出来，比如第 685 题，这一题不能路径压缩和秩优化，因为题目中涉及到有向图，需要知道节点的前驱节点，如果路径压缩了，这一题就没法做了。这一题不需要路径压缩和秩优化。 灵活的抽象题目给的信息，将给定的信息合理的编号，使用并查集解题，并用 map 降低时间复杂度，如第 721 题，第 959 题。 关于地图，砖块，网格的题目，可以新建一个特殊节点，将四周边缘的砖块或者网格都 union() 到这个特殊节点上。第 130 题，第 803 题。 能用并查集的题目，一般也可以用 DFS 和 BFS 解答，只不过时间复杂度会高一点。 No.</description></item><item><title>2.17 ✅ Sliding Window</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Sliding_Window/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Sliding_Window/</guid><description>Sliding Window # 双指针滑动窗口的经典写法。右指针不断往右移，移动到不能往右移动为止(具体条件根据题目而定)。当右指针到最右边以后，开始挪动左指针，释放窗口左边界。第 3 题，第 76 题，第 209 题，第 424 题，第 438 题，第 567 题，第 713 题，第 763 题，第 845 题，第 881 题，第 904 题，第 978 题，第 992 题，第 1004 题，第 1040 题，第 1052 题。 left, right := 0, -1 for left &amp;lt; len(s) { if right+1 &amp;lt; len(s) &amp;amp;&amp;amp; freq[s[right+1]-&amp;#39;a&amp;#39;] == 0 { freq[s[right+1]-&amp;#39;a&amp;#39;]++ right++ } else { freq[s[left]-&amp;#39;a&amp;#39;]-- left++ } result = max(result, right-left+1) } 滑动窗口经典题。第 239 题，第 480 题。 No.</description></item><item><title>2.18 ✅ Segment Tree</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Segment_Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Segment_Tree/</guid><description>Segment Tree # 线段树的经典数组实现写法。将合并两个节点 pushUp 逻辑抽象出来了，可以实现任意操作(常见的操作有：加法，取 max，min 等等)。第 218 题，第 303 题，第 307 题，第 699 题。 计数线段树的经典写法。第 315 题，第 327 题，第 493 题。 线段树的树的实现写法。第 715 题，第 732 题。 区间懒惰更新。第 218 题，第 699 题。 离散化。离散化需要注意一个特殊情况：假如三个区间为 [1,10] [1,4] [6,10]，离散化后 x[1]=1,x[2]=4,x[3]=6,x[4]=10。第一个区间为 [1,4]，第二个区间为 [1,2]，第三个区间为 [3,4]，这样一来，区间一 = 区间二 + 区间三，这和离散前的模型不符，离散前，很明显，区间一 &amp;gt; 区间二 + 区间三。正确的做法是：在相差大于 1 的数间加一个数，例如在上面 1 4 6 10 中间加 5，即可 x[1]=1,x[2]=4,x[3]=5,x[4]=6,x[5]=10。这样处理之后，区间一是 1-5 ，区间二是 1-2 ，区间三是 4-5 。 灵活构建线段树。线段树节点可以存储多条信息，合并两个节点的 pushUp 操作也可以是多样的。第 850 题，第 1157 题。 线段树 题型从简单到困难:</description></item><item><title>2.19 ✅ Binary Indexed Tree</title><link>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Binary_Indexed_Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterTwo/Binary_Indexed_Tree/</guid><description>Binary Indexed Tree # No. Title Solution Difficulty TimeComplexity SpaceComplexity Favorite Acceptance 0218 The Skyline Problem Go Hard 41.9% 0307 Range Sum Query - Mutable Go Medium 40.7% 0315 Count of Smaller Numbers After Self Go Hard 42.6% 0327 Count of Range Sum Go Hard 35.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0001.Two-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0001.Two-Sum/</guid><description>1. Two Sum # 题目 # Given an array of integers, return indices of the two numbers such that they add up to a specific target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
Example:
Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1] 题目大意 # 在数组中找到 2 个数之和等于给定值的数字，结果返回 2 个数字在数组中的下标。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0002.Add-Two-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0002.Add-Two-Numbers/</guid><description>2. Add Two Numbers # 题目 # You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Example:
Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) Output: 7 -&amp;gt; 0 -&amp;gt; 8 Explanation: 342 + 465 = 807.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0003.Longest-Substring-Without-Repeating-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0003.Longest-Substring-Without-Repeating-Characters/</guid><description>3. Longest Substring Without Repeating Characters # 题目 # Given a string, find the length of the longest substring without repeating characters.
Example 1:
Input: &amp;quot;abcabcbb&amp;quot; Output: 3 Explanation: The answer is &amp;quot;abc&amp;quot;, with the length of 3. Example 2:
Input: &amp;quot;bbbbb&amp;quot; Output: 1 Explanation: The answer is &amp;quot;b&amp;quot;, with the length of 1. Example 3:
Input: &amp;quot;pwwkew&amp;quot; Output: 3 Explanation: The answer is &amp;quot;wke&amp;quot;, with the length of 3.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0004.Median-of-Two-Sorted-Arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0004.Median-of-Two-Sorted-Arrays/</guid><description>4. Median of Two Sorted Arrays # 题目 # There are two sorted arrays nums1 and nums2 of size m and n respectively.
Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
You may assume nums1 and nums2 cannot be both empty.
Example 1:
nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2:
nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0005.Longest-Palindromic-Substring/</guid><description>5. Longest Palindromic Substring # 题目 # Given a string s, return the longest palindromic substring in s.
Example 1:
Input: s = &amp;quot;babad&amp;quot; Output: &amp;quot;bab&amp;quot; Note: &amp;quot;aba&amp;quot; is also a valid answer. Example 2:
Input: s = &amp;quot;cbbd&amp;quot; Output: &amp;quot;bb&amp;quot; Example 3:
Input: s = &amp;quot;a&amp;quot; Output: &amp;quot;a&amp;quot; Example 4:
Input: s = &amp;quot;ac&amp;quot; Output: &amp;quot;a&amp;quot; Constraints:
1 &amp;lt;= s.length &amp;lt;= 1000 s consist of only digits and English letters (lower-case and/or upper-case), 题目大意 # 给你一个字符串 s，找到 s 中最长的回文子串。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0006.ZigZag-Conversion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0006.ZigZag-Conversion/</guid><description>6. ZigZag Conversion # 题目 # The string &amp;quot;PAYPALISHIRING&amp;quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
P A H N A P L S I I G Y I R And then read line by line: &amp;quot;PAHNAPLSIIGYIR&amp;quot;
Write the code that will take a string and make this conversion given a number of rows:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0007.Reverse-Integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0007.Reverse-Integer/</guid><description>7. Reverse Integer # 题目 # Given a 32-bit signed integer, reverse digits of an integer.
Example 1:
Input: 123 Output: 321 Example 2:
Input: -123 Output: -321 Example 3:
Input: 120 Output: 21 Note: Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0008.String-to-Integer-atoi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0008.String-to-Integer-atoi/</guid><description>8. String to Integer (atoi) # 题目 # Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).
The algorithm for myAtoi(string s) is as follows:
Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0009.Palindrome-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0009.Palindrome-Number/</guid><description>9. Palindrome Number # 题目 # Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.
Example 1:
Input: 121 Output: true Example 2:
Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:
Input: 10 Output: false Explanation: Reads 01 from right to left.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0011.Container-With-Most-Water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0011.Container-With-Most-Water/</guid><description>11. Container With Most Water # 题目 # Given n non-negative integers a1, a2, &amp;hellip;, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0012.Integer-to-Roman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0012.Integer-to-Roman/</guid><description>12. Integer to Roman # 题目 # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two one&amp;rsquo;s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0013.Roman-to-Integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0013.Roman-to-Integer/</guid><description>13. Roman to Integer # 题目 # Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one&amp;rsquo;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0014.Longest-Common-Prefix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0014.Longest-Common-Prefix/</guid><description>14. Longest Common Prefix # 题目 # Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string &amp;ldquo;&amp;rdquo;.
Example 1:
Input: strs = [&amp;quot;flower&amp;quot;,&amp;quot;flow&amp;quot;,&amp;quot;flight&amp;quot;] Output: &amp;quot;fl&amp;quot; Example 2:
Input: strs = [&amp;quot;dog&amp;quot;,&amp;quot;racecar&amp;quot;,&amp;quot;car&amp;quot;] Output: &amp;quot;&amp;quot; Explanation: There is no common prefix among the input strings. Constraints:
1 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0015.3Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0015.3Sum/</guid><description>15. 3Sum # 题目 # Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.
Note:
The solution set must not contain duplicate triplets.
Example:
Given array nums = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] 题目大意 # 给定一个数组，要求在这个数组中找出 3 个数之和为 0 的所有组合。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0016.3Sum-Closest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0016.3Sum-Closest/</guid><description>16. 3Sum Closest # 题目 # Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.
Example:
Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0017.Letter-Combinations-of-a-Phone-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0017.Letter-Combinations-of-a-Phone-Number/</guid><description>17. Letter Combinations of a Phone Number # 题目 # Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
Example:
Input: &amp;quot;23&amp;quot; Output: [&amp;quot;ad&amp;quot;, &amp;quot;ae&amp;quot;, &amp;quot;af&amp;quot;, &amp;quot;bd&amp;quot;, &amp;quot;be&amp;quot;, &amp;quot;bf&amp;quot;, &amp;quot;cd&amp;quot;, &amp;quot;ce&amp;quot;, &amp;quot;cf&amp;quot;]. Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0018.4Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0018.4Sum/</guid><description>18. 4Sum # 题目 # Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note:
The solution set must not contain duplicate quadruplets.
Example:
Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0019.Remove-Nth-Node-From-End-of-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0019.Remove-Nth-Node-From-End-of-List/</guid><description>19. Remove Nth Node From End of List # 题目 # Given the head of a linked list, remove the nth node from the end of the list and return its head.
Follow up: Could you do this in one pass?
Example 1:
Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:
Input: head = [1], n = 1 Output: [] Example 3:
Input: head = [1,2], n = 1 Output: [1] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0020.Valid-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0020.Valid-Parentheses/</guid><description>20. Valid Parentheses # 题目 # Given a string containing just the characters &amp;lsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;rsquo;, determine if the input string is valid.
An input string is valid if:
Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid.
Example 1:
Input: &amp;quot;()&amp;quot; Output: true Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0021.Merge-Two-Sorted-Lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0021.Merge-Two-Sorted-Lists/</guid><description>21. Merge Two Sorted Lists # 题目 # Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.
Example:
Input: 1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 题目大意 # 合并 2 个有序链表
解题思路 # 按照题意做即可。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0022.Generate-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0022.Generate-Parentheses/</guid><description>22. Generate Parentheses # 题目 # Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[ &amp;quot;((()))&amp;quot;, &amp;quot;(()())&amp;quot;, &amp;quot;(())()&amp;quot;, &amp;quot;()(())&amp;quot;, &amp;quot;()()()&amp;quot; ] 题目大意 # 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。
解题思路 # 这道题乍一看需要判断括号是否匹配的问题，如果真的判断了，那时间复杂度就到 O(n * 2^n)了，虽然也可以 AC，但是时间复杂度巨高。 这道题实际上不需要判断括号是否匹配的问题。因为在 DFS 回溯的过程中，会让 ( 和 ) 成对的匹配上的。 代码 # package leetcode func generateParenthesis(n int) []string { if n == 0 { return []string{} } res := []string{} findGenerateParenthesis(n, n, &amp;#34;&amp;#34;, &amp;amp;res) return res } func findGenerateParenthesis(lindex, rindex int, str string, res *[]string) { if lindex == 0 &amp;amp;&amp;amp; rindex == 0 { *res = append(*res, str) return } if lindex &amp;gt; 0 { findGenerateParenthesis(lindex-1, rindex, str+&amp;#34;(&amp;#34;, res) } if rindex &amp;gt; 0 &amp;amp;&amp;amp; lindex &amp;lt; rindex { findGenerateParenthesis(lindex, rindex-1, str+&amp;#34;)&amp;#34;, res) } } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0023.Merge-k-Sorted-Lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0023.Merge-k-Sorted-Lists/</guid><description>23. Merge k Sorted Lists # 题目 # Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
Example:
Input: [ 1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6 ] Output: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 题目大意 # 合并 K 个有序链表
解题思路 # 借助分治的思想，把 K 个有序链表两两合并即可。相当于是第 21 题的加强版。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { length := len(lists) if length &amp;lt; 1 { return nil } if length == 1 { return lists[0] } num := length / 2 left := mergeKLists(lists[:num]) right := mergeKLists(lists[num:]) return mergeTwoLists1(left, right) } func mergeTwoLists1(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } if l2 == nil { return l1 } if l1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0024.Swap-Nodes-in-Pairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0024.Swap-Nodes-in-Pairs/</guid><description>24. Swap Nodes in Pairs # 题目 # Given a linked list, swap every two adjacent nodes and return its head.
You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.
Example:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, you should return the list as 2-&amp;gt;1-&amp;gt;4-&amp;gt;3. 题目大意 # 两两相邻的元素，翻转链表
解题思路 # 按照题意做即可。
代码 # package leetcode import ( &amp;#34;github.com/halfrost/leetcode-go/structures&amp;#34; ) // ListNode define type ListNode = structures.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0025.Reverse-Nodes-in-k-Group/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0025.Reverse-Nodes-in-k-Group/</guid><description>25. Reverse Nodes in k-Group # 题目 # Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0026.Remove-Duplicates-from-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0026.Remove-Duplicates-from-Sorted-Array/</guid><description>26. Remove Duplicates from Sorted Array # 题目 # Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0027.Remove-Element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0027.Remove-Element/</guid><description>27. Remove Element # 题目 # Given an array nums and a value val, remove all instances of that value in-place and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
The order of elements can be changed. It doesn&amp;rsquo;t matter what you leave beyond the new length.
Example 1:
Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0028.Find-the-Index-of-the-First-Occurrence-in-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0028.Find-the-Index-of-the-First-Occurrence-in-a-String/</guid><description>28. Find the Index of the First Occurrence in a String # 题目 # Implement strStr().
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example 1:
Input: haystack = &amp;quot;hello&amp;quot;, needle = &amp;quot;ll&amp;quot; Output: 2 Example 2:
Input: haystack = &amp;quot;aaaaa&amp;quot;, needle = &amp;quot;bba&amp;quot; Output: -1 Clarification:
What should we return when needle is an empty string?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0029.Divide-Two-Integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0029.Divide-Two-Integers/</guid><description>29. Divide Two Integers # 题目 # Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.
Return the quotient after dividing dividend by divisor.
The integer division should truncate toward zero.
Example 1:
Input: dividend = 10, divisor = 3 Output: 3 Example 2:
Input: dividend = 7, divisor = -3 Output: -2 Note:
Both dividend and divisor will be 32-bit signed integers.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0030.Substring-with-Concatenation-of-All-Words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0030.Substring-with-Concatenation-of-All-Words/</guid><description>30. Substring with Concatenation of All Words # 题目 # You are given a string, s, and a list of words, words, that are all of the same length. Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.
Example 1:
Input: s = &amp;quot;barfoothefoobarman&amp;quot;, words = [&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;] Output: [0,9] Explanation: Substrings starting at index 0 and 9 are &amp;quot;barfoor&amp;quot; and &amp;quot;foobar&amp;quot; respectively.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0031.Next-Permutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0031.Next-Permutation/</guid><description>31. Next Permutation # 题目 # Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.
If such an arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).
The replacement must be  in place and use only constant extra memory.
Example 1:
Input: nums = [1,2,3] Output: [1,3,2] Example 2:
Input: nums = [3,2,1] Output: [1,2,3] Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0032.Longest-Valid-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0032.Longest-Valid-Parentheses/</guid><description>32. Longest Valid Parentheses # 题目 # Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.
Example 1:
Input: s = &amp;quot;(()&amp;quot; Output: 2 Explanation: The longest valid parentheses substring is &amp;quot;()&amp;quot;. Example 2:
Input: s = &amp;quot;)()())&amp;quot; Output: 4 Explanation: The longest valid parentheses substring is &amp;quot;()()&amp;quot;. Example 3:
Input: s = &amp;quot;&amp;quot; Output: 0 Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0033.Search-in-Rotated-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0033.Search-in-Rotated-Sorted-Array/</guid><description>33. Search in Rotated Sorted Array # 题目 # Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0034.Find-First-and-Last-Position-of-Element-in-Sorted-Array/</guid><description>34. Find First and Last Position of Element in Sorted Array # 题目 # Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm&amp;rsquo;s runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].
Example 1:
Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0035.Search-Insert-Position/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0035.Search-Insert-Position/</guid><description>35. Search Insert Position # 题目 # Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.
You may assume no duplicates in the array.
Example 1:
Input: [1,3,5,6], 5 Output: 2 Example 2:
Input: [1,3,5,6], 2 Output: 1 Example 3:
Input: [1,3,5,6], 7 Output: 4 Example 4:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0036.Valid-Sudoku/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0036.Valid-Sudoku/</guid><description>36. Valid Sudoku # 题目 # Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition. A partially filled sudoku which is valid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0037.Sudoku-Solver/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0037.Sudoku-Solver/</guid><description>37. Sudoku Solver # 题目 # Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:
Each of the digits 1-9 must occur exactly once in each row. Each of the digits 1-9 must occur exactly once in each column. Each of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0039.Combination-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0039.Combination-Sum/</guid><description>39. Combination Sum # 题目 # Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
Note:
All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: candidates = [2,3,6,7], target = 7, A solution set is: [ [7], [2,2,3] ] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0040.Combination-Sum-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0040.Combination-Sum-II/</guid><description>40. Combination Sum II # 题目 # Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
Each number in candidates may only be used once in the combination.
Note:
All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8, A solution set is: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0041.First-Missing-Positive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0041.First-Missing-Positive/</guid><description>41. First Missing Positive # 题目 # Given an unsorted integer array, find the smallest missing positive integer.
Example 1:
Input: [1,2,0] Output: 3 Example 2:
Input: [3,4,-1,1] Output: 2 Example 3:
Input: [7,8,9,11,12] Output: 1 Note:
Your algorithm should run in O(n) time and uses constant extra space.
题目大意 # 找到缺失的第一个正整数。
解题思路 # 为了减少时间复杂度，可以把 input 数组都装到 map 中，然后 i 循环从 1 开始，依次比对 map 中是否存在 i，只要不存在 i 就立即返回结果，即所求。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0042.Trapping-Rain-Water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0042.Trapping-Rain-Water/</guid><description>42. Trapping Rain Water # 题目 # Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!
Example:
Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 题目大意 # 从 x 轴开始，给出一个数组，数组里面的数字代表从 (0,0) 点开始，宽度为 1 个单位，高度为数组元素的值。如果下雨了，问这样一个容器能装多少单位的水？</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0043.Multiply-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0043.Multiply-Strings/</guid><description>43. Multiply Strings # 题目 # Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Note: You must not use any built-in BigInteger library or convert the inputs to integer directly.
Example 1:
Input: num1 = &amp;quot;2&amp;quot;, num2 = &amp;quot;3&amp;quot; Output: &amp;quot;6&amp;quot; Example 2:
Input: num1 = &amp;quot;123&amp;quot;, num2 = &amp;quot;456&amp;quot; Output: &amp;quot;56088&amp;quot; Constraints:
1 &amp;lt;= num1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0045.Jump-Game-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0045.Jump-Game-II/</guid><description>45. Jump Game II # 题目 # Given an array of non-negative integers nums, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Your goal is to reach the last index in the minimum number of jumps.
You can assume that you can always reach the last index.
Example 1:
Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0046.Permutations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0046.Permutations/</guid><description>46. Permutations # 题目 # Given a collection of distinct integers, return all possible permutations.
Example:
Input: [1,2,3] Output: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 题目大意 # 给定一个没有重复数字的序列，返回其所有可能的全排列。
解题思路 # 求出一个数组的排列组合中的所有排列，用 DFS 深搜即可。 代码 # package leetcode func permute(nums []int) [][]int { if len(nums) == 0 { return [][]int{} } used, p, res := make([]bool, len(nums)), []int{}, [][]int{} generatePermutation(nums, 0, p, &amp;amp;res, &amp;amp;used) return res } func generatePermutation(nums []int, index int, p []int, res *[][]int, used *[]bool) { if index == len(nums) { temp := make([]int, len(p)) copy(temp, p) *res = append(*res, temp) return } for i := 0; i &amp;lt; len(nums); i++ { if !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0047.Permutations-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0047.Permutations-II/</guid><description>47. Permutations II # 题目 # Given a collection of numbers that might contain duplicates, return all possible unique permutations.
Example:
Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1] ] 题目大意 # 给定一个可包含重复数字的序列，返回所有不重复的全排列。
解题思路 # 这一题是第 46 题的加强版，第 46 题中求数组的排列，数组中元素不重复，但是这一题中，数组元素会重复，所以需要最终排列出来的结果需要去重。 去重的方法是经典逻辑，将数组排序以后，判断重复元素再做逻辑判断。 其他思路和第 46 题完全一致，DFS 深搜即可。 代码 # package leetcode import &amp;#34;sort&amp;#34; func permuteUnique(nums []int) [][]int { if len(nums) == 0 { return [][]int{} } used, p, res := make([]bool, len(nums)), []int{}, [][]int{} sort.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0048.Rotate-Image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0048.Rotate-Image/</guid><description>48. Rotate Image # 题目 # You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Note:
You have to rotate the image  in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.
Example 1:
Given input matrix = [ [1,2,3], [4,5,6], [7,8,9] ], rotate the input matrix in-place such that it becomes: [ [7,4,1], [8,5,2], [9,6,3] ] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0049.Group-Anagrams/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0049.Group-Anagrams/</guid><description>49. Group Anagrams # 题目 # Given an array of strings, group anagrams together.
Example:
Input: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;], Output: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ] Note:
All inputs will be in lowercase. The order of your output does not matter. 题目大意 # 给出一个字符串数组，要求对字符串数组里面有 Anagrams 关系的字符串进行分组。Anagrams 关系是指两个字符串的字符完全相同，顺序不同，两者是由排列组合组成。
解题思路 # 这道题可以将每个字符串都排序，排序完成以后，相同 Anagrams 的字符串必然排序结果一样。把排序以后的字符串当做 key 存入到 map 中。遍历数组以后，就能得到一个 map，key 是排序以后的字符串，value 对应的是这个排序字符串以后的 Anagrams 字符串集合。最后再将这些 value 对应的字符串数组输出即可。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0050.Powx-n/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0050.Powx-n/</guid><description>50. Pow(x, n) # 题目 # Implement pow(x, n), which calculates x raised to the power n (xn).
Example 1:
Input: 2.00000, 10 Output: 1024.00000 Example 2:
Input: 2.10000, 3 Output: 9.26100 Example 3:
Input: 2.00000, -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 Note:
-100.0 &amp;lt; x &amp;lt; 100.0 n is a 32-bit signed integer, within the range [−2^31, 2^31− 1] 题目大意 # 实现 pow(x, n) ，即计算 x 的 n 次幂函数。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0051.N-Queens/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0051.N-Queens/</guid><description>51. N-Queens # 题目 # The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle.
Each solution contains a distinct board configuration of the n-queens&amp;rsquo; placement, where 'Q' and '.' both indicate a queen and an empty space respectively.
Example:
Input: 4 Output: [ [&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0052.N-Queens-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0052.N-Queens-II/</guid><description>52. N-Queens II # 题目 # The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
Given an integer n, return the number of distinct solutions to the n-queens puzzle.
Example:
Input: 4 Output: 2 Explanation: There are two distinct solutions to the 4-queens puzzle as shown below. [ [&amp;quot;.Q..&amp;quot;, // Solution 1 &amp;quot;...Q&amp;quot;, &amp;quot;Q...&amp;quot;, &amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0053.Maximum-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0053.Maximum-Subarray/</guid><description>53. Maximum Subarray # 题目 # Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.
Example:
Input: [-2,1,-3,4,-1,2,1,-5,4], Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:
If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
题目大意 # 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0054.Spiral-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0054.Spiral-Matrix/</guid><description>54. Spiral Matrix # 题目 # Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
Example 1:
Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,3,6,9,8,7,4,5] Example 2:
Input: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] Output: [1,2,3,4,8,12,11,10,9,5,6,7] 题目大意 # 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0055.Jump-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0055.Jump-Game/</guid><description>55. Jump Game # 题目 # Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Determine if you are able to reach the last index.
Example 1:
Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0056.Merge-Intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0056.Merge-Intervals/</guid><description>56. Merge Intervals # 题目 # Given a collection of intervals, merge all overlapping intervals.
Example 1:
Input: [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6]. Example 2:
Input: [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. 题目大意 # 合并给的多个区间，区间有重叠的要进行区间合并。
解题思路 # 先按照区间起点进行排序。然后从区间起点小的开始扫描，依次合并每个有重叠的区间。
代码 # package leetcode /** * Definition for an interval. * type Interval struct { * Start int * End int * } */ // Interval define type Interval struct { Start int End int } func merge56(intervals []Interval) []Interval { if len(intervals) == 0 { return intervals } quickSort(intervals, 0, len(intervals)-1) res := make([]Interval, 0) res = append(res, intervals[0]) curIndex := 0 for i := 1; i &amp;lt; len(intervals); i++ { if intervals[i].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0057.Insert-Interval/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0057.Insert-Interval/</guid><description>57. Insert Interval # 题目 # Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).
You may assume that the intervals were initially sorted according to their start times.
Example 1:
Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:
Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0058.Length-of-Last-Word/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0058.Length-of-Last-Word/</guid><description>58. Length of Last Word # 题目 # Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string.
A word is a maximal substring consisting of non-space characters only.
Example 1:
Input: s = &amp;quot;Hello World&amp;quot; Output: 5 Explanation: The last word is &amp;quot;World&amp;quot; with length 5. Example 2:
Input: s = &amp;quot; fly me to the moon &amp;quot; Output: 4 Explanation: The last word is &amp;quot;moon&amp;quot; with length 4.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0059.Spiral-Matrix-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0059.Spiral-Matrix-II/</guid><description>59. Spiral Matrix II # 题目 # Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.
Example:
Input: 3 Output: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 题目大意 # 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
解题思路 # 给出一个数组 n，要求输出一个 n * n 的二维数组，里面元素是 1 - n*n，且数组排列顺序是螺旋排列的 这一题是第 54 题的加强版，没有需要注意的特殊情况，直接模拟即可。 代码 # package leetcode func generateMatrix(n int) [][]int { if n == 0 { return [][]int{} } if n == 1 { return [][]int{[]int{1}} } res, visit, round, x, y, spDir := make([][]int, n), make([][]int, n), 0, 0, 0, [][]int{ []int{0, 1}, // 朝右 []int{1, 0}, // 朝下 []int{0, -1}, // 朝左 []int{-1, 0}, // 朝上 } for i := 0; i &amp;lt; n; i++ { visit[i] = make([]int, n) res[i] = make([]int, n) } visit[x][y] = 1 res[x][y] = 1 for i := 0; i &amp;lt; n*n; i++ { x += spDir[round%4][0] y += spDir[round%4][1] if (x == 0 &amp;amp;&amp;amp; y == n-1) || (x == n-1 &amp;amp;&amp;amp; y == n-1) || (y == 0 &amp;amp;&amp;amp; x == n-1) { round++ } if x &amp;gt; n-1 || y &amp;gt; n-1 || x &amp;lt; 0 || y &amp;lt; 0 { return res } if visit[x][y] == 0 { visit[x][y] = 1 res[x][y] = i + 2 } switch round % 4 { case 0: if y+1 &amp;lt;= n-1 &amp;amp;&amp;amp; visit[x][y+1] == 1 { round++ continue } case 1: if x+1 &amp;lt;= n-1 &amp;amp;&amp;amp; visit[x+1][y] == 1 { round++ continue } case 2: if y-1 &amp;gt;= 0 &amp;amp;&amp;amp; visit[x][y-1] == 1 { round++ continue } case 3: if x-1 &amp;gt;= 0 &amp;amp;&amp;amp; visit[x-1][y] == 1 { round++ continue } } } return res } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0060.Permutation-Sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0060.Permutation-Sequence/</guid><description>60. Permutation Sequence # 题目 # The set [1,2,3,...,*n*] contains a total of n! unique permutations.
By listing and labeling all of the permutations in order, we get the following sequence for n = 3:
&amp;quot;123&amp;quot; &amp;quot;132&amp;quot; &amp;quot;213&amp;quot; &amp;quot;231&amp;quot; &amp;quot;312&amp;quot; &amp;quot;321&amp;quot; Given n and k, return the kth permutation sequence.
Note:
Given n will be between 1 and 9 inclusive. Given k will be between 1 and n!</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0061.Rotate-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0061.Rotate-List/</guid><description>61. Rotate List # 题目 # Given a linked list, rotate the list to the right by k places, where k is non-negative.
Example 1:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 Output: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Explanation: rotate 1 steps to the right: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL rotate 2 steps to the right: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL Example 2:
Input: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL, k = 4 Output: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL Explanation: rotate 1 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL rotate 2 steps to the right: 1-&amp;gt;2-&amp;gt;0-&amp;gt;NULL rotate 3 steps to the right: 0-&amp;gt;1-&amp;gt;2-&amp;gt;NULL rotate 4 steps to the right: 2-&amp;gt;0-&amp;gt;1-&amp;gt;NULL 题目大意 # 旋转链表 K 次。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0062.Unique-Paths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0062.Unique-Paths/</guid><description>62. Unique Paths # 题目 # A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
How many possible unique paths are there?
Above is a 7 x 3 grid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0063.Unique-Paths-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0063.Unique-Paths-II/</guid><description>63. Unique Paths II # 题目 # A robot is located at the top-left corner of a m x n grid (marked &amp;lsquo;Start&amp;rsquo; in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &amp;lsquo;Finish&amp;rsquo; in the diagram below).
Now consider if some obstacles are added to the grids.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0064.Minimum-Path-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0064.Minimum-Path-Sum/</guid><description>64. Minimum Path Sum # 题目 # Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
Example:
Input: [ [1,3,1], [1,5,1], [4,2,1] ] Output: 7 Explanation: Because the path 1→3→1→1→1 minimizes the sum. 题目大意 # 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0065.Valid-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0065.Valid-Number/</guid><description>65. Valid Number # 题目 # A valid number can be split up into these components (in order):
A decimal number or an integer. (Optional) An &amp;lsquo;e&amp;rsquo; or &amp;lsquo;E&amp;rsquo;, followed by an integer. A decimal number can be split up into these components (in order):
(Optional) A sign character (either &amp;lsquo;+&amp;rsquo; or &amp;lsquo;-'). One of the following formats: One or more digits, followed by a dot &amp;lsquo;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0066.Plus-One/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0066.Plus-One/</guid><description>66. Plus One # 题目 # Given a non-empty array of digits representing a non-negative integer, plus one to the integer.
The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.
You may assume the integer does not contain any leading zero, except the number 0 itself.
Example 1:
Input: [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0067.Add-Binary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0067.Add-Binary/</guid><description>67. Add Binary # 题目 # Given two binary strings, return their sum (also a binary string).
The input strings are both non-empty and contains only characters 1 or 0.
Example 1:
Input: a = &amp;quot;11&amp;quot;, b = &amp;quot;1&amp;quot; Output: &amp;quot;100&amp;quot; Example 2:
Input: a = &amp;quot;1010&amp;quot;, b = &amp;quot;1011&amp;quot; Output: &amp;quot;10101&amp;quot; 题目大意 # 给你两个二进制字符串，返回它们的和（用二进制表示）。输入为 非空 字符串且只包含数字 1 和 0。
解题思路 # 要求输出 2 个二进制数的和，结果也用二进制表示。 简单题。按照二进制的加法规则做加法即可。 代码 # package leetcode import ( &amp;#34;strconv&amp;#34; &amp;#34;strings&amp;#34; ) func addBinary(a string, b string) string { if len(b) &amp;gt; len(a) { a, b = b, a } res := make([]string, len(a)+1) i, j, k, c := len(a)-1, len(b)-1, len(a), 0 for i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;gt;= 0 { ai, _ := strconv.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0069.Sqrtx/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0069.Sqrtx/</guid><description>69. Sqrt(x) # 题目 # Implement int sqrt(int x).
Compute and return the square root of x, where x is guaranteed to be a non-negative integer.
Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
Example 1:
Input: 4 Output: 2 Example 2:
Input: 8 Output: 2 Explanation: The square root of 8 is 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0070.Climbing-Stairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0070.Climbing-Stairs/</guid><description>70. Climbing Stairs # 题目 # You are climbing a stair case. It takes n steps to reach to the top.
Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
Note: Given n will be a positive integer.
Example 1:
Input: 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0071.Simplify-Path/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0071.Simplify-Path/</guid><description>71. Simplify Path # 题目 # Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.
In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix
Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0073.Set-Matrix-Zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0073.Set-Matrix-Zeroes/</guid><description>73. Set Matrix Zeroes # 题目 # Given an *m* x *n* matrix. If an element is 0, set its entire row and column to 0. Do it  in-place.
Follow up:
A straight forward solution using O(mn) space is probably a bad idea. A simple improvement uses O(m + n) space, but still not the best solution. Could you devise a constant space solution? Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0074.Search-a-2D-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0074.Search-a-2D-Matrix/</guid><description>74. Search a 2D Matrix # 题目 # Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1:
Input: matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50] ] target = 3 Output: true Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0075.Sort-Colors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0075.Sort-Colors/</guid><description>75. Sort Colors # 题目 # Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.
Note: You are not suppose to use the library&amp;rsquo;s sort function for this problem.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0076.Minimum-Window-Substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0076.Minimum-Window-Substring/</guid><description>76. Minimum Window Substring # 题目 # Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
Example:
Input: S = &amp;quot;ADOBECODEBANC&amp;quot;, T = &amp;quot;ABC&amp;quot; Output: &amp;quot;BANC&amp;quot; Note:
If there is no such window in S that covers all characters in T, return the empty string &amp;ldquo;&amp;rdquo;. If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0077.Combinations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0077.Combinations/</guid><description>77. Combinations # 题目 # Given two integers n and k, return all possible combinations of k numbers out of 1 &amp;hellip; n.
Example:
Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 题目大意 # 给定两个整数 n 和 k，返回 1 &amp;hellip; n 中所有可能的 k 个数的组合。
解题思路 # 计算排列组合中的组合，用 DFS 深搜即可，注意剪枝 代码 # package leetcode func combine(n int, k int) [][]int { if n &amp;lt;= 0 || k &amp;lt;= 0 || k &amp;gt; n { return [][]int{} } c, res := []int{}, [][]int{} generateCombinations(n, k, 1, c, &amp;amp;res) return res } func generateCombinations(n, k, start int, c []int, res *[][]int) { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } // i will at most be n - (k - c.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0078.Subsets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0078.Subsets/</guid><description>78. Subsets # 题目 # Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: nums = [1,2,3] Output: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 题目大意 # 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。
解题思路 # 找出一个集合中的所有子集，空集也算是子集。且数组中的数字不会出现重复。用 DFS 暴力枚举即可。 这一题和第 90 题，第 491 题类似，可以一起解答和复习。 代码 # package leetcode import &amp;#34;sort&amp;#34; // 解法一 func subsets(nums []int) [][]int { c, res := []int{}, [][]int{} for k := 0; k &amp;lt;= len(nums); k++ { generateSubsets(nums, k, 0, c, &amp;amp;res) } return res } func generateSubsets(nums []int, k, start int, c []int, res *[][]int) { if len(c) == k { b := make([]int, len(c)) copy(b, c) *res = append(*res, b) return } // i will at most be n - (k - c.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0079.Word-Search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0079.Word-Search/</guid><description>79. Word Search # 题目 # Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
Example:
board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] Given word = &amp;quot;ABCCED&amp;quot;, return true. Given word = &amp;quot;SEE&amp;quot;, return true.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0080.Remove-Duplicates-from-Sorted-Array-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0080.Remove-Duplicates-from-Sorted-Array-II/</guid><description>80. Remove Duplicates from Sorted Array II # 题目 # Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
Example 1:
Given nums = [1,1,1,2,2,3], Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0081.Search-in-Rotated-Sorted-Array-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0081.Search-in-Rotated-Sorted-Array-II/</guid><description>81. Search in Rotated Sorted Array II # 题目 # Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
You are given a target value to search. If found in the array return true, otherwise return false.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false Follow up:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0082.Remove-Duplicates-from-Sorted-List-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0082.Remove-Duplicates-from-Sorted-List-II/</guid><description>82. Remove Duplicates from Sorted List II # 题目 # Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.
Example 1:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 Output: 1-&amp;gt;2-&amp;gt;5 Example 2:
Input: 1-&amp;gt;1-&amp;gt;1-&amp;gt;2-&amp;gt;3 Output: 2-&amp;gt;3 题目大意 # 删除链表中重复的结点，只要是有重复过的结点，全部删除。
解题思路 # 按照题意做即可。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // 解法一 func deleteDuplicates1(head *ListNode) *ListNode { if head == nil { return nil } if head.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0083.Remove-Duplicates-from-Sorted-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0083.Remove-Duplicates-from-Sorted-List/</guid><description>83. Remove Duplicates from Sorted List # 题目 # Given a sorted linked list, delete all duplicates such that each element appear only once.
Example 1:
Input: 1-&amp;gt;1-&amp;gt;2 Output: 1-&amp;gt;2 Example 2:
Input: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3 题目大意 # 删除链表中重复的结点，以保障每个结点只出现一次。
解题思路 # 按照题意做即可。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func deleteDuplicates(head *ListNode) *ListNode { cur := head if head == nil { return nil } if head.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0084.Largest-Rectangle-in-Histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0084.Largest-Rectangle-in-Histogram/</guid><description>84. Largest Rectangle in Histogram # 题目 # Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].
The largest rectangle is shown in the shaded area, which has area = 10 unit.
Example:
Input: [2,1,5,6,2,3] Output: 10 题目大意 # 给出每个直方图的高度，要求在这些直方图之中找到面积最大的矩形，输出矩形的面积。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0086.Partition-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0086.Partition-List/</guid><description>86. Partition List # 题目 # Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.
You should preserve the original relative order of the nodes in each of the two partitions.
Example:
Input: head = 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;2, x = 3 Output: 1-&amp;gt;2-&amp;gt;2-&amp;gt;4-&amp;gt;3-&amp;gt;5 题目大意 # 给定一个数 x，比 x 大或等于的数字都要排列在比 x 小的数字后面，并且相对位置不能发生变化。由于相对位置不能发生变化，所以不能用类似冒泡排序的思想。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0088.Merge-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0088.Merge-Sorted-Array/</guid><description>88. Merge Sorted Array # 题目 # Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.
Note:
The number of elements initialized in nums1 and nums2 are m and n respectively. You may assume that nums1 has enough space (size that is equal to m + n) to hold additional elements from nums2. Example:
Input: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0089.Gray-Code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0089.Gray-Code/</guid><description>89. Gray Code # 题目 # The gray code is a binary numeral system where two successive values differ in only one bit.
Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.
Example 1:
Input: 2 Output: [0,1,3,2] Explanation: 00 - 0 01 - 1 11 - 3 10 - 2 For a given n, a gray code sequence may not be uniquely defined.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0090.Subsets-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0090.Subsets-II/</guid><description>90. Subsets II # 题目 # Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: [1,2,2] Output: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 题目大意 # 给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。说明：解集不能包含重复的子集。
解题思路 # 这一题是第 78 题的加强版，比第 78 题多了一个条件，数组中的数字会出现重复。 解题方法依旧是 DFS，需要在回溯的过程中加上一些判断。 这一题和第 78 题，第 491 题类似，可以一起解答和复习。 代码 # package leetcode import ( &amp;#34;fmt&amp;#34; &amp;#34;sort&amp;#34; ) func subsetsWithDup(nums []int) [][]int { c, res := []int{}, [][]int{} sort.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0091.Decode-Ways/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0091.Decode-Ways/</guid><description>91. Decode Ways # 题目 # A message containing letters from A-Z is being encoded to numbers using the following mapping:
'A' -&amp;gt; 1 'B' -&amp;gt; 2 ... 'Z' -&amp;gt; 26 Given a non-empty string containing only digits, determine the total number of ways to decode it.
Example 1:
Input: &amp;quot;12&amp;quot; Output: 2 Explanation: It could be decoded as &amp;quot;AB&amp;quot; (1 2) or &amp;quot;L&amp;quot; (12). Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0092.Reverse-Linked-List-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0092.Reverse-Linked-List-II/</guid><description>92. Reverse Linked List II # 题目 # Reverse a linked list from position m to n. Do it in one-pass.
Note: 1 ≤ m ≤ n ≤ length of list.
Example:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 Output: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 题目大意 # 给定 2 个链表中结点的位置 m, n，反转这个两个位置区间内的所有结点。
解题思路 # 由于有可能整个链表都被反转，所以构造一个新的头结点指向当前的头。之后的处理方法是：找到第一个需要反转的结点的前一个结点 p，从这个结点开始，依次把后面的结点用“头插”法，插入到 p 结点的后面。循环次数用 n-m 来控制。
这一题结点可以原地变化，更改各个结点的 next 指针就可以。不需要游标 p 指针。因为每次逆序以后，原有结点的相对位置就发生了变化，相当于游标指针已经移动了，所以不需要再有游标 p = p.Next 的操作了。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0093.Restore-IP-Addresses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0093.Restore-IP-Addresses/</guid><description>93. Restore IP Addresses # 题目 # Given a string containing only digits, restore it by returning all possible valid IP address combinations.
Example:
Input: &amp;quot;25525511135&amp;quot; Output: [&amp;quot;255.255.11.135&amp;quot;, &amp;quot;255.255.111.35&amp;quot;] 题目大意 # 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
解题思路 # DFS 深搜 需要注意的点是 IP 的规则，以 0 开头的数字和超过 255 的数字都为非法的。 代码 # package leetcode import ( &amp;#34;strconv&amp;#34; ) func restoreIPAddresses(s string) []string { if s == &amp;#34;&amp;#34; { return []string{} } res, ip := []string{}, []int{} dfs(s, 0, ip, &amp;amp;res) return res } func dfs(s string, index int, ip []int, res *[]string) { if index == len(s) { if len(ip) == 4 { *res = append(*res, getString(ip)) } return } if index == 0 { num, _ := strconv.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0094.Binary-Tree-Inorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0094.Binary-Tree-Inorder-Traversal/</guid><description>94. Binary Tree Inorder Traversal # 题目 # Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,3,2] Follow up: Recursive solution is trivial, could you do it iteratively?
题目大意 # 中根遍历一颗树。
解题思路 # 递归的实现方法，见代码。
代码 # package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func inorderTraversal(root *TreeNode) []int { var result []int inorder(root, &amp;amp;result) return result } func inorder(root *TreeNode, output *[]int) { if root !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0095.Unique-Binary-Search-Trees-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0095.Unique-Binary-Search-Trees-II/</guid><description>95. Unique Binary Search Trees II # 题目 # Given an integer n, generate all structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n.
Example:
Input: 3 Output: [ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3] ] Explanation: The above output corresponds to the 5 unique BST's shown below: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 题目大意 # 给定一个整数 n，生成所有由 1 &amp;hellip; n 为节点所组成的二叉搜索树。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0096.Unique-Binary-Search-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0096.Unique-Binary-Search-Trees/</guid><description>96. Unique Binary Search Trees # 题目 # Given n, how many structurally unique BST&amp;rsquo;s (binary search trees) that store values 1 &amp;hellip; n?
Example:
Input: 3 Output: 5 Explanation: Given n = 3, there are a total of 5 unique BST's: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 题目大意 # 给定一个整数 n，求以 1 &amp;hellip; n 为节点组成的二叉搜索树有多少种？</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0097.Interleaving-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0097.Interleaving-String/</guid><description>97. Interleaving String # 题目 # Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.
An interleaving of two strings s and t is a configuration where they are divided into non-empty substrings such that:
s = s1 + s2 + ... + sn t = t1 + t2 + ... + tm |n - m| &amp;lt;= 1 The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + .</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0098.Validate-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0098.Validate-Binary-Search-Tree/</guid><description>98. Validate Binary Search Tree # 题目 # Given a binary tree, determine if it is a valid binary search tree (BST).
Assume a BST is defined as follows:
The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node&amp;rsquo;s key. Both the left and right subtrees must also be binary search trees.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0099.Recover-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0001~0099/0099.Recover-Binary-Search-Tree/</guid><description>99. Recover Binary Search Tree # 题目 # Two elements of a binary search tree (BST) are swapped by mistake.
Recover the tree without changing its structure.
Example 1:
Input: [1,3,null,null,2] 1 / 3 \ 2 Output: [3,1,null,null,2] 3 / 1 \ 2 Example 2:
Input: [3,1,4,null,null,2] 3 / \ 1 4 / 2 Output: [2,1,4,null,null,3] 2 / \ 1 4 / 3 Follow up:
A solution using O(n) space is pretty straight forward.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0100.Same-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0100.Same-Tree/</guid><description>100. Same Tree # 题目 # Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
Example 1:
Input: 1 1 / \ / \ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2:
Input: 1 1 / \ 2 2 [1,2], [1,null,2] Output: false Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0101.Symmetric-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0101.Symmetric-Tree/</guid><description>101. Symmetric Tree # 题目 # Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
1 / \ 2 2 / \ / \ 3 4 4 3 But the following [1,2,2,null,3,null,3] is not:
1 / \ 2 2 \ \ 3 3 Note:
Bonus points if you could solve it both recursively and iteratively.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0102.Binary-Tree-Level-Order-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0102.Binary-Tree-Level-Order-Traversal/</guid><description>102. Binary Tree Level Order Traversal # 题目 # Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its level order traversal as:
[ [3], [9,20], [15,7] ] 题目大意 # 按层序从上到下遍历一颗树。
解题思路 # 用一个队列即可实现。
代码 # package leetcode import ( &amp;#34;github.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0103.Binary-Tree-Zigzag-Level-Order-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0103.Binary-Tree-Zigzag-Level-Order-Traversal/</guid><description>103. Binary Tree Zigzag Level Order Traversal # 题目 # Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).
For Example: Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its zigzag level order traversal as:
[ [3], [20,9], [15,7] ] 题目大意 # 按照 Z 字型层序遍历一棵树。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0104.Maximum-Depth-of-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0104.Maximum-Depth-of-Binary-Tree/</guid><description>104. Maximum Depth of Binary Tree # 题目 # Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its depth = 3.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0105.Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/</guid><description>105. Construct Binary Tree from Preorder and Inorder Traversal # 题目 # Given preorder and inorder traversal of a tree, construct the binary tree.
Note:You may assume that duplicates do not exist in the tree.
For example, given
preorder = [3,9,20,15,7] inorder = [9,3,15,20,7] Return the following binary tree:
3 / \ 9 20 / \ 15 7 题目大意 # 根据一棵树的前序遍历与中序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。
解题思路 # 给出 2 个数组，根据 preorder 和 inorder 数组构造一颗树。 利用递归思想，从 preorder 可以得到根节点，从 inorder 中得到左子树和右子树。只剩一个节点的时候即为根节点。不断的递归直到所有的树都生成完成。 代码 # package leetcode import ( &amp;#34;github.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0106.Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0106.Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal/</guid><description>106. Construct Binary Tree from Inorder and Postorder Traversal # 题目 # Given inorder and postorder traversal of a tree, construct the binary tree.
Note: You may assume that duplicates do not exist in the tree.
For example, given
inorder = [9,3,15,20,7] postorder = [9,15,7,20,3] Return the following binary tree:
3 / \ 9 20 / \ 15 7 题目大意 # 根据一棵树的中序遍历与后序遍历构造二叉树。
注意: 你可以假设树中没有重复的元素。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0107.Binary-Tree-Level-Order-Traversal-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0107.Binary-Tree-Level-Order-Traversal-II/</guid><description>107. Binary Tree Level Order Traversal II # 题目 # Given a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level from leaf to root).
For Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its bottom-up level order traversal as:
[ [15,7], [9,20], [3] ] 题目大意 # 按层序从下到上遍历一颗树。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0108.Convert-Sorted-Array-to-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0108.Convert-Sorted-Array-to-Binary-Search-Tree/</guid><description>108. Convert Sorted Array to Binary Search Tree # 题目 # Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted array: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 题目大意 # 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0109.Convert-Sorted-List-to-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0109.Convert-Sorted-List-to-Binary-Search-Tree/</guid><description>109. Convert Sorted List to Binary Search Tree # 题目 # Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example:
Given the sorted linked list: [-10,-3,0,5,9], One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST: 0 / \ -3 9 / / -10 5 题目大意 # 将链表转化为高度平衡的二叉搜索树。高度平衡的定义：每个结点的 2 个子结点的深度不能相差超过 1 。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0110.Balanced-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0110.Balanced-Binary-Tree/</guid><description>110. Balanced Binary Tree # 题目 # Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
Example 1:
Given the following tree [3,9,20,null,null,15,7]:
3 / \ 9 20 / \ 15 7 Return true.
Example 2:
Given the following tree [1,2,2,3,3,null,null,4,4]:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0111.Minimum-Depth-of-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0111.Minimum-Depth-of-Binary-Tree/</guid><description>111. Minimum Depth of Binary Tree # 题目 # Given a binary tree, find its minimum depth.
The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.
Note: A leaf is a node with no children.
Example:
Given binary tree [3,9,20,null,null,15,7],
3 / \ 9 20 / \ 15 7 return its minimum depth = 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0112.Path-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0112.Path-Sum/</guid><description>112. Path Sum # 题目 # Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
Note: A leaf is a node with no children.
Example:
Given the below binary tree and sum = 22,
5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1 return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0113.Path-Sum-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0113.Path-Sum-II/</guid><description>113. Path Sum II # 题目 # Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum.
Note: A leaf is a node with no children.
Example:
Given the below binary tree and sum = 22,
5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1 Return:
[ [5,4,11,2], [5,8,4,5] ] 题目大意 # 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0114.Flatten-Binary-Tree-to-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0114.Flatten-Binary-Tree-to-Linked-List/</guid><description>114. Flatten Binary Tree to Linked List # 题目 # Given a binary tree, flatten it to a linked list in-place.
For example, given the following tree:
1 / \ 2 5 / \ \ 3 4 6 The flattened tree should look like:
1 \ 2 \ 3 \ 4 \ 5 \ 6 题目大意 # 给定一个二叉树，原地将它展开为链表。
解题思路 # 要求把二叉树“打平”，按照先根遍历的顺序，把树的结点都放在右结点中。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0115.Distinct-Subsequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0115.Distinct-Subsequences/</guid><description>115. Distinct Subsequences # 题目 # Given two strings s and t, return the number of distinct subsequences of s which equals t.
A string&amp;rsquo;s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters&amp;rsquo; relative positions. (i.e., &amp;quot;ACE&amp;quot; is a subsequence of &amp;quot;ABCDE&amp;quot; while &amp;quot;AEC&amp;quot; is not).
It is guaranteed the answer fits on a 32-bit signed integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0116.Populating-Next-Right-Pointers-in-Each-Node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0116.Populating-Next-Right-Pointers-in-Each-Node/</guid><description>116. Populating Next Right Pointers in Each Node # 题目 # You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:
struct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0118.Pascals-Triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0118.Pascals-Triangle/</guid><description>118. Pascal&amp;rsquo;s Triangle # 题目 # Given a non-negative integer numRows, generate the first numRows of Pascal&amp;rsquo;s triangle.
Note: In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Example:
Input: 5 Output: [ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1] ] 题目大意 # 给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。在杨辉三角中，每个数是它左上方和右上方的数的和。
解题思路 # 给定一个 n，要求打印杨辉三角的前 n 行。 简单题。按照杨辉三角的生成规则循环打印即可。 代码 # package leetcode func generate(numRows int) [][]int { result := [][]int{} for i := 0; i &amp;lt; numRows; i++ { row := []int{} for j := 0; j &amp;lt; i+1; j++ { if j == 0 || j == i { row = append(row, 1) } else if i &amp;gt; 1 { row = append(row, result[i-1][j-1]+result[i-1][j]) } } result = append(result, row) } return result } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0119.Pascals-Triangle-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0119.Pascals-Triangle-II/</guid><description>119. Pascal&amp;rsquo;s Triangle II # 题目 # Given an integer rowIndex, return the rowIndexth row of the Pascal&amp;rsquo;s triangle.
Notice that the row index starts from 0.
In Pascal&amp;rsquo;s triangle, each number is the sum of the two numbers directly above it.
Follow up:
Could you optimize your algorithm to use only O(k) extra space?
Example 1:
Input: rowIndex = 3 Output: [1,3,3,1] Example 2:
Input: rowIndex = 0 Output: [1] Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0120.Triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0120.Triangle/</guid><description>120. Triangle # 题目 # Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
For example, given the following triangle
[ [2], [3,4], [6,5,7], [4,1,8,3] ] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).
Note:
Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0121.Best-Time-to-Buy-and-Sell-Stock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0121.Best-Time-to-Buy-and-Sell-Stock/</guid><description>121. Best Time to Buy and Sell Stock # 题目 # Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0122.Best-Time-to-Buy-and-Sell-Stock-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0122.Best-Time-to-Buy-and-Sell-Stock-II/</guid><description>122. Best Time to Buy and Sell Stock II # 题目 # Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
Note: You may not engage in multiple transactions at the same time (i.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0124.Binary-Tree-Maximum-Path-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0124.Binary-Tree-Maximum-Path-Sum/</guid><description>124. Binary Tree Maximum Path Sum # 题目 # Given a non-empty binary tree, find the maximum path sum.
For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.
Example 1:
Input: [1,2,3] 1 / \ 2 3 Output: 6 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0125.Valid-Palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0125.Valid-Palindrome/</guid><description>125. Valid Palindrome # 题目 # Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
For example,
&amp;quot;A man, a plan, a canal: Panama&amp;quot; is a palindrome. &amp;quot;race a car&amp;quot; is not a palindrome. Note:
Have you consider that the string might be empty? This is a good question to ask during an interview.
For the purpose of this problem, we define empty string as valid palindrome.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0126.Word-Ladder-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0126.Word-Ladder-II/</guid><description>126. Word Ladder II # 题目 # Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:
Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note:
Return an empty list if there is no such transformation sequence.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0127.Word-Ladder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0127.Word-Ladder/</guid><description>127. Word Ladder # 题目 # Given two words (beginWord and endWord), and a dictionary&amp;rsquo;s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
Only one letter can be changed at a time. Each transformed word must exist in the word list. Note that beginWord is not a transformed word. Note:
Return 0 if there is no such transformation sequence.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0128.Longest-Consecutive-Sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0128.Longest-Consecutive-Sequence/</guid><description>128. Longest Consecutive Sequence # 题目 # Given an unsorted array of integers, find the length of the longest consecutive elements sequence.
Your algorithm should run in O(n) complexity.
Example:
Input: [100, 4, 200, 1, 3, 2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 题目大意 # 给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。
解题思路 # 给出一个数组，要求找出最长连续序列，输出这个最长的长度。要求时间复杂度为 O(n)。 这一题可以先用暴力解决解决，代码见解法三。思路是把每个数都存在 map 中，先删去 map 中没有前一个数 nums[i]-1 也没有后一个数 nums[i]+1 的数 nums[i]，这种数前后都不连续。然后在 map 中找到前一个数 nums[i]-1 不存在，但是后一个数 nums[i]+1 存在的数，这种数是连续序列的起点，那么不断的往后搜，直到序列“断”了。最后输出最长序列的长度。 这一题最优的解法是解法一，针对每一个 map 中不存在的数 n，插入进去都做 2 件事情。第一件事，先查看 n - 1 和 n + 1 是否都存在于 map 中，如果都存在，代表存在连续的序列，那么就更新 left，right 边界。那么 n 对应的这个小的子连续序列长度为 sum = left + right + 1。第二件事就是更新 left 和 right 左右边界对应的 length = sum。 这一题还可以用并查集解决，见解法二。利用每个数在 nums 中的下标，把下标和下标进行 union()，具体做法是看前一个数 nums[i]-1 和后一个数 nums[i]+1 在 map 中是否存在，如果存在就 union()，最终输出整个并查集中包含最多元素的那个集合的元素总数。 代码 # package leetcode import ( &amp;#34;github.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0129.Sum-Root-to-Leaf-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0129.Sum-Root-to-Leaf-Numbers/</guid><description>129. Sum Root to Leaf Numbers # 题目 # Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.
An example is the root-to-leaf path 1-&amp;gt;2-&amp;gt;3 which represents the number 123.
Find the total sum of all root-to-leaf numbers.
Note: A leaf is a node with no children.
Example:
Input: [1,2,3] 1 / \ 2 3 Output: 25 Explanation: The root-to-leaf path 1-&amp;gt;2 represents the number 12.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0130.Surrounded-Regions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0130.Surrounded-Regions/</guid><description>130. Surrounded Regions # 题目 # Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.
A region is captured by flipping all 'O's into 'X's in that surrounded region.
Example:
X X X X X O O X X X O X X O X X After running your function, the board should be:
X X X X X X X X X X X X X O X X Explanation:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0131.Palindrome-Partitioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0131.Palindrome-Partitioning/</guid><description>131. Palindrome Partitioning # 题目 # Given a string s, partition s such that every substring of the partition is a palindrome.
Return all possible palindrome partitioning of s.
Example:
Input: &amp;quot;aab&amp;quot; Output: [ [&amp;quot;aa&amp;quot;,&amp;quot;b&amp;quot;], [&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;] ] 题目大意 # 给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。
解题思路 # 要求输出一个字符串可以被拆成回文串的所有解，DFS 递归求解即可。 代码 # package leetcode // 解法一 func partition131(s string) [][]string { if s == &amp;#34;&amp;#34; { return [][]string{} } res, pal := [][]string{}, []string{} findPalindrome(s, 0, &amp;#34;&amp;#34;, true, pal, &amp;amp;res) return res } func findPalindrome(str string, index int, s string, isPal bool, pal []string, res *[][]string) { if index == len(str) { if isPal { tmp := make([]string, len(pal)) copy(tmp, pal) *res = append(*res, tmp) } return } if index == 0 { s = string(str[index]) pal = append(pal, s) findPalindrome(str, index+1, s, isPal &amp;amp;&amp;amp; isPalindrome131(s), pal, res) } else { temp := pal[len(pal)-1] s = pal[len(pal)-1] + string(str[index]) pal[len(pal)-1] = s findPalindrome(str, index+1, s, isPalindrome131(s), pal, res) pal[len(pal)-1] = temp if isPalindrome131(temp) { pal = append(pal, string(str[index])) findPalindrome(str, index+1, temp, isPal &amp;amp;&amp;amp; isPalindrome131(temp), pal, res) pal = pal[:len(pal)-1] } } return } func isPalindrome131(s string) bool { slen := len(s) for i, j := 0, slen-1; i &amp;lt; j; i, j = i+1, j-1 { if s[i] !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0135.Candy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0135.Candy/</guid><description>135. Candy # 题目 # There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.
You are giving candies to these children subjected to the following requirements:
Each child must have at least one candy. Children with a higher rating get more candies than their neighbors. Return the minimum number of candies you need to have to distribute the candies to the children.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0136.Single-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0136.Single-Number/</guid><description>136. Single Number # 题目 # Given a non-empty array of integers, every element appears twice except for one. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,1] Output: 1 Example 2:
Input: [4,1,2,1,2] Output: 4 题目大意 # 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。
解题思路 # 题目要求不能使用辅助空间，并且时间复杂度只能是线性的。 题目为什么要强调有一个数字出现一次，其他的出现两次？我们想到了异或运算的性质：任何一个数字异或它自己都等于0。也就是说，如果我们从头到尾依次异或数组中的每一个数字，那么最终的结果刚好是那个只出现一次的数字，因为那些出现两次的数字全部在异或中抵消掉了。于是最终做法是从头到尾依次异或数组中的每一个数字，那么最终得到的结果就是两个只出现一次的数字的异或结果。因为其他数字都出现了两次，在异或中全部抵消掉了。利用的性质是 x^x = 0。 代码 # package leetcode func singleNumber(nums []int) int { result := 0 for i := 0; i &amp;lt; len(nums); i++ { result ^= nums[i] } return result } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0137.Single-Number-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0137.Single-Number-II/</guid><description>137. Single Number II # 题目 # Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.
Note:
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?
Example 1:
Input: [2,2,3,2] Output: 3 Example 2:
Input: [0,1,0,1,0,1,99] Output: 99 题目大意 # 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。要求算法时间复杂度是线性的，并且不使用额外的辅助空间。
解题思路 # 这一题是第 136 题的加强版。这类题也可以扩展，在数组中每个元素都出现 5 次，找出只出现 1 次的数。 本题中要求找出只出现 1 次的数，出现 3 次的数都要被消除。第 136 题是消除出现 2 次的数。这一题也会相当相同的解法，出现 3 次的数也要被消除。定义状态，00、10、01，这 3 个状态。当一个数出现 3 次，那么它每个位置上的 1 出现的次数肯定是 3 的倍数，所以当 1 出现 3 次以后，就归零清除。如何能做到这点呢？仿造三进制(00，01，10) 就可以做到。 变量 ones 中记录遍历中每个位上出现 1 的个数。将它与 A[i] 进行异或，目的是： 每位上两者都是 1 的，表示历史统计结果 ones 出现1次、A[i]中又出现 1 次，则是出现 2 次，需要进位到 twos 变量中。 每位上两者分别为 0、1 的，加入到 ones 统计结果中。 最后还要 &amp;amp; ^twos ，是为了能做到三进制，出现 3 次就清零。例如 ones = x，那么 twos = 0，当 twos = x，那么 ones = 0； 变量 twos 中记录遍历中每个位上出现 1 ，2次 的个数。与 A[i] 进行异或的目的和上述描述相同，不再赘述。 在 golang 中，&amp;amp;^ 表示 AND NOT 的意思。这里的 ^ 作为一元操作符，表示按位取反 (^0001 0100 = 1110 1011)，X &amp;amp;^ Y 的意思是将 X 中与 Y 相异的位保留，相同的位清零。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0138.Copy-List-With-Random-Pointer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0138.Copy-List-With-Random-Pointer/</guid><description>138. Copy List with Random Pointer # 题目 # A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a  deep copy of the list.
The Linked List is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:
val: an integer representing Node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0141.Linked-List-Cycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0141.Linked-List-Cycle/</guid><description>141. Linked List Cycle # 题目 # Given a linked list, determine if it has a cycle in it.
Follow up:
Can you solve it without using extra space?
题目大意 # 判断链表是否有环，不能使用额外的空间。
解题思路 # 给 2 个指针，一个指针是另外一个指针的下一个指针。快指针一次走 2 格，慢指针一次走 1 格。如果存在环，那么前一个指针一定会经过若干圈之后追上慢的指针。
代码 # package leetcode import ( &amp;#34;github.com/halfrost/leetcode-go/structures&amp;#34; ) // ListNode define type ListNode = structures.ListNode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func hasCycle(head *ListNode) bool { fast := head slow := head for fast !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0142.Linked-List-Cycle-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0142.Linked-List-Cycle-II/</guid><description>142. Linked List Cycle II # 题目 # Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Note: Do not modify the linked list.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0143.Reorder-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0143.Reorder-List/</guid><description>143. Reorder List # 题目 # Given a singly linked list L: L0→L1→…→Ln-1→Ln, reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…
You may not modify the values in the list&amp;rsquo;s nodes, only nodes itself may be changed.
Example 1:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4, reorder it to 1-&amp;gt;4-&amp;gt;2-&amp;gt;3. Example 2:
Given 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5, reorder it to 1-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;3. 题目大意 # 按照指定规则重新排序链表：第一个元素和最后一个元素排列在一起，接着第二个元素和倒数第二个元素排在一起，接着第三个元素和倒数第三个元素排在一起。
解题思路 # 最近简单的方法是先把链表存储到数组里，然后找到链表中间的结点，按照规则拼接即可。这样时间复杂度是 O(n)，空间复杂度是 O(n)。
更好的做法是结合之前几道题的操作：链表逆序，找中间结点。
先找到链表的中间结点，然后利用逆序区间的操作，如 第 92 题 里的 reverseBetween() 操作，只不过这里的反转区间是从中点一直到末尾。最后利用 2 个指针，一个指向头结点，一个指向中间结点，开始拼接最终的结果。这种做法的时间复杂度是 O(n)，空间复杂度是 O(1)。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0144.Binary-Tree-Preorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0144.Binary-Tree-Preorder-Traversal/</guid><description>144. Binary Tree Preorder Traversal # 题目 # Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [1,2,3] Follow up: Recursive solution is trivial, could you do it iteratively?
题目大意 # 先根遍历一颗树。
解题思路 # 两种递归的实现方法，见代码。
代码 # package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ // 解法一 递归 func preorderTraversal(root *TreeNode) []int { res := []int{} if root !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0145.Binary-Tree-Postorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0145.Binary-Tree-Postorder-Traversal/</guid><description>145. Binary Tree Postorder Traversal # 题目 # Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
Example:
Input: [1,null,2,3] 1 \ 2 / 3 Output: [3,2,1] Follow up: Recursive solution is trivial, could you do it iteratively?
题目大意 # 后根遍历一颗树。
解题思路 # 递归的实现方法，见代码。
代码 # package leetcode /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func postorderTraversal(root *TreeNode) []int { var result []int postorder(root, &amp;amp;result) return result } func postorder(root *TreeNode, output *[]int) { if root !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0146.LRU-Cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0146.LRU-Cache/</guid><description>146. LRU Cache # 题目 # Design a data structure that follows the constraints of a  Least Recently Used (LRU) cache.
Implement the LRUCache class:
LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return 1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0147.Insertion-Sort-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0147.Insertion-Sort-List/</guid><description>147. Insertion Sort List # 题目 # Sort a linked list using insertion sort.
A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list. With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list
Algorithm of Insertion Sort:
Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0148.Sort-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0148.Sort-List/</guid><description>148. Sort List # 题目 # Sort a linked list in O(n log n) time using constant space complexity.
Example 1:
Input: 4-&amp;gt;2-&amp;gt;1-&amp;gt;3 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4 Example 2:
Input: -1-&amp;gt;5-&amp;gt;3-&amp;gt;4-&amp;gt;0 Output: -1-&amp;gt;0-&amp;gt;3-&amp;gt;4-&amp;gt;5 题目大意 # 链表的排序，要求时间复杂度必须是 O(n log n)，空间复杂度是 O(1)
解题思路 # 这道题只能用归并排序才能符合要求。归并排序需要的 2 个操作在其他题目已经出现过了，取中间点是第 876 题，合并 2 个有序链表是第 21 题。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func sortList(head *ListNode) *ListNode { length := 0 cur := head for cur !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0150.Evaluate-Reverse-Polish-Notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0150.Evaluate-Reverse-Polish-Notation/</guid><description>150. Evaluate Reverse Polish Notation # 题目 # Evaluate the value of an arithmetic expression in Reverse Polish Notation.
Valid operators are +, -, *, /. Each operand may be an integer or another expression.
Note:
Division between two integers should truncate toward zero. The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&amp;rsquo;t be any divide by zero operation.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0151.Reverse-Words-in-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0151.Reverse-Words-in-a-String/</guid><description>151. Reverse Words in a String # 题目 # Given an input string, reverse the string word by word.
Example 1:
Input: &amp;quot;the sky is blue&amp;quot; Output: &amp;quot;blue is sky the&amp;quot; Example 2:
Input: &amp;quot; hello world! &amp;quot; Output: &amp;quot;world! hello&amp;quot; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3:
Input: &amp;quot;a good example&amp;quot; Output: &amp;quot;example good a&amp;quot; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0152.Maximum-Product-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0152.Maximum-Product-Subarray/</guid><description>152. Maximum Product Subarray # 题目 # Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.
Example 1:
Input: [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2:
Input: [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. 题目大意 # 给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0153.Find-Minimum-in-Rotated-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0153.Find-Minimum-in-Rotated-Sorted-Array/</guid><description>153. Find Minimum in Rotated Sorted Array # 题目 # Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
You may assume no duplicate exists in the array.
Example 1:
Input: [3,4,5,1,2] Output: 1 Example 2:
Input: [4,5,6,7,0,1,2] Output: 0 题目大意 # 假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。请找出其中最小的元素。
你可以假设数组中不存在重复元素。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0154.Find-Minimum-in-Rotated-Sorted-Array-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0154.Find-Minimum-in-Rotated-Sorted-Array-II/</guid><description>154. Find Minimum in Rotated Sorted Array II # 题目 # Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
Find the minimum element.
The array may contain duplicates.
Example 1:
Input: [1,3,5] Output: 1 Example 2:
Input: [2,2,2,0,1] Output: 0 Note:
This is a follow up problem to Find Minimum in Rotated Sorted Array.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0155.Min-Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0155.Min-Stack/</guid><description>155. Min Stack # 题目 # Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
push(x) &amp;ndash; Push element x onto stack. pop() &amp;ndash; Removes the element on top of the stack. top() &amp;ndash; Get the top element. getMin() &amp;ndash; Retrieve the minimum element in the stack.
Example:
MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; Returns -3. minStack.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0160.Intersection-of-Two-Linked-Lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0160.Intersection-of-Two-Linked-Lists/</guid><description>160. Intersection of Two Linked Lists # 题目 # Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
begin to intersect at node c1.
Example 1:
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 Output: Reference of the node with value = 8 Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0162.Find-Peak-Element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0162.Find-Peak-Element/</guid><description>162. Find Peak Element # 题目 # A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -∞.
Example 1:
Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0164.Maximum-Gap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0164.Maximum-Gap/</guid><description>164. Maximum Gap # 题目 # Given an unsorted array, find the maximum difference between the successive elements in its sorted form.
Return 0 if the array contains less than 2 elements.
Example 1:
Input: [3,6,9,1] Output: 3 Explanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3. Example 2:
Input: [10] Output: 0 Explanation: The array contains less than 2 elements, therefore return 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0167.Two-Sum-II-Input-array-is-sorted/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0167.Two-Sum-II-Input-array-is-sorted/</guid><description>167. Two Sum II - Input array is sorted # 题目 # Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
Note:
Your returned answers (both index1 and index2) are not zero-based.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0168.Excel-Sheet-Column-Title/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0168.Excel-Sheet-Column-Title/</guid><description>168. Excel Sheet Column Title # 题目 # Given a positive integer, return its corresponding column title as appear in an Excel sheet.
For example:
1 -&amp;gt; A 2 -&amp;gt; B 3 -&amp;gt; C ... 26 -&amp;gt; Z 27 -&amp;gt; AA 28 -&amp;gt; AB ... Example 1:
Input: 1 Output: &amp;quot;A&amp;quot; Example 2:
Input: 28 Output: &amp;quot;AB&amp;quot; Example 3:
Input: 701 Output: &amp;quot;ZY&amp;quot; 题目大意 # 给定一个正整数，返回它在 Excel 表中相对应的列名称。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0169.Majority-Element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0169.Majority-Element/</guid><description>169. Majority Element # 题目 # Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.
You may assume that the array is non-empty and the majority element always exist in the array.
Example 1:
Input: [3,2,3] Output: 3 Example 2:
Input: [2,2,1,1,1,2,2] Output: 2 题目大意 # 给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0171.Excel-Sheet-Column-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0171.Excel-Sheet-Column-Number/</guid><description>171. Excel Sheet Column Number # 题目 # Given a column title as appear in an Excel sheet, return its corresponding column number.
For example:
A -&amp;gt; 1 B -&amp;gt; 2 C -&amp;gt; 3 ... Z -&amp;gt; 26 AA -&amp;gt; 27 AB -&amp;gt; 28 ... Example 1:
Input: &amp;quot;A&amp;quot; Output: 1 Example 2:
Input: &amp;quot;AB&amp;quot; Output: 28 Example 3:
Input: &amp;quot;ZY&amp;quot; Output: 701 题目大意 # 给定一个 Excel 表格中的列名称，返回其相应的列序号。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0172.Factorial-Trailing-Zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0172.Factorial-Trailing-Zeroes/</guid><description>172. Factorial Trailing Zeroes # 题目 # Given an integer n, return the number of trailing zeroes in n!.
Example 1:
Input: 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2:
Input: 5 Output: 1 Explanation: 5! = 120, one trailing zero. Note: Your solution should be in logarithmic time complexity.
题目大意 # 给定一个整数 n，返回 n! 结果尾数中零的数量。说明: 你算法的时间复杂度应为 O(log n) 。
解题思路 # 给出一个数 n，要求 n！末尾 0 的个数。 这是一道数学题。计算 N 的阶乘有多少个后缀 0，即计算 N!</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0173.Binary-Search-Tree-Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0173.Binary-Search-Tree-Iterator/</guid><description>173. Binary Search Tree Iterator # 题目 # Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
Calling next() will return the next smallest number in the BST.
Example:
BSTIterator iterator = new BSTIterator(root); iterator.next(); // return 3 iterator.next(); // return 7 iterator.hasNext(); // return true iterator.next(); // return 9 iterator.hasNext(); // return true iterator.next(); // return 15 iterator.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0174.Dungeon-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0174.Dungeon-Game/</guid><description>174. Dungeon Game # 题目 # The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.
The knight has an initial health point represented by a positive integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0179.Largest-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0179.Largest-Number/</guid><description>179. Largest Number # 题目 # Given a list of non negative integers, arrange them such that they form the largest number.
Example 1:
Input: [10,2] Output: &amp;quot;210&amp;quot; Example 2:
Input: [3,30,34,5,9] Output: &amp;quot;9534330&amp;quot; Note:
The result may be very large, so you need to return a string instead of an integer.
题目大意 # 给出一个数组，要求排列这些数组里的元素，使得最终排列出来的数字是最大的。
解题思路 # 这一题很容易想到把数字都转化为字符串，利用字符串比较，来排序，这样 9 开头的一定排在最前面。不过这样做有一个地方是错误的，比如：&amp;ldquo;3&amp;rdquo; 和 &amp;ldquo;30&amp;rdquo; 比较，&amp;ldquo;30&amp;rdquo; 比 &amp;ldquo;3&amp;rdquo; 的字符序要大，这样排序以后就出错了。实际上就这道题而言， &amp;ldquo;3&amp;rdquo; 应该排在 &amp;ldquo;30&amp;rdquo; 前面。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0187.Repeated-DNA-Sequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0187.Repeated-DNA-Sequences/</guid><description>187. Repeated DNA Sequences # 题目 # All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for Example: &amp;ldquo;ACGAATTCCG&amp;rdquo;. When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.
Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.
Example:
Input: s = &amp;quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&amp;quot; Output: [&amp;quot;AAAAACCCCC&amp;quot;, &amp;quot;CCCCCAAAAA&amp;quot;] 题目大意 # 所有 DNA 由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。编写一个函数来查找 DNA 分子中所有出现超多一次的10个字母长的序列（子串）。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0189.Rotate-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0189.Rotate-Array/</guid><description>189. Rotate Array # 题目 # Given an array, rotate the array to the right by k steps, where k is non-negative.
Follow up:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem. Could you do it in-place with O(1) extra space? Example 1:
Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0190.Reverse-Bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0190.Reverse-Bits/</guid><description>190. Reverse Bits # 题目 # Reverse bits of a given 32 bits unsigned integer.
Example 1:
Input: 00000010100101000001111010011100 Output: 00111001011110000010100101000000 Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2:
Input: 11111111111111111111111111111101 Output: 10111111111111111111111111111111 Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10101111110010110010011101101001. Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0191.Number-of-1-Bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0191.Number-of-1-Bits/</guid><description>191. Number of 1 Bits # 题目 # Write a function that takes an unsigned integer and return the number of &amp;lsquo;1&amp;rsquo; bits it has (also known as the Hamming weight).
Example 1:
Input: 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2:
Input: 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0198.House-Robber/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0198.House-Robber/</guid><description>198. House Robber # 题目 # You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0199.Binary-Tree-Right-Side-View/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0100~0199/0199.Binary-Tree-Right-Side-View/</guid><description>199. Binary Tree Right Side View # 题目 # Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.
Example:
Input: [1,2,3,null,5,null,4] Output: [1, 3, 4] Explanation: 1 &amp;lt;--- / \ 2 3 &amp;lt;--- \ \ 5 4 &amp;lt;--- 题目大意 # 从右边看一个树，输出看到的数字。注意有遮挡。
解题思路 # 这一题是按层序遍历的变种题。按照层序把每层的元素都遍历出来，然后依次取每一层的最右边的元素即可。用一个队列即可实现。 第 102 题和第 107 题都是按层序遍历的。 代码 # package leetcode /** * Definition for a binary tree node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0200.Number-of-Islands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0200.Number-of-Islands/</guid><description>200. Number of Islands # 题目 # Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.
Example 1:
Input: 11110 11010 11000 00000 Output: 1 Example 2:
Input: 11000 11000 00100 00011 Output: 3 题目大意 # 给定一个由 &amp;lsquo;1&amp;rsquo;（陆地）和 &amp;lsquo;0&amp;rsquo;（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0201.Bitwise-AND-of-Numbers-Range/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0201.Bitwise-AND-of-Numbers-Range/</guid><description>201. Bitwise AND of Numbers Range # 题目 # Given a range [m, n] where 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive.
Example 1:
Input: [5,7] Output: 4 Example 2:
Input: [0,1] Output: 0 题目大意 # 给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。
解题思路 # 这一题要求输出 [m,n] 区间内所有数的 AND 与操作之后的结果。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0202.Happy-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0202.Happy-Number/</guid><description>202. Happy Number # 题目 # Write an algorithm to determine if a number is &amp;ldquo;happy&amp;rdquo;.
A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0203.Remove-Linked-List-Elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0203.Remove-Linked-List-Elements/</guid><description>203. Remove Linked List Elements # 题目 # Remove all elements from a linked list of integers that have value val.
Example:
Input: 1-&amp;gt;2-&amp;gt;6-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6, val = 6 Output: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5 题目大意 # 删除链表中所有指定值的结点。
解题思路 # 按照题意做即可。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeElements(head *ListNode, val int) *ListNode { if head == nil { return head } newHead := &amp;amp;ListNode{Val: 0, Next: head} pre := newHead cur := head for cur !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0204.Count-Primes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0204.Count-Primes/</guid><description>204. Count Primes # 题目 # Count the number of prime numbers less than a non-negative number, n.
Example:
Input: 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. 题目大意 # 统计所有小于非负整数 n 的质数的数量。
解题思路 # 给出一个数字 n，要求输出小于 n 的所有素数的个数总和。简单题。 代码 # package leetcode func countPrimes(n int) int { isNotPrime := make([]bool, n) for i := 2; i*i &amp;lt; n; i++ { if isNotPrime[i] { continue } for j := i * i; j &amp;lt; n; j = j + i { isNotPrime[j] = true } } count := 0 for i := 2; i &amp;lt; n; i++ { if !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0205.Isomorphic-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0205.Isomorphic-Strings/</guid><description>205. Isomorphic Strings # 题目 # Given two strings s and t, determine if they are isomorphic.
Two strings are isomorphic if the characters in s can be replaced to get t.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.
Example 1:
Input: s = &amp;quot;egg&amp;quot;, t = &amp;quot;add&amp;quot; Output: true Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0206.Reverse-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0206.Reverse-Linked-List/</guid><description>206. Reverse Linked List # 题目 # Reverse a singly linked list.
题目大意 # 翻转单链表
解题思路 # 按照题意做即可。
代码 # package leetcode /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ // ListNode define type ListNode struct { Val int Next *ListNode } func reverseList(head *ListNode) *ListNode { var behind *ListNode for head != nil { next := head.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0207.Course-Schedule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0207.Course-Schedule/</guid><description>207. Course Schedule # 题目 # There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0208.Implement-Trie-Prefix-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0208.Implement-Trie-Prefix-Tree/</guid><description>208. Implement Trie (Prefix Tree) # 题目 # Implement a trie with insert, search, and startsWith methods.
Example:
Trie trie = new Trie(); trie.insert(&amp;quot;apple&amp;quot;); trie.search(&amp;quot;apple&amp;quot;); // returns true trie.search(&amp;quot;app&amp;quot;); // returns false trie.startsWith(&amp;quot;app&amp;quot;); // returns true trie.insert(&amp;quot;app&amp;quot;); trie.search(&amp;quot;app&amp;quot;); // returns true Note:
You may assume that all inputs are consist of lowercase letters a-z. All inputs are guaranteed to be non-empty strings. 题目大意 # 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0209.Minimum-Size-Subarray-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0209.Minimum-Size-Subarray-Sum/</guid><description>209. Minimum Size Subarray Sum # 题目 # Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn&amp;rsquo;t one, return 0 instead.
Example 1:
Input: s = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up:
If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0210.Course-Schedule-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0210.Course-Schedule-II/</guid><description>210. Course Schedule II # 题目 # There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0211.Design-Add-and-Search-Words-Data-Structure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0211.Design-Add-and-Search-Words-Data-Structure/</guid><description>211. Design Add and Search Words Data Structure # 题目 # Design a data structure that supports the following two operations:
void addWord(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.
Example:
addWord(&amp;quot;bad&amp;quot;) addWord(&amp;quot;dad&amp;quot;) addWord(&amp;quot;mad&amp;quot;) search(&amp;quot;pad&amp;quot;) -&amp;gt; false search(&amp;quot;bad&amp;quot;) -&amp;gt; true search(&amp;quot;.ad&amp;quot;) -&amp;gt; true search(&amp;quot;b..&amp;quot;) -&amp;gt; true Note: You may assume that all words are consist of lowercase letters a-z.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0212.Word-Search-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0212.Word-Search-II/</guid><description>212. Word Search II # 题目 # Given a 2D board and a list of words from the dictionary, find all words in the board.
Each word must be constructed from letters of sequentially adjacent cell, where &amp;ldquo;adjacent&amp;rdquo; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.
Example:
Input: board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] words = [&amp;quot;oath&amp;quot;,&amp;quot;pea&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;rain&amp;quot;] Output: [&amp;quot;eat&amp;quot;,&amp;quot;oath&amp;quot;] Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0213.House-Robber-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0213.House-Robber-II/</guid><description>213. House Robber II # 题目 # You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0215.Kth-Largest-Element-in-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0215.Kth-Largest-Element-in-an-Array/</guid><description>215. Kth Largest Element in an Array # 题目 # Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Example 1:
Input: [3,2,1,5,6,4] and k = 2 Output: 5 Example 2:
Input: [3,2,3,1,2,4,5,5,6] and k = 4 Output: 4 Note:
You may assume k is always valid, 1 ≤ k ≤ array&amp;rsquo;s length.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0216.Combination-Sum-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0216.Combination-Sum-III/</guid><description>216. Combination Sum III # 题目 # Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
Note:
All numbers will be positive integers. The solution set must not contain duplicate combinations. Example 1:
Input: k = 3, n = 7 Output: [[1,2,4]] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0217.Contains-Duplicate/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0217.Contains-Duplicate/</guid><description>217. Contains Duplicate # 题目 # Given an array of integers, find if the array contains any duplicates.
Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
Example 1:
Input: [1,2,3,1] Output: true Example 2:
Input: [1,2,3,4] Output: false Example 3:
Input: [1,1,1,3,3,4,3,2,4,2] Output: true 题目大意 # 这是一道简单题，如果数组里面有重复数字就输出 true，否则输出 flase。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0218.The-Skyline-Problem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0218.The-Skyline-Problem/</guid><description>218. The Skyline Problem # 题目 # A city&amp;rsquo;s skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Now suppose you are given the locations and height of all the buildings as shown on a cityscape photo (Figure A), write a program to output the skyline formed by these buildings collectively (Figure B).
The geometric information of each building is represented by a triplet of integers [Li, Ri, Hi], where Li and Ri are the x coordinates of the left and right edge of the ith building, respectively, and Hi is its height.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0219.Contains-Duplicate-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0219.Contains-Duplicate-II/</guid><description>219. Contains Duplicate II # 题目 # Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.
Example 1:
Input: nums = [1,2,3,1], k = 3 Output: true Example 2:
Input: nums = [1,0,1,1], k = 1 Output: true Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0220.Contains-Duplicate-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0220.Contains-Duplicate-III/</guid><description>220. Contains Duplicate III # 题目 # Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.
Example 1:
Input: nums = [1,2,3,1], k = 3, t = 0 Output: true Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0222.Count-Complete-Tree-Nodes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0222.Count-Complete-Tree-Nodes/</guid><description>222. Count Complete Tree Nodes # 题目 # Given a complete binary tree, count the number of nodes.
Note:
Definition of a complete binary tree from Wikipedia: In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0223.Rectangle-Area/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0223.Rectangle-Area/</guid><description>223. Rectangle Area # 题目 # Find the total area covered by two rectilinear rectangles in a 2D plane.
Each rectangle is defined by its bottom left corner and top right corner as shown in the figure.
Example:
Input: A = -3, B = 0, C = 3, D = 4, E = 0, F = -1, G = 9, H = 2 Output: 45 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0224.Basic-Calculator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0224.Basic-Calculator/</guid><description>224. Basic Calculator # 题目 # Implement a basic calculator to evaluate a simple expression string.
The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .
Example 1:
Input: &amp;quot;1 + 1&amp;quot; Output: 2 Example 2:
Input: &amp;quot; 2-1 + 2 &amp;quot; Output: 3 Example 3:
Input: &amp;quot;(1+(4+5+2)-3)+(6+8)&amp;quot; Output: 23 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0225.Implement-Stack-using-Queues/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0225.Implement-Stack-using-Queues/</guid><description>225. Implement Stack using Queues # 题目 # Implement the following operations of a stack using queues.
push(x) &amp;ndash; Push element x onto stack. pop() &amp;ndash; Removes the element on top of the stack. top() &amp;ndash; Get the top element. empty() &amp;ndash; Return whether the stack is empty. Example:
MyStack stack = new MyStack(); stack.push(1); stack.push(2); stack.top(); // returns 2 stack.pop(); // returns 2 stack.empty(); // returns false Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0226.Invert-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0226.Invert-Binary-Tree/</guid><description>226. Invert Binary Tree # 题目 # Invert a binary tree.
Example:
Input:
4 / \ 2 7 / \ / \ 1 3 6 9 Output:
4 / \ 7 2 / \ / \ 9 6 3 1 Trivia:
This problem was inspired by this original tweet by Max Howell:
Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0227.Basic-Calculator-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0227.Basic-Calculator-II/</guid><description>227. Basic Calculator II # 题目 # Given a string s which represents an expression, evaluate this expression and return its value.
The integer division should truncate toward zero.
Example 1:
Input: s = &amp;quot;3+2*2&amp;quot; Output: 7 Example 2:
Input: s = &amp;quot; 3/2 &amp;quot; Output: 1 Example 3:
Input: s = &amp;quot; 3+5 / 2 &amp;quot; Output: 5 Constraints:
1 &amp;lt;= s.length &amp;lt;= 3 * 10^5 s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0228.Summary-Ranges/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0228.Summary-Ranges/</guid><description>228. Summary Ranges # 题目 # You are given a sorted unique integer array nums.
Return the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.
Each range [a,b] in the list should be output as:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0229.Majority-Element-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0229.Majority-Element-II/</guid><description>229. Majority Element II # 题目 # Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.
Note: The algorithm should run in linear time and in O(1) space.
Example 1:
Input: [3,2,3] Output: [3] Example 2:
Input: [1,1,1,3,3,2,2,2] Output: [1,2] 题目大意 # 给定一个大小为 n 的数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。说明: 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。
解题思路 # 这一题是第 169 题的加强版。Boyer-Moore Majority Vote algorithm 算法的扩展版。 题目要求找出数组中出现次数大于 ⌊ n/3 ⌋ 次的数。要求空间复杂度为 O(1)。简单题。 这篇文章写的不错，可参考： https://gregable.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0230.Kth-Smallest-Element-in-a-BST/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0230.Kth-Smallest-Element-in-a-BST/</guid><description>230. Kth Smallest Element in a BST # 题目 # Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.
Note: You may assume k is always valid, 1 ≤ k ≤ BST&amp;rsquo;s total elements.
Example 1:
Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2 Output: 1 Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1 Output: 3 Follow up:What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0231.Power-of-Two/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0231.Power-of-Two/</guid><description>231. Power of Two # 题目 # Given an integer, write a function to determine if it is a power of two.
Example 1:
Input: 1 Output: true Explanation: 2^0 = 1 Example 2:
Input: 16 Output: true Explanation: 2^4 = 16 Example 3:
Input: 218 Output: false 题目大意 # 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。
解题思路 # 判断一个数是不是 2 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。这一题和第 326 题是一样的思路。 代码 # package leetcode // 解法一 二进制位操作法 func isPowerOfTwo(num int) bool { return (num &amp;gt; 0 &amp;amp;&amp;amp; ((num &amp;amp; (num - 1)) == 0)) } // 解法二 数论 func isPowerOfTwo1(num int) bool { return num &amp;gt; 0 &amp;amp;&amp;amp; (1073741824%num == 0) } // 解法三 打表法 func isPowerOfTwo2(num int) bool { allPowerOfTwoMap := map[int]int{1: 1, 2: 2, 4: 4, 8: 8, 16: 16, 32: 32, 64: 64, 128: 128, 256: 256, 512: 512, 1024: 1024, 2048: 2048, 4096: 4096, 8192: 8192, 16384: 16384, 32768: 32768, 65536: 65536, 131072: 131072, 262144: 262144, 524288: 524288, 1048576: 1048576, 2097152: 2097152, 4194304: 4194304, 8388608: 8388608, 16777216: 16777216, 33554432: 33554432, 67108864: 67108864, 134217728: 134217728, 268435456: 268435456, 536870912: 536870912, 1073741824: 1073741824} _, ok := allPowerOfTwoMap[num] return ok } // 解法四 循环 func isPowerOfTwo3(num int) bool { for num &amp;gt;= 2 { if num%2 == 0 { num = num / 2 } else { return false } } return num == 1 } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0232.Implement-Queue-using-Stacks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0232.Implement-Queue-using-Stacks/</guid><description>232. Implement Queue using Stacks # 题目 # Implement the following operations of a queue using stacks.
push(x) &amp;ndash; Push element x to the back of queue. pop() &amp;ndash; Removes the element from in front of queue. peek() &amp;ndash; Get the front element. empty() &amp;ndash; Return whether the queue is empty. Example:
MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // returns 1 queue.pop(); // returns 1 queue.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0234.Palindrome-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0234.Palindrome-Linked-List/</guid><description>234. Palindrome Linked List # 题目 # Given a singly linked list, determine if it is a palindrome.
Example 1:
Input: 1-&amp;gt;2 Output: false Example 2:
Input: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 Output: true Follow up:
Could you do it in O(n) time and O(1) space?
题目大意 # 判断一个链表是否是回文链表。要求时间复杂度 O(n)，空间复杂度 O(1)。
解题思路 # 这道题只需要在第 143 题上面改改就可以了。思路是完全一致的。先找到中间结点，然后反转中间结点后面到结尾的所有结点。最后一一判断头结点开始的结点和中间结点往后开始的结点是否相等。如果一直相等，就是回文链表，如果有不相等的，直接返回不是回文链表。
代码 # package leetcode import ( &amp;#34;github.com/halfrost/leetcode-go/structures&amp;#34; ) // ListNode define type ListNode = structures.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0235.Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0235.Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</guid><description>235. Lowest Common Ancestor of a Binary Search Tree # 题目 # Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0236.Lowest-Common-Ancestor-of-a-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0236.Lowest-Common-Ancestor-of-a-Binary-Tree/</guid><description>236. Lowest Common Ancestor of a Binary Tree # 题目 # Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0237.Delete-Node-in-a-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0237.Delete-Node-in-a-Linked-List/</guid><description>237. Delete Node in a Linked List # 题目 # Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.
It is guaranteed that the node to be deleted is not a tail node in the list.
Example 1:
Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation:You are given the second node with value 5, the linked list should become 4 -&amp;gt; 1 -&amp;gt; 9 after calling your function.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0239.Sliding-Window-Maximum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0239.Sliding-Window-Maximum/</guid><description>239. Sliding Window Maximum # 题目 # Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.
Example:
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0240.Search-a-2D-Matrix-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0240.Search-a-2D-Matrix-II/</guid><description>240. Search a 2D Matrix II # 题目 # Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example:
Consider the following matrix:
[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] Given target = 5, return true.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0242.Valid-Anagram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0242.Valid-Anagram/</guid><description>242. Valid Anagram # 题目 # Given two strings s and t , write a function to determine if t is an anagram of s.
Example 1:
Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2:
Input: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false Note:
You may assume the string contains only lowercase alphabets.
Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0257.Binary-Tree-Paths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0257.Binary-Tree-Paths/</guid><description>257. Binary Tree Paths # 题目 # Given a binary tree, return all root-to-leaf paths.
Note: A leaf is a node with no children.
Example:
Input: 1 / \ 2 3 \ 5 Output: [&amp;quot;1-&amp;gt;2-&amp;gt;5&amp;quot;, &amp;quot;1-&amp;gt;3&amp;quot;] Explanation: All root-to-leaf paths are: 1-&amp;gt;2-&amp;gt;5, 1-&amp;gt;3 题目大意 # 给定一个二叉树，返回所有从根节点到叶子节点的路径。说明: 叶子节点是指没有子节点的节点。
解题思路 # Google 的面试题，考察递归 代码 # package leetcode import ( &amp;#34;strconv&amp;#34; ) /** * Definition for a binary tree node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0258.Add-Digits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0258.Add-Digits/</guid><description>258. Add Digits # 题目 # Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
Example:
Input: 38 Output: 2 Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it. Follow up: Could you do it without any loop/recursion in O(1) runtime?
题目大意 # 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0260.Single-Number-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0260.Single-Number-III/</guid><description>260. Single Number III # 题目 # Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once.
Example:
Input: [1,2,1,3,2,5] Output: [3,5] Note:
The order of the result is not important. So in the above example, [5, 3] is also correct. Your algorithm should run in linear runtime complexity.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0263.Ugly-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0263.Ugly-Number/</guid><description>263. Ugly Number # 题目 # Write a program to check whether a given number is an ugly number.
Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.
Example 1:
Input: 6 Output: true Explanation: 6 = 2 × 3 Example 2:
Input: 8 Output: true Explanation: 8 = 2 × 2 × 2 Example 3:
Input: 14 Output: false Explanation: 14 is not ugly since it includes another prime factor 7.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0264.Ugly-Number-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0264.Ugly-Number-II/</guid><description>264. Ugly Number II # 题目 # Given an integer n, return the nth ugly number.
Ugly number is a positive number whose prime factors only include 2, 3, and/or 5.
Example 1:
Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. Example 2:
Input: n = 1 Output: 1 Explanation: 1 is typically treated as an ugly number.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0268.Missing-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0268.Missing-Number/</guid><description>268. Missing Number # 题目 # Given an array containing n distinct numbers taken from 0, 1, 2, ..., n, find the one that is missing from the array.
Example 1:
Input: [3,0,1] Output: 2 Example 2:
Input: [9,6,4,2,3,5,7,0,1] Output: 8 Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
题目大意 # 给定一个包含 0, 1, 2, &amp;hellip;, n 中 n 个数的序列，找出 0 .</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0274.H-Index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0274.H-Index/</guid><description>274. H-Index # 题目 # Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.
According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.&amp;rdquo;
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0275.H-Index-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0275.H-Index-II/</guid><description>275. H-Index II # 题目 # Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher&amp;rsquo;s h-index.
According to the definition of h-index on Wikipedia: &amp;ldquo;A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0278.First-Bad-Version/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0278.First-Bad-Version/</guid><description>278. First Bad Version # 题目 # You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.
Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0279.Perfect-Squares/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0279.Perfect-Squares/</guid><description>279. Perfect Squares # 题目 # Given an integer n, return the least number of perfect square numbers that sum to n.
A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.
Example 1:
Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0283.Move-Zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0283.Move-Zeroes/</guid><description>283. Move Zeroes # 题目 # Given an array nums, write a function to move all 0&amp;rsquo;s to the end of it while maintaining the relative order of the non-zero elements.
Example 1:
Input: [0,1,0,3,12] Output: [1,3,12,0,0] Note:
You must do this in-place without making a copy of the array. Minimize the total number of operations. 题目大意 # 题目要求不能采用额外的辅助空间，将数组中 0 元素都移动到数组的末尾，并且维持所有非 0 元素的相对位置。
解题思路 # 这一题可以只扫描数组一遍，不断的用 i，j 标记 0 和非 0 的元素，然后相互交换，最终到达题目的目的。与这一题相近的题目有第 26 题，第 27 题，第 80 题。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0284.Peeking-Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0284.Peeking-Iterator/</guid><description>284. Peeking Iterator # 题目 # Given an Iterator class interface with methods: next() and hasNext(), design and implement a PeekingIterator that support the peek() operation &amp;ndash; it essentially peek() at the element that will be returned by the next call to next().
Example:
Assume that the iterator is initialized to the beginning of the list: [1,2,3]. Call next() gets you 1, the first element in the list. Now you call peek() and it returns 2, the next element.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0287.Find-the-Duplicate-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0287.Find-the-Duplicate-Number/</guid><description>287. Find the Duplicate Number # 题目 # Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.
Example 1:
Input: [1,3,4,2,2] Output: 2 Example 2:
Input: [3,1,3,4,2] Output: 3 Note:
You must not modify the array (assume the array is read only).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0290.Word-Pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0290.Word-Pattern/</guid><description>290. Word Pattern # 题目 # Given a pattern and a string str, find if str follows the same pattern.
Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.
Example 1:
Input: pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat dog&amp;quot; Output: true Example 2:
Input:pattern = &amp;quot;abba&amp;quot;, str = &amp;quot;dog cat cat fish&amp;quot; Output: false Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0297.Serialize-and-Deserialize-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0297.Serialize-and-Deserialize-Binary-Tree/</guid><description>297. Serialize and Deserialize Binary Tree # 题目 # Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.
Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0299.Bulls-and-Cows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0200~0299/0299.Bulls-and-Cows/</guid><description>299. Bulls and Cows # 题目 # You are playing the Bulls and Cows game with your friend.
You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:
The number of &amp;ldquo;bulls&amp;rdquo;, which are digits in the guess that are in the correct position. The number of &amp;ldquo;cows&amp;rdquo;, which are digits in the guess that are in your secret number but are located in the wrong position.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0300.Longest-Increasing-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0300.Longest-Increasing-Subsequence/</guid><description>300. Longest Increasing Subsequence # 题目 # Given an unsorted array of integers, find the length of longest increasing subsequence.
Example:
Input: [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Note:
There may be more than one LIS combination, it is only necessary for you to return the length. Your algorithm should run in O(n^2) complexity. Follow up: Could you improve it to O(n log n) time complexity?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0301.Remove-Invalid-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0301.Remove-Invalid-Parentheses/</guid><description>301. Remove Invalid Parentheses # 题目 # Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.
Return all the possible results. You may return the answer in any order.
Example 1:
Input: s = &amp;quot;()())()&amp;quot; Output: [&amp;quot;(())()&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2:
Input: s = &amp;quot;(a)())()&amp;quot; Output: [&amp;quot;(a())()&amp;quot;,&amp;quot;(a)()()&amp;quot;] Example 3:
Input: s = &amp;quot;)(&amp;quot; Output: [&amp;quot;&amp;quot;] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0303.Range-Sum-Query-Immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0303.Range-Sum-Query-Immutable/</guid><description>303. Range Sum Query - Immutable # 题目 # Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
Example:
Given nums = [-2, 0, 3, -5, 2, -1] sumRange(0, 2) -&amp;gt; 1 sumRange(2, 5) -&amp;gt; -1 sumRange(0, 5) -&amp;gt; -3 Note:
You may assume that the array does not change. There are many calls to sumRange function.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0304.Range-Sum-Query-2D-Immutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0304.Range-Sum-Query-2D-Immutable/</guid><description>304. Range Sum Query 2D - Immutable # 题目 # Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).
The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.
Example:
Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5] ] sumRegion(2, 1, 4, 3) -&amp;gt; 8 sumRegion(1, 1, 2, 2) -&amp;gt; 11 sumRegion(1, 2, 2, 4) -&amp;gt; 12 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0306.Additive-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0306.Additive-Number/</guid><description>306. Additive Number # 题目 # Additive number is a string whose digits can form additive sequence.
A valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.
Given a string containing only digits '0'-'9', write a function to determine if it&amp;rsquo;s an additive number.
Note: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0307.Range-Sum-Query-Mutable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0307.Range-Sum-Query-Mutable/</guid><description>307. Range Sum Query - Mutable # 题目 # Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.
The update(i, val) function modifies nums by updating the element at index i to val.
Example:
Given nums = [1, 3, 5] sumRange(0, 2) -&amp;gt; 9 update(1, 2) sumRange(0, 2) -&amp;gt; 8 Note:
The array is only modifiable by the update function.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0309.Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/</guid><description>309. Best Time to Buy and Sell Stock with Cooldown # 题目 # Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0315.Count-of-Smaller-Numbers-After-Self/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0315.Count-of-Smaller-Numbers-After-Self/</guid><description>315. Count of Smaller Numbers After Self # 题目 # You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].
Example:
Input: [5,2,6,1] Output: [2,1,1,0] Explanation: To the right of 5 there are 2 smaller elements (2 and 1). To the right of 2 there is only 1 smaller element (1).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0318.Maximum-Product-of-Word-Lengths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0318.Maximum-Product-of-Word-Lengths/</guid><description>318. Maximum Product of Word Lengths # 题目 # Given a string array words, find the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. You may assume that each word will contain only lower case letters. If no such two words exist, return 0.
Example 1:
Input: [&amp;quot;abcw&amp;quot;,&amp;quot;baz&amp;quot;,&amp;quot;foo&amp;quot;,&amp;quot;bar&amp;quot;,&amp;quot;xtfn&amp;quot;,&amp;quot;abcdef&amp;quot;] Output: 16 Explanation: The two words can be &amp;quot;abcw&amp;quot;, &amp;quot;xtfn&amp;quot;. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0319.Bulb-Switcher/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0319.Bulb-Switcher/</guid><description>319. Bulb Switcher # 题目 # There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.
On the third round, you toggle every third bulb (turning on if it&amp;rsquo;s off or turning off if it&amp;rsquo;s on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.
Return the number of bulbs that are on after n rounds.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0322.Coin-Change/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0322.Coin-Change/</guid><description>322. Coin Change # 题目 # You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.
Example 1:
Input: coins = [1, 2, 5], amount = 11 Output: 3 Explanation: 11 = 5 + 5 + 1 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0324.Wiggle-Sort-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0324.Wiggle-Sort-II/</guid><description>324. Wiggle Sort II # 题目 # Given an unsorted array nums, reorder it such that nums[0] &amp;lt; nums[1] &amp;gt; nums[2] &amp;lt; nums[3]&amp;hellip;.
Example 1:
Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2:
Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0326.Power-of-Three/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0326.Power-of-Three/</guid><description>326. Power of Three # 题目 # Given an integer, write a function to determine if it is a power of three.
Example 1:
Input: 27 Output: true Example 2:
Input: 0 Output: false Example 3:
Input: 9 Output: true Example 4:
Input: 45 Output: false Follow up:
Could you do it without using any loop / recursion?
题目大意 # 给定一个整数，写一个函数来判断它是否是 3 的幂次方。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0327.Count-of-Range-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0327.Count-of-Range-Sum/</guid><description>327. Count of Range Sum # 题目 # Given an integer array nums, return the number of range sums that lie in [lower, upper] inclusive.Range sum S(i, j) is defined as the sum of the elements in nums between indices i and j (i ≤ j), inclusive.
Note:A naive algorithm of O(n2) is trivial. You MUST do better than that.
Example:
Input: nums = [-2,5,-1], lower = -2, upper = 2, Output: 3 Explanation: The three ranges are : [0,0], [2,2], [0,2] and their respective sums are: -2, -1, 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0328.Odd-Even-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0328.Odd-Even-Linked-List/</guid><description>328. Odd Even Linked List # 题目 # Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.
You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.
Example 1:
Input: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL Output: 1-&amp;gt;3-&amp;gt;5-&amp;gt;2-&amp;gt;4-&amp;gt;NULL Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0329.Longest-Increasing-Path-in-a-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0329.Longest-Increasing-Path-in-a-Matrix/</guid><description>329. Longest Increasing Path in a Matrix # 题目 # Given an integer matrix, find the length of the longest increasing path.
From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).
Example 1:
Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0331.Verify-Preorder-Serialization-of-a-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0331.Verify-Preorder-Serialization-of-a-Binary-Tree/</guid><description>331. Verify Preorder Serialization of a Binary Tree # 题目 # One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node&amp;rsquo;s value. If it is a null node, we record using a sentinel value such as #.
_9_ / \ 3 2 / \ / \ 4 1 # 6 / \ / \ / \ # # # # # # For example, the above binary tree can be serialized to the string &amp;ldquo;9,3,4,#,#,1,#,#,2,#,6,#,#&amp;rdquo;, where # represents a null node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0337.House-Robber-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0337.House-Robber-III/</guid><description>337. House Robber III # 题目 # The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the &amp;ldquo;root.&amp;rdquo; Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that &amp;ldquo;all houses in this place forms a binary tree&amp;rdquo;. It will automatically contact the police if two directly-linked houses were broken into on the same night.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0338.Counting-Bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0338.Counting-Bits/</guid><description>338. Counting Bits # 题目 # Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1&amp;rsquo;s in their binary representation and return them as an array.
Example 1:
Input: 2 Output: [0,1,1] Example 2:
Input: 5 Output: [0,1,1,2,1,2] Follow up:
It is very easy to come up with a solution with run time O(n*sizeof(integer)).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0341.Flatten-Nested-List-Iterator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0341.Flatten-Nested-List-Iterator/</guid><description>341. Flatten Nested List Iterator # 题目 # Given a nested list of integers, implement an iterator to flatten it.
Each element is either an integer, or a list &amp;ndash; whose elements may also be integers or other lists.
Example 1:
Input:[[1,1],2,[1,1]] Output:[1,1,2,1,1] Explanation:By callingnext repeatedly untilhasNext returns false, the order of elements returned bynext should be:[1,1,2,1,1]. Example 2:
Input:[1,[4,[6]]] Output:[1,4,6] Explanation:By callingnext repeatedly untilhasNext returns false, the order of elements returned bynext should be:[1,4,6].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0342.Power-of-Four/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0342.Power-of-Four/</guid><description>342. Power of Four # 题目 # Given an integer (signed 32 bits), write a function to check whether it is a power of 4.
Example 1:
Input: 16 Output: true Example 2:
Input: 5 Output: false Follow up: Could you solve it without loops/recursion?
题目大意 # 给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。
解题思路 # 判断一个数是不是 4 的 n 次方。 这一题最简单的思路是循环，可以通过。但是题目要求不循环就要判断，这就需要用到数论的知识了。 证明 (4^n - 1) % 3 == 0，(1) 4^n - 1 = (2^n + 1) * (2^n - 1)(2) 在任何连续的 3 个数中 (2^n-1)，(2^n)，(2^n+1)，一定有一个数是 3 的倍数。(2^n) 肯定不是 3 的倍数，那么 (2^n-1) 或者 (2^n+1) 中一定有一个是 3 的倍数。所以 4^n-1 一定是 3 的倍数。 代码 # package leetcode // 解法一 数论 func isPowerOfFour(num int) bool { return num &amp;gt; 0 &amp;amp;&amp;amp; (num&amp;amp;(num-1)) == 0 &amp;amp;&amp;amp; (num-1)%3 == 0 } // 解法二 循环 func isPowerOfFour1(num int) bool { for num &amp;gt;= 4 { if num%4 == 0 { num = num / 4 } else { return false } } return num == 1 } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0343.Integer-Break/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0343.Integer-Break/</guid><description>343. Integer Break # 题目 # Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.
Example 1:
Input: 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1. Example 2:
Input: 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0344.Reverse-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0344.Reverse-String/</guid><description>344. Reverse String # 题目 # Write a function that reverses a string. The input string is given as an array of characters char[].
Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.
You may assume all the characters consist of printable ascii characters.
Example 1:
Input: [&amp;quot;h&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;o&amp;quot;] Output: [&amp;quot;o&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;l&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;h&amp;quot;] Example 2:
Input: [&amp;quot;H&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;h&amp;quot;] Output: [&amp;quot;h&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;n&amp;quot;,&amp;quot;a&amp;quot;,&amp;quot;H&amp;quot;] 题目大意 # 题目要求我们反转一个字符串。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0345.Reverse-Vowels-of-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0345.Reverse-Vowels-of-a-String/</guid><description>345. Reverse Vowels of a String # 题目 # Write a function that takes a string as input and reverse only the vowels of a string.
Example 1:
Input: &amp;quot;hello&amp;quot; Output: &amp;quot;holle&amp;quot; Example 2:
Input: &amp;quot;leetcode&amp;quot; Output: &amp;quot;leotcede&amp;quot; 题目大意 # 题目要求我们反转字符串中的元音字母。需要注意字母大小写。
解题思路 # 这一题的解题思路是用 2 个指针，指针对撞的思路，来不断交换首尾元素，即可。这一题和第 344 题思路一样。
代码 # package leetcode func reverseVowels(s string) string { b := []byte(s) for i, j := 0, len(b)-1; i &amp;lt; j; { if !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0347.Top-K-Frequent-Elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0347.Top-K-Frequent-Elements/</guid><description>347. Top K Frequent Elements # 题目 # Given a non-empty array of integers, return the k most frequent elements.
Example 1:
Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:
Input: nums = [1], k = 1 Output: [1] Note:
You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0349.Intersection-of-Two-Arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0349.Intersection-of-Two-Arrays/</guid><description>349. Intersection of Two Arrays # 题目 # Given two arrays, write a function to compute their intersection.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Note:
Each element in the result must be unique. The result can be in any order. 题目大意 # 找到两个数组的交集元素，如果交集元素同一个数字出现了多次，只输出一次。
解题思路 # 把数组一的每个数字都存进字典中，然后在数组二中依次判断字典中是否存在，如果存在，在字典中删除它(因为输出要求只输出一次)。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0350.Intersection-of-Two-Arrays-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0350.Intersection-of-Two-Arrays-II/</guid><description>350. Intersection of Two Arrays II # 题目 # Given two arrays, write a function to compute their intersection.
Example 1:
Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] Example 2:
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Note:
Each element in the result should appear as many times as it shows in both arrays. The result can be in any order. Follow up:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0352.Data-Stream-as-Disjoint-Intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0352.Data-Stream-as-Disjoint-Intervals/</guid><description>352. Data Stream as Disjoint Intervals # 题目 # Given a data stream input of non-negative integers a1, a2, &amp;hellip;, an, summarize the numbers seen so far as a list of disjoint intervals.
Implement the SummaryRanges class:
SummaryRanges() Initializes the object with an empty stream. void addNum(int val) Adds the integer val to the stream. int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0354.Russian-Doll-Envelopes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0354.Russian-Doll-Envelopes/</guid><description>354. Russian Doll Envelopes # 题目 # You have a number of envelopes with widths and heights given as a pair of integers (w, h). One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.
What is the maximum number of envelopes can you Russian doll? (put one inside other)</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0357.Count-Numbers-with-Unique-Digits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0357.Count-Numbers-with-Unique-Digits/</guid><description>357. Count Numbers with Unique Digits # 题目 # Given a non-negative integer n, count all numbers with unique digits, x, where 0 ≤ x &amp;lt; 10n.
Example:
Input: 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x &amp;lt; 100, excluding 11,22,33,44,55,66,77,88,99 题目大意 # 给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x &amp;lt; 10^n 。
解题思路 # 输出 n 位数中不出现重复数字的数字的个数 这道题摸清楚规律以后，可以直接写出最终所有答案，答案只有 11 个。 考虑不重复数字是如生成的。如果只是一位数，不存在重复的数字，结果是 10 。如果是二位数，第一位一定不能取 0，那么第一位有 1-9，9种取法，第二位为了和第一位不重复，只能有 0-9，10种取法中减去第一位取的数字，那么也是 9 种取法。以此类推，如果是三位数，第三位是 8 种取法；四位数，第四位是 7 种取法；五位数，第五位是 6 种取法；六位数，第六位是 5 种取法；七位数，第七位是 4 种取法；八位数，第八位是 3 种取法；九位数，第九位是 2 种取法；十位数，第十位是 1 种取法；十一位数，第十一位是 0 种取法；十二位数，第十二位是 0 种取法；那么第 11 位数以后，每个数都是重复数字的数字。知道这个规律以后，可以累积上面的结果，把结果直接存在数组里面，暴力打表即可。O(1) 的时间复杂度。 代码 # package leetcode // 暴力打表法 func countNumbersWithUniqueDigits1(n int) int { res := []int{1, 10, 91, 739, 5275, 32491, 168571, 712891, 2345851, 5611771, 8877691} if n &amp;gt;= 10 { return res[10] } return res[n] } // 打表方法 func countNumbersWithUniqueDigits(n int) int { if n == 0 { return 1 } res, uniqueDigits, availableNumber := 10, 9, 9 for n &amp;gt; 1 &amp;amp;&amp;amp; availableNumber &amp;gt; 0 { uniqueDigits = uniqueDigits * availableNumber res += uniqueDigits availableNumber-- n-- } return res } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0367.Valid-Perfect-Square/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0367.Valid-Perfect-Square/</guid><description>367. Valid Perfect Square # 题目 # Given a positive integer num, write a function which returns True if num is a perfect square else False.
Note: Do not use any built-in library function such as sqrt.
Example 1:
Input: 16 Output: true Example 2:
Input: 14 Output: false 题目大意 # 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。
说明：不要使用任何内置的库函数，如 sqrt。
解题思路 # 给出一个数，要求判断这个数是不是完全平方数。 可以用二分搜索来解答这道题。判断完全平方数，根据它的定义来，是否能被开根号，即找到一个数的平方是否可以等于待判断的数字。从 [1, n] 区间内进行二分，若能找到则返回 true，找不到就返回 false 。 代码 # package leetcode func isPerfectSquare(num int) bool { low, high := 1, num for low &amp;lt;= high { mid := low + (high-low)&amp;gt;&amp;gt;1 if mid*mid == num { return true } else if mid*mid &amp;lt; num { low = mid + 1 } else { high = mid - 1 } } return false } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0368.Largest-Divisible-Subset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0368.Largest-Divisible-Subset/</guid><description>368. Largest Divisible Subset # 题目 # Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:
answer[i] % answer[j] == 0, or answer[j] % answer[i] == 0 If there are multiple solutions, return any of them.
Example 1:
Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0371.Sum-of-Two-Integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0371.Sum-of-Two-Integers/</guid><description>371. Sum of Two Integers # 题目 # Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.
Example 1:
Input: a = 1, b = 2 Output: 3 Example 2:
Input: a = -2, b = 3 Output: 1 题目大意 # 不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。
解题思路 # 要求不用加法和减法运算符计算 a+b。这一题需要用到 ^ 和 &amp;amp; 运算符的性质，两个数 ^ 可以实现两个数不带进位的二进制加法。这里需要实现加法，肯定需要进位。所以如何找到进位是本题的关键。 在二进制中，只有 1 和 1 加在一起才会进位，0 和 0，0 和 1，1 和 0，这三种情况都不会进位，规律就是 a &amp;amp; b 为 0 的时候就不用进位，为 1 的时候代表需要进位。进位是往前进一位，所以还需要左移操作，所以加上的进位为 (a&amp;amp;b)&amp;lt;&amp;lt;1。 代码 # package leetcode func getSum(a int, b int) int { if a == 0 { return b } if b == 0 { return a } // (a &amp;amp; b)&amp;lt;&amp;lt;1 计算的是进位 // a ^ b 计算的是不带进位的加法 return getSum((a&amp;amp;b)&amp;lt;&amp;lt;1, a^b) } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0372.Super-Pow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0372.Super-Pow/</guid><description>372. Super Pow # 题目 # Your task is to calculate ab mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.
Example 1:
Input: a = 2, b = [3] Output: 8 Example 2:
Input: a = 2, b = [1,0] Output: 1024 题目大意 # 你的任务是计算 a^b 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0373.Find-K-Pairs-with-Smallest-Sums/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0373.Find-K-Pairs-with-Smallest-Sums/</guid><description>373. Find K Pairs with Smallest Sums # 题目 # You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k.
Define a pair (u,v) which consists of one element from the first array and one element from the second array.
Find the k pairs (u1,v1),(u2,v2) &amp;hellip;(uk,vk) with the smallest sums.
Example 1:
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0374.Guess-Number-Higher-or-Lower/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0374.Guess-Number-Higher-or-Lower/</guid><description>374. Guess Number Higher or Lower # 题目 # We are playing the Guess Game. The game is as follows:
I pick a number from 1 to n. You have to guess which number I picked.
Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.
You call a pre-defined API int guess(int num), which returns 3 possible results:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0376.Wiggle-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0376.Wiggle-Subsequence/</guid><description>376. Wiggle Subsequence # 题目 # Given an integer array nums, return the length of the longest wiggle sequence.
A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.
For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) are alternately positive and negative.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0377.Combination-Sum-IV/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0377.Combination-Sum-IV/</guid><description>377. Combination Sum IV # 题目 # Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.
The answer is guaranteed to fit in a 32-bit integer.
Example 1:
Input: nums = [1,2,3], target = 4 Output: 7 Explanation: The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0378.Kth-Smallest-Element-in-a-Sorted-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0378.Kth-Smallest-Element-in-a-Sorted-Matrix/</guid><description>378. Kth Smallest Element in a Sorted Matrix # 题目 # Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix.
Note that it is the kth smallest element in the sorted order, not the kth distinct element.
Example:
matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15] ], k = 8, return 13.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0382.Linked-List-Random-Node/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0382.Linked-List-Random-Node/</guid><description>382. Linked List Random Node # 题目 # Given a singly linked list, return a random node&amp;rsquo;s value from the linked list. Each node must have the same probability of being chosen.
Implement the Solution class:
Solution(ListNode head) Initializes the object with the integer array nums. int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be choosen.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0383.Ransom-Note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0383.Ransom-Note/</guid><description>383. Ransom Note # 题目 # Given two stings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote.
Example 1:
Input: ransomNote = &amp;quot;a&amp;quot;, magazine = &amp;quot;b&amp;quot; Output: false Example 2:
Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;ab&amp;quot; Output: false Example 3:
Input: ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;aab&amp;quot; Output: true Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0384.Shuffle-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0384.Shuffle-an-Array/</guid><description>384.Shuffle an Array # 题目 # Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.
Implement the Solution class:
Solution(int[] nums) Initializes the object with the integer array nums. int[] reset() Resets the array to its original configuration and returns it. int[] shuffle() Returns a random shuffling of the array.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0385.Mini-Parser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0385.Mini-Parser/</guid><description>385. Mini Parser # 题目 # Given a nested list of integers represented as a string, implement a parser to deserialize it.
Each element is either an integer, or a list &amp;ndash; whose elements may also be integers or other lists.
Note: You may assume that the string is well-formed:
String is non-empty. String does not contain white spaces. String contains only digits 0-9, [, - ,, ].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0386.Lexicographical-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0386.Lexicographical-Numbers/</guid><description>386. Lexicographical Numbers # 题目 # Given an integer n, return 1 - n in lexicographical order.
For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].
Please optimize your algorithm to use less time and space. The input size may be as large as 5,000,000.
题目大意 # 给定一个整数 n, 返回从 1 到 n 的字典顺序。例如，给定 n =13，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。
请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。
解题思路 # 给出一个数字 n ，要求按照字典序对 1-n 这 n 个数排序。 DFS 暴力求解即可。 代码 # package leetcode func lexicalOrder(n int) []int { res := make([]int, 0, n) dfs386(1, n, &amp;amp;res) return res } func dfs386(x, n int, res *[]int) { limit := (x + 10) / 10 * 10 for x &amp;lt;= n &amp;amp;&amp;amp; x &amp;lt; limit { *res = append(*res, x) if x*10 &amp;lt;= n { dfs386(x*10, n, res) } x++ } } ⬅️上一页</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0387.First-Unique-Character-in-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0387.First-Unique-Character-in-a-String/</guid><description>387. First Unique Character in a String # 题目 # Given a string, find the first non-repeating character in it and return it&amp;rsquo;s index. If it doesn&amp;rsquo;t exist, return -1.
Examples:
s = &amp;quot;leetcode&amp;quot; return 0. s = &amp;quot;loveleetcode&amp;quot;, return 2. Note: You may assume the string contain only lowercase letters.
题目大意 # 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
解题思路 # 简单题，要求输出第一个没有重复的字符。 解法二这个思路只超过 81% 的用户，但是如果测试样例中 s 的字符串很长，但是满足条件的字符都在靠后的位置的话，这个思路应该会更有优势。通过记录每个字符的第一次出现的位置和最后一次出现的位置。第一次对 s 进行一次遍历。第二次仅仅对数组进行遍历就可以了。 代码 # package leetcode // 解法 一 func firstUniqChar(s string) int { result := make([]int, 26) for i := 0; i &amp;lt; len(s); i++ { result[s[i]-&amp;#39;a&amp;#39;]++ } for i := 0; i &amp;lt; len(s); i++ { if result[s[i]-&amp;#39;a&amp;#39;] == 1 { return i } } return -1 } // 解法 二 // 执行用时: 8 ms // 内存消耗: 5.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0389.Find-the-Difference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0389.Find-the-Difference/</guid><description>389. Find the Difference # 题目 # Given two strings s and t which consist of only lowercase letters.
String t is generated by random shuffling string s and then add one more letter at a random position.
Find the letter that was added in t.
Example:
Input: s = &amp;quot;abcd&amp;quot; t = &amp;quot;abcde&amp;quot; Output: e Explanation: 'e' is the letter that was added. 题目大意 # 给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0390.Elimination-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0390.Elimination-Game/</guid><description>390. Elimination Game # 题目 # You have a list arr of all integers in the range [1, n] sorted in a strictly increasing order. Apply the following algorithm on arr:
Starting from left to right, remove the first number and every other number afterward until you reach the end of the list. Repeat the previous step again, but this time from right to left, remove the rightmost number and every other number from the remaining numbers.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0391.Perfect-Rectangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0391.Perfect-Rectangle/</guid><description>391. Perfect Rectangle # 题目 # Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).
Return true if all the rectangles together form an exact cover of a rectangular region.
Example1:
Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]] Output: true Explanation: All 5 rectangles together form an exact cover of a rectangular region.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0392.Is-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0392.Is-Subsequence/</guid><description>392. Is Subsequence # 题目 # Given a string s and a string t, check if s is subsequence of t.
You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&amp;lt;=100).
A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0393.UTF-8-Validation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0393.UTF-8-Validation/</guid><description>393. UTF-8 Validation # 题目 # A character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:
For 1-byte character, the first bit is a 0, followed by its unicode code. For n-bytes character, the first n-bits are all one&amp;rsquo;s, the n+1 bit is 0, followed by n-1 bytes with most significant 2 bits being 10. This is how the UTF-8 encoding would work:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0394.Decode-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0394.Decode-String/</guid><description>394. Decode String # 题目 # Given an encoded string, return its decoded string.
The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.
You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.
Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0395.Longest-Substring-with-At-Least-K-Repeating-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0395.Longest-Substring-with-At-Least-K-Repeating-Characters/</guid><description>395. Longest Substring with At Least K Repeating Characters # 题目 # Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.
Example 1:
Input: s = &amp;quot;aaabb&amp;quot;, k = 3 Output: 3 Explanation: The longest substring is &amp;quot;aaa&amp;quot;, as 'a' is repeated 3 times.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0396.Rotate-Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0396.Rotate-Function/</guid><description>396. Rotate Function # 题目 # You are given an integer array nums of length n.
Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:
F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1]. Return the maximum value of F(0), F(1), .</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0397.Integer-Replacement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0397.Integer-Replacement/</guid><description>397. Integer Replacement # 题目 # Given a positive integer n and you can do operations as follow:
If n is even, replace n with n/2. If n is odd, you can replace n with either n + 1 or n - 1. What is the minimum number of replacements needed for n to become 1?
Example 1:
Input: 8 Output: 3 Explanation: 8 -&amp;gt; 4 -&amp;gt; 2 -&amp;gt; 1 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0399.Evaluate-Division/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0300~0399/0399.Evaluate-Division/</guid><description>399. Evaluate Division # 题目 # Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.
Example:
Given a / b = 2.0, b / c = 3.0.queries are: a / c = ?, b / a = ?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0400.Nth-Digit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0400.Nth-Digit/</guid><description>400. Nth Digit # 题目 # Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, &amp;hellip;].
Example 1:
Input: n = 3 Output: 3 Example 2:
Input: n = 11 Output: 0 Explanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0401.Binary-Watch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0401.Binary-Watch/</guid><description>401. Binary Watch # 题目 # A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).
Each LED represents a zero or one, with the least significant bit on the right.
For example, the above binary watch reads &amp;ldquo;3:25&amp;rdquo;.
Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0402.Remove-K-Digits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0402.Remove-K-Digits/</guid><description>402. Remove K Digits # 题目 # Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note:
The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1:
Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0404.Sum-of-Left-Leaves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0404.Sum-of-Left-Leaves/</guid><description>404. Sum of Left Leaves # 题目 # Find the sum of all left leaves in a given binary tree.
Example:
3 / \ 9 20 / \ 15 7 There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24. 题目大意 # 计算给定二叉树的所有左叶子之和。
解题思路 # 这一题是微软的面试题。递归求解即可 代码 # package leetcode /** * Definition for a binary tree node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0405.Convert-a-Number-to-Hexadecimal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0405.Convert-a-Number-to-Hexadecimal/</guid><description>405. Convert a Number to Hexadecimal # 题目 # Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, two’s complement method is used.
Note:
All letters in hexadecimal (a-f) must be in lowercase. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0409.Longest-Palindrome/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0409.Longest-Palindrome/</guid><description>409. Longest Palindrome # 题目 # Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.
This is case sensitive, for example &amp;quot;Aa&amp;quot; is not considered a palindrome here.
Note:Assume the length of given string will not exceed 1,010.
Example:
Input: &amp;quot;abccccdd&amp;quot; Output: 7 Explanation: One longest palindrome that can be built is &amp;quot;dccaccd&amp;quot;, whose length is 7.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0410.Split-Array-Largest-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0410.Split-Array-Largest-Sum/</guid><description>410. Split Array Largest Sum # 题目 # Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
Note:If n is the length of array, assume the following constraints are satisfied:
1 ≤ n ≤ 1000 1 ≤ m ≤ min(50, n) Examples:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0412.Fizz-Buzz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0412.Fizz-Buzz/</guid><description>412. Fizz Buzz # 题目 # Write a program that outputs the string representation of numbers from 1 to n.
But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.
Example:
n = 15, Return: [ &amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;4&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;7&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;Buzz&amp;quot;, &amp;quot;11&amp;quot;, &amp;quot;Fizz&amp;quot;, &amp;quot;13&amp;quot;, &amp;quot;14&amp;quot;, &amp;quot;FizzBuzz&amp;quot; ] 题目大意 # 3的倍数输出 &amp;ldquo;Fizz&amp;rdquo;，5的倍数输出 &amp;ldquo;Buzz&amp;rdquo;，15的倍数输出 &amp;ldquo;FizzBuzz&amp;rdquo;，其他时候都输出原本的数字。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0413.Arithmetic-Slices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0413.Arithmetic-Slices/</guid><description>413. Arithmetic Slices # 题目 # A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.
For example, these are arithmetic sequences:
1, 3, 5, 7, 9 7, 7, 7, 7 3, -1, -5, -9 The following sequence is not arithmetic.
1, 1, 2, 5, 7 A zero-indexed array A consisting of N numbers is given.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0414.Third-Maximum-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0414.Third-Maximum-Number/</guid><description>414. Third Maximum Number # 题目 # Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).
Example 1:
Input: [3, 2, 1] Output: 1 Explanation: The third maximum is 1. Example 2:
Input: [1, 2] Output: 2 Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0416.Partition-Equal-Subset-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0416.Partition-Equal-Subset-Sum/</guid><description>416. Partition Equal Subset Sum # 题目 # Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.
Note:
Each of the array element will not exceed 100. The array size will not exceed 200. Example 1:
Input: [1, 5, 11, 5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0417.Pacific-Atlantic-Water-Flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0417.Pacific-Atlantic-Water-Flow/</guid><description>417. Pacific Atlantic Water Flow # 题目 # Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the &amp;ldquo;Pacific ocean&amp;rdquo; touches the left and top edges of the matrix and the &amp;ldquo;Atlantic ocean&amp;rdquo; touches the right and bottom edges.
Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0419.Battleships-in-a-Board/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0419.Battleships-in-a-Board/</guid><description>419. Battleships in a Board # 题目 # Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.
Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0421.Maximum-XOR-of-Two-Numbers-in-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0421.Maximum-XOR-of-Two-Numbers-in-an-Array/</guid><description>421. Maximum XOR of Two Numbers in an Array # 题目 # Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &amp;lt; 231.
Find the maximum result of ai XOR aj, where 0 ≤ i, j &amp;lt; n.
Could you do this in O(n) runtime?
Example:
Input: [3, 10, 5, 25, 2, 8] Output: 28 Explanation: The maximum result is 5 ^ 25 = 28.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0423.Reconstruct-Original-Digits-from-English/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0423.Reconstruct-Original-Digits-from-English/</guid><description>423. Reconstruct Original Digits from English # 题目 # Given a non-empty string containing an out-of-order English representation of digits 0-9, output the digits in ascending order.
Note:
Input contains only lowercase English letters. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as &amp;ldquo;abc&amp;rdquo; or &amp;ldquo;zerone&amp;rdquo; are not permitted. Input length is less than 50,000. Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0424.Longest-Repeating-Character-Replacement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0424.Longest-Repeating-Character-Replacement/</guid><description>424. Longest Repeating Character Replacement # 题目 # Given a string that consists of only uppercase English letters, you can replace any letter in the string with another letter at most k times. Find the length of a longest substring containing all repeating letters you can get after performing the above operations.
Note:
Both the string&amp;rsquo;s length and k will not exceed 10^4.
Example 1:
Input: s = &amp;quot;ABAB&amp;quot;, k = 2 Output: 4 Explanation: Replace the two 'A's with two 'B's or vice versa.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0429.N-ary-Tree-Level-Order-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0429.N-ary-Tree-Level-Order-Traversal/</guid><description>429.N-ary Tree Level Order Traversal # 题目 # Given an n-ary tree, return the level order traversal of its nodes&amp;rsquo; values.
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).
Example 1:
Input: root = [1,null,3,2,4,null,5,6] Output: [[1],[3,2,4],[5,6]] Example 2:
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] Constraints:
The height of the n-ary tree is less than or equal to 1000 The total number of nodes is between [0, 104] 题目大意 # 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0433.Minimum-Genetic-Mutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0433.Minimum-Genetic-Mutation/</guid><description>433. Minimum Genetic Mutation # 题目 # A gene string can be represented by an 8-character long string, with choices from &amp;quot;A&amp;quot;, &amp;quot;C&amp;quot;, &amp;quot;G&amp;quot;, &amp;quot;T&amp;quot;.
Suppose we need to investigate about a mutation (mutation from &amp;ldquo;start&amp;rdquo; to &amp;ldquo;end&amp;rdquo;), where ONE mutation is defined as ONE single character changed in the gene string.
For example, &amp;quot;AACCGGTT&amp;quot; -&amp;gt; &amp;quot;AACCGGTA&amp;quot; is 1 mutation.
Also, there is a given gene &amp;ldquo;bank&amp;rdquo;, which records all the valid gene mutations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0434.Number-of-Segments-in-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0434.Number-of-Segments-in-a-String/</guid><description>434. Number of Segments in a String # 题目 # You are given a string s, return the number of segments in the string.
A segment is defined to be a contiguous sequence of non-space characters.
Example 1:
Input: s = &amp;quot;Hello, my name is John&amp;quot; Output: 5 Explanation: The five segments are [&amp;quot;Hello,&amp;quot;, &amp;quot;my&amp;quot;, &amp;quot;name&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;John&amp;quot;] Example 2:
Input: s = &amp;quot;Hello&amp;quot; Output: 1 Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0435.Non-overlapping-Intervals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0435.Non-overlapping-Intervals/</guid><description>435. Non-overlapping Intervals # 题目 # Given a collection of intervals, find the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.
Note:
You may assume the interval&amp;rsquo;s end point is always bigger than its start point. Intervals like [1,2] and [2,3] have borders &amp;ldquo;touching&amp;rdquo; but they don&amp;rsquo;t overlap each other. Example 1:
Input: [ [1,2], [2,3], [3,4], [1,3] ] Output: 1 Explanation: [1,3] can be removed and the rest of intervals are non-overlapping.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0436.Find-Right-Interval/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0436.Find-Right-Interval/</guid><description>436. Find Right Interval # 题目 # Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the &amp;ldquo;right&amp;rdquo; of i.
For any interval i, you need to store the minimum interval j&amp;rsquo;s index, which means that the interval j has the minimum start point to build the &amp;ldquo;right&amp;rdquo; relationship for interval i.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0437.Path-Sum-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0437.Path-Sum-III/</guid><description>437. Path Sum III # 题目 # Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum.
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).
Example 1:
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3 Explanation: The paths that sum to 8 are shown.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0438.Find-All-Anagrams-in-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0438.Find-All-Anagrams-in-a-String/</guid><description>438. Find All Anagrams in a String # 题目 # Given a string s and a non-empty string p, find all the start indices of p&amp;rsquo;s anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
The order of output does not matter.
Example 1:
Input: s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot; Output: [0, 6] Explanation: The substring with start index = 0 is &amp;quot;cba&amp;quot;, which is an anagram of &amp;quot;abc&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0441.Arranging-Coins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0441.Arranging-Coins/</guid><description>441. Arranging Coins # 题目 # You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.
Given n, find the total number of full staircase rows that can be formed.
n is a non-negative integer and fits within the range of a 32-bit signed integer.
Example 1:
n = 5 The coins can form the following rows: ¤ ¤ ¤ ¤ ¤ Because the 3rd row is incomplete, we return 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0445.Add-Two-Numbers-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0445.Add-Two-Numbers-II/</guid><description>445. Add Two Numbers II # 题目 # You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
Follow up: What if you cannot modify the input lists?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0447.Number-of-Boomerangs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0447.Number-of-Boomerangs/</guid><description>447. Number of Boomerangs # 题目 # Given n points in the plane that are all pairwise distinct, a &amp;ldquo;boomerang&amp;rdquo; is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (the order of the tuple matters).
Find the number of boomerangs. You may assume that n will be at most 500 and coordinates of points are all in the range [-10000, 10000] (inclusive).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0448.Find-All-Numbers-Disappeared-in-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0448.Find-All-Numbers-Disappeared-in-an-Array/</guid><description>448. Find All Numbers Disappeared in an Array # 题目 # Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.
Find all the elements of [1, n] inclusive that do not appear in this array.
Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0451.Sort-Characters-By-Frequency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0451.Sort-Characters-By-Frequency/</guid><description>451. Sort Characters By Frequency # 题目 # Given a string, sort it in decreasing order based on the frequency of characters.
Example 1:
Input: &amp;quot;tree&amp;quot; Output: &amp;quot;eert&amp;quot; Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore &amp;quot;eetr&amp;quot; is also a valid answer. Example 2:
Input: &amp;quot;cccaaa&amp;quot; Output: &amp;quot;cccaaa&amp;quot; Explanation: Both 'c' and 'a' appear three times, so &amp;quot;aaaccc&amp;quot; is also a valid answer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0453.Minimum-Moves-to-Equal-Array-Elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0453.Minimum-Moves-to-Equal-Array-Elements/</guid><description>453. Minimum Moves to Equal Array Elements # 题目 # Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.
Example:
Input: [1,2,3] Output: 3 Explanation: Only three moves are needed (remember each move increments two elements): [1,2,3] =&amp;gt; [2,3,3] =&amp;gt; [3,4,3] =&amp;gt; [4,4,4] 题目大意 # 给定一个长度为 n 的非空整数数组，找到让数组所有元素相等的最小移动次数。每次移动将会使 n - 1 个元素增加 1。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0454.4Sum-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0454.4Sum-II/</guid><description>454. 4Sum II # 题目 # Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.
To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0455.Assign-Cookies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0455.Assign-Cookies/</guid><description>455. Assign Cookies # 题目 # Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj &amp;gt;= gi, we can assign the cookie j to the child i, and the child i will be content.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0456.132-Pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0456.132-Pattern/</guid><description>456. 132 Pattern # 题目 # Given a sequence of n integers a1, a2, &amp;hellip;, an, a 132 pattern is a subsequence ai, aj, ak such that i &amp;lt; j &amp;lt; k and ai &amp;lt; ak &amp;lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.
Note: n will be less than 15,000.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0457.Circular-Array-Loop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0457.Circular-Array-Loop/</guid><description>457. Circular Array Loop # 题目 # You are given a circular array nums of positive and negative integers. If a number k at an index is positive, then move forward k steps. Conversely, if it&amp;rsquo;s negative (-k), move backward k steps. Since the array is circular, you may assume that the last element&amp;rsquo;s next element is the first element, and the first element&amp;rsquo;s previous element is the last element.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0458.Poor-Pigs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0458.Poor-Pigs/</guid><description>458. Poor Pigs # 题目 # There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.
You can feed the pigs according to these steps:
Choose some live pigs to feed.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0460.LFU-Cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0460.LFU-Cache/</guid><description>460. LFU Cache # 题目 # Design and implement a data structure for Least Frequently Used (LFU) cache.
Implement the LFUCache class:
LFUCache(int capacity) Initializes the object with the capacity of the data structure. int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns 1. void put(int key, int value) Sets or inserts the value if the key is not already present.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0461.Hamming-Distance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0461.Hamming-Distance/</guid><description>461. Hamming Distance # 题目 # The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Given two integers x and y, calculate the Hamming distance.
Note: 0 ≤ x, y &amp;lt; 231.
Example:
Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0462.Minimum-Moves-to-Equal-Array-Elements-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0462.Minimum-Moves-to-Equal-Array-Elements-II/</guid><description>462. Minimum Moves to Equal Array Elements II # 题目 # Given an integer array nums of size n, return the minimum number of moves required to make all array elements equal.
In one move, you can increment or decrement an element of the array by 1.
Example 1:
Input: nums = [1,2,3] Output: 2 Explanation: Only two moves are needed (remember each move increments or decrements one element): [1,2,3] =&amp;gt; [2,2,3] =&amp;gt; [2,2,2] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0463.Island-Perimeter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0463.Island-Perimeter/</guid><description>463. Island Perimeter # 题目 # You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water.
Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).
The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0470.Implement-Rand10-Using-Rand7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0470.Implement-Rand10-Using-Rand7/</guid><description>470. Implement Rand10() Using Rand7() # 题目 # Given a function rand7 which generates a uniform random integer in the range 1 to 7, write a function rand10 which generates a uniform random integer in the range 1 to 10.
Do NOT use system&amp;rsquo;s Math.random().
Example 1:
Input: 1 Output: [7] Example 2:
Input: 2 Output: [8,4] Example 3:
Input: 3 Output: [8,1,10] Note:
rand7 is predefined.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0473.Matchsticks-to-Square/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0473.Matchsticks-to-Square/</guid><description>473. Matchsticks to Square # 题目 # You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.
Return true if you can make this square and false otherwise.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0474.Ones-and-Zeroes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0474.Ones-and-Zeroes/</guid><description>474. Ones and Zeroes # 题目 # In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.
For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.
Now your task is to find the maximum number of strings that you can form with given m0s and n 1s.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0475.Heaters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0475.Heaters/</guid><description>475. Heaters # 题目 # Winter is coming! Your first job during the contest is to design a standard heater with fixed warm radius to warm all the houses.
Now, you are given positions of houses and heaters on a horizontal line, find out minimum radius of heaters so that all houses could be covered by those heaters.
So, your input will be the positions of houses and heaters seperately, and your expected output will be the minimum radius standard of heaters.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0476.Number-Complement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0476.Number-Complement/</guid><description>476. Number Complement # 题目 # Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.
Note:
The given integer is guaranteed to fit within the range of a 32-bit signed integer. You could assume no leading zero bit in the integer’s binary representation. Example 1:
Input: 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0477.Total-Hamming-Distance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0477.Total-Hamming-Distance/</guid><description>477. Total Hamming Distance # 题目 # The Hamming distance between two integers is the number of positions at which the corresponding bits are different.
Now your job is to find the total Hamming distance between all pairs of the given numbers.
Example:
Input: 4, 14, 2 Output: 6 Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (just showing the four bits relevant in this case).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0478.Generate-Random-Point-in-a-Circle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0478.Generate-Random-Point-in-a-Circle/</guid><description>478. Generate Random Point in a Circle # 题目 # Given the radius and x-y positions of the center of a circle, write a function randPoint which generates a uniform random point in the circle.
Note:
input and output values are in floating-point. radius and x-y position of the center of the circle is passed into the class constructor. a point on the circumference of the circle is considered to be in the circle.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0480.Sliding-Window-Median/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0480.Sliding-Window-Median/</guid><description>480. Sliding Window Median # 题目 # Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
Examples:
[2,3,4] , the median is 3
[2,3], the median is (2 + 3) / 2 = 2.5
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0483.Smallest-Good-Base/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0483.Smallest-Good-Base/</guid><description>483. Smallest Good Base # 题目 # For an integer n, we call k&amp;gt;=2 a good base of n, if all digits of n base k are 1.
Now given a string representing n, you should return the smallest good base of n in string format.
Example 1:
Input: &amp;quot;13&amp;quot; Output: &amp;quot;3&amp;quot; Explanation: 13 base 3 is 111. Example 2:
Input: &amp;quot;4681&amp;quot; Output: &amp;quot;8&amp;quot; Explanation: 4681 base 8 is 11111.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0485.Max-Consecutive-Ones/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0485.Max-Consecutive-Ones/</guid><description>485. Max Consecutive Ones # 题目 # Given a binary array, find the maximum number of consecutive 1s in this array.
Example 1:
Input: [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note:
The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 题目大意 # 给定一个二进制数组， 计算其中最大连续1的个数。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0488.Zuma-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0488.Zuma-Game/</guid><description>488. Zuma Game # 题目 # You are playing a variation of the game Zuma.
In this variation of Zuma, there is a single row of colored balls on a board, where each ball can be colored red &amp;lsquo;R&amp;rsquo;, yellow &amp;lsquo;Y&amp;rsquo;, blue &amp;lsquo;B&amp;rsquo;, green &amp;lsquo;G&amp;rsquo;, or white &amp;lsquo;W&amp;rsquo;. You also have several colored balls in your hand.
Your goal is to clear all of the balls from the board.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0491.Non-decreasing-Subsequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0491.Non-decreasing-Subsequences/</guid><description>491. Non-decreasing Subsequences # 题目 # Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2.
Example:
Input: [4, 6, 7, 7] Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]] Note:
The length of the given array will not exceed 15.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0492.Construct-the-Rectangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0492.Construct-the-Rectangle/</guid><description>492. Construct the Rectangle # 题目 # A web developer needs to know how to design a web page&amp;rsquo;s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:
The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L &amp;gt;= W.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0493.Reverse-Pairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0493.Reverse-Pairs/</guid><description>493. Reverse Pairs # 题目 # Given an array nums, we call (i, j) an important reverse pair if i &amp;lt; j and nums[i] &amp;gt; 2*nums[j].
You need to return the number of important reverse pairs in the given array.
Example1:
Input: [1,3,2,3,1] Output: 2 Example2:
Input: [2,4,3,5,1] Output: 3 Note:
The length of the given array will not exceed 50,000. All the numbers in the input array are in the range of 32-bit integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0494.Target-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0494.Target-Sum/</guid><description>494. Target Sum # 题目 # You are given a list of non-negative integers, a1, a2, &amp;hellip;, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.
Find out how many ways to assign symbols to make sum of integers equal to target S.
Example 1:
Input: nums is [1, 1, 1, 1, 1], S is 3.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0495.Teemo-Attacking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0495.Teemo-Attacking/</guid><description>495. Teemo Attacking # 题目 # Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds.
More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1].
If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0496.Next-Greater-Element-I/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0496.Next-Greater-Element-I/</guid><description>496. Next Greater Element I # 题目 # You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1&amp;rsquo;s elements in the corresponding places of nums2.
The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0497.Random-Point-in-Non-overlapping-Rectangles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0497.Random-Point-in-Non-overlapping-Rectangles/</guid><description>497. Random Point in Non-overlapping Rectangles # 题目 # Given a list of non-overlapping axis-aligned rectangles rects, write a function pick which randomly and uniformily picks an integer point in the space covered by the rectangles.
Note:
An integer point is a point that has integer coordinates. A point on the perimeter of a rectangle is included in the space covered by the rectangles. ith rectangle = rects[i] = [x1,y1,x2,y2], where [x1, y1] are the integer coordinates of the bottom-left corner, and [x2, y2] are the integer coordinates of the top-right corner.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0498.Diagonal-Traverse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0400~0499/0498.Diagonal-Traverse/</guid><description>498. Diagonal Traverse # 题目 # Given a matrix of M x N elements (M rows, N columns), return all elements of the matrix in diagonal order as shown in the below image.
Example:
Input: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1,2,4,7,5,3,6,8,9] Explanation: Note:
The total number of elements of the given matrix will not exceed 10,000.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0500.Keyboard-Row/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0500.Keyboard-Row/</guid><description>500. Keyboard Row # 题目 # Given a List of words, return the words that can be typed using letters of alphabet on only one row&amp;rsquo;s of American keyboard like the image below.
Example:
Input: [&amp;quot;Hello&amp;quot;, &amp;quot;Alaska&amp;quot;, &amp;quot;Dad&amp;quot;, &amp;quot;Peace&amp;quot;] Output: [&amp;quot;Alaska&amp;quot;, &amp;quot;Dad&amp;quot;] Note:
You may use one character in the keyboard more than once. You may assume the input string will only contain letters of alphabet.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0503.Next-Greater-Element-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0503.Next-Greater-Element-II/</guid><description>503. Next Greater Element II # 题目 # Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&amp;rsquo;t exist, output -1 for this number.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0504.Base-7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0504.Base-7/</guid><description>504. Base 7 # 题目 # Given an integer num, return a string of its base 7 representation.
Example 1:
Input: num = 100 Output: &amp;quot;202&amp;quot; Example 2:
Input: num = -7 Output: &amp;quot;-10&amp;quot; Constraints:
-10000000 &amp;lt;= num &amp;lt;= 10000000 题目大意 # 给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。
解题思路 # num反复除以7，然后倒排余数 代码 # package leetcode import &amp;#34;strconv&amp;#34; func convertToBase7(num int) string { if num == 0 { return &amp;#34;0&amp;#34; } negative := false if num &amp;lt; 0 { negative = true num = -num } var ans string var nums []int for num !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0506.Relative-Ranks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0506.Relative-Ranks/</guid><description>506. Relative Ranks # 题目 # You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.
The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0507.Perfect-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0507.Perfect-Number/</guid><description>507. Perfect Number # 题目 # We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.
Now, given an
integer
n, write a function that returns true when it is a perfect number and false when it is not.
Example:
Input: 28 Output: True Explanation: 28 = 1 + 2 + 4 + 7 + 14 Note: The input number n will not exceed 100,000,000.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0508.Most-Frequent-Subtree-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0508.Most-Frequent-Subtree-Sum/</guid><description>508. Most Frequent Subtree Sum # 题目 # Given the root of a tree, you are asked to find the most frequent subtree sum. The subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself). So what is the most frequent subtree sum value? If there is a tie, return all the values with the highest frequency in any order.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0509.Fibonacci-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0509.Fibonacci-Number/</guid><description>509. Fibonacci Number # 题目 # The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,
F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), for N &amp;gt; 1. Given N, calculate F(N).
Example 1:
Input: 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0513.Find-Bottom-Left-Tree-Value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0513.Find-Bottom-Left-Tree-Value/</guid><description>513. Find Bottom Left Tree Value # 题目 # Given a binary tree, find the leftmost value in the last row of the tree.
Example 1:
Input: 2 / \ 1 3 Output: 1 Example 2:
Input: 1 / \ 2 3 / / \ 4 5 6 / 7 Output: 7 Note: You may assume the tree (i.e., the given root node) is not NULL.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0515.Find-Largest-Value-in-Each-Tree-Row/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0515.Find-Largest-Value-in-Each-Tree-Row/</guid><description>515. Find Largest Value in Each Tree Row # 题目 # You need to find the largest value in each row of a binary tree.
Example:
Input: 1 / \ 3 2 / \ \ 5 3 9 Output: [1, 3, 9] 题目大意 # 求在二叉树的每一行中找到最大的值。
解题思路 # 给出一个二叉树，要求依次输出每行的最大值 用 BFS 层序遍历，将每层排序取出最大值。改进的做法是遍历中不断更新每层的最大值。 代码 # package leetcode import ( &amp;#34;math&amp;#34; &amp;#34;sort&amp;#34; ) /** * Definition for a binary tree node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0518.Coin-Change-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0518.Coin-Change-II/</guid><description>518. Coin Change II # 题目 # You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.
Return the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.
You may assume that you have an infinite number of each kind of coin.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0519.Random-Flip-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0519.Random-Flip-Matrix/</guid><description>519. Random Flip Matrix # 题目 # There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to randomly pick an index (i, j) where matrix[i][j] == 0 and flips it to 1. All the indices (i, j) where matrix[i][j] == 0 should be equally likely to be returned.
Optimize your algorithm to minimize the number of calls made to the built-in random function of your language and optimize the time and space complexity.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0520.Detect-Capital/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0520.Detect-Capital/</guid><description>520. Detect Capital # 题目 # We define the usage of capitals in a word to be right when one of the following cases holds:
All letters in this word are capitals, like &amp;ldquo;USA&amp;rdquo;.
All letters in this word are not capitals, like &amp;ldquo;leetcode&amp;rdquo;.
Only the first letter in this word is capital, like &amp;ldquo;Google&amp;rdquo;.
Given a string word, return true if the usage of capitals in it is right.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0523.Continuous-Subarray-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0523.Continuous-Subarray-Sum/</guid><description>523. Continuous Subarray Sum # 题目 # Given an integer array nums and an integer k, return true if nums has a continuous subarray of size at least two whose elements sum up to a multiple of k*, or* false *otherwise*.
An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0524.Longest-Word-in-Dictionary-through-Deleting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0524.Longest-Word-in-Dictionary-through-Deleting/</guid><description>524. Longest Word in Dictionary through Deleting # 题目 # Given a string and a string dictionary, find the longest string in the dictionary that can be formed by deleting some characters of the given string. If there are more than one possible results, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.
Example 1:
Input: s = &amp;quot;abpcplea&amp;quot;, d = [&amp;quot;ale&amp;quot;,&amp;quot;apple&amp;quot;,&amp;quot;monkey&amp;quot;,&amp;quot;plea&amp;quot;] Output: &amp;quot;apple&amp;quot; Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0525.Contiguous-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0525.Contiguous-Array/</guid><description>525. Contiguous Array # 题目 # Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.
Example 1:
Input: nums = [0,1] Output: 2 Explanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1. Example 2:
Input: nums = [0,1,0] Output: 2 Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0526.Beautiful-Arrangement/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0526.Beautiful-Arrangement/</guid><description>526. Beautiful Arrangement # 题目 # Suppose you have N integers from 1 to N. We define a beautiful arrangement as an array that is constructed by these N numbers successfully if one of the following is true for the ith position (1 &amp;lt;= i &amp;lt;= N) in this array:
The number at the i position is divisible by i.th i is divisible by the number at the i position.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0528.Random-Pick-with-Weight/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0528.Random-Pick-with-Weight/</guid><description>528. Random Pick with Weight # 题目 # Given an array w of positive integers, where w[i] describes the weight of index i, write a function pickIndex which randomly picks an index in proportion to its weight.
Note:
1 &amp;lt;= w.length &amp;lt;= 10000 1 &amp;lt;= w[i] &amp;lt;= 10^5 pickIndex will be called at most 10000 times. Example 1:
Input: [&amp;quot;Solution&amp;quot;,&amp;quot;pickIndex&amp;quot;] [[[1]],[]] Output: [null,0] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0529.Minesweeper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0529.Minesweeper/</guid><description>529. Minesweeper # 题目 # Let&amp;rsquo;s play the minesweeper game ( Wikipedia, online game)!
You are given a 2D char matrix representing the game board. &amp;lsquo;M&amp;rsquo; represents an unrevealed mine, &amp;lsquo;E&amp;rsquo; represents an unrevealed empty square, &amp;lsquo;B&amp;rsquo; represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (&amp;lsquo;1&amp;rsquo; to &amp;lsquo;8&amp;rsquo;) represents how many mines are adjacent to this revealed square, and finally &amp;lsquo;X&amp;rsquo; represents a revealed mine.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0530.Minimum-Absolute-Difference-in-BST/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0530.Minimum-Absolute-Difference-in-BST/</guid><description>530. Minimum Absolute Difference in BST # 题目 # Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.
Example:
Input: 1 \ 3 / 2 Output: 1 Explanation: The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3). Note:
There are at least two nodes in this BST. This question is the same as 783: https://leetcode.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0532.K-diff-Pairs-in-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0532.K-diff-Pairs-in-an-Array/</guid><description>532. K-diff Pairs in an Array # 题目 # Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.
Example 1:
Input: [3, 1, 4, 1, 5], k = 2 Output: 2 Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0535.Encode-and-Decode-TinyURL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0535.Encode-and-Decode-TinyURL/</guid><description>535. Encode and Decode TinyURL # 题目 # Note: This is a companion problem to the System Design problem: Design TinyURL.
TinyURL is a URL shortening service where you enter a URL such as https://leetcode.com/problems/design-tinyurl and it returns a short URL such as http://tinyurl.com/4e9iAk.
Design the encode and decode methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0537.Complex-Number-Multiplication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0537.Complex-Number-Multiplication/</guid><description>537. Complex Number Multiplication # 题目 # Given two strings representing two complex numbers.
You need to return a string representing their multiplication. Note i2 = -1 according to the definition.
Example 1:
Input: &amp;quot;1+1i&amp;quot;, &amp;quot;1+1i&amp;quot; Output: &amp;quot;0+2i&amp;quot; Explanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0538.Convert-BST-to-Greater-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0538.Convert-BST-to-Greater-Tree/</guid><description>538. Convert BST to Greater Tree # 题目 # Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.
As a reminder, a binary search tree is a tree that satisfies these constraints:
The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0540.Single-Element-in-a-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0540.Single-Element-in-a-Sorted-Array/</guid><description>540. Single Element in a Sorted Array # 题目 # You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once.
Return the single element that appears only once.
Your solution must run in O(log n) time and O(1) space.
Example 1:
Input: nums = [1,1,2,3,3,4,4,8,8] Output: 2 Example 2:
Input: nums = [3,3,7,7,10,11,11] Output: 10 Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0541.Reverse-String-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0541.Reverse-String-II/</guid><description>541. Reverse String II # 题目 # Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0542.01-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0542.01-Matrix/</guid><description>542. 01 Matrix # 题目 # Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.
The distance between two adjacent cells is 1.
Example 1:
Input: [[0,0,0], [0,1,0], [0,0,0]] Output: [[0,0,0], [0,1,0], [0,0,0]] Example 2:
Input: [[0,0,0], [0,1,0], [1,1,1]] Output: [[0,0,0], [0,1,0], [1,2,1]] Note:
The number of elements of the given matrix will not exceed 10,000. There are at least one 0 in the given matrix.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0543.Diameter-of-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0543.Diameter-of-Binary-Tree/</guid><description>543. Diameter of Binary Tree # 题目 # Given the root of a binary tree, return the length of the diameter of the tree.
The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.
The length of a path between two nodes is represented by the number of edges between them.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0547.Number-of-Provinces/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0547.Number-of-Provinces/</guid><description>547. Number of Provinces # 题目 # There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a directfriend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0551.Student-Attendance-Record-I/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0551.Student-Attendance-Record-I/</guid><description>551. Student Attendance Record I # 题目 # You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:
'A': Absent. 'L': Late. 'P': Present. The student is eligible for an attendance award if they meet both of the following criteria:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0554.Brick-Wall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0554.Brick-Wall/</guid><description>554. Brick Wall # 题目 # There is a rectangular brick wall in front of you with n rows of bricks. The ith row has some number of bricks each of the same height (i.e., one unit) but they can be of different widths. The total width of each row is the same.
Draw a vertical line from the top to the bottom and cross the least bricks. If your line goes through the edge of a brick, then the brick is not considered as crossed.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0557.Reverse-Words-in-a-String-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0557.Reverse-Words-in-a-String-III/</guid><description>557. Reverse Words in a String III # 题目 # Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.
Example 1:
Input: &amp;quot;Let's take LeetCode contest&amp;quot; Output: &amp;quot;s'teL ekat edoCteeL tsetnoc&amp;quot; Note: In the string, each word is separated by single space and there will not be any extra space in the string.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0559.Maximum-Depth-of-N-ary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0559.Maximum-Depth-of-N-ary-Tree/</guid><description>559. Maximum Depth of N-ary Tree # 题目 # Given a n-ary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).
Example 1:
Input: root = [1,null,3,2,4,null,5,6] Output: 3 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0560.Subarray-Sum-Equals-K/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0560.Subarray-Sum-Equals-K/</guid><description>560. Subarray Sum Equals K # 题目 # Given an array of integers nums and an integer k, return the total number of continuous subarrays whose sum equals to k.
Example 1:
Input: nums = [1,1,1], k = 2 Output: 2 Example 2:
Input: nums = [1,2,3], k = 3 Output: 2 Constraints:
1 &amp;lt;= nums.length &amp;lt;= 2 * 104 -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -10^7 &amp;lt;= k &amp;lt;= 10^7 题目大意 # 给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k ****的连续子数组的个数。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0561.Array-Partition/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0561.Array-Partition/</guid><description>561. Array Partition # 题目 # Given an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), &amp;hellip;, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.
Example 1:
Input: [1,4,3,2] Output: 4 Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0563.Binary-Tree-Tilt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0563.Binary-Tree-Tilt/</guid><description>563. Binary Tree Tilt # 题目 # Given a binary tree, return the tilt of the whole tree.
The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.
The tilt of the whole tree is defined as the sum of all nodes&amp;rsquo; tilt.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0566.Reshape-the-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0566.Reshape-the-Matrix/</guid><description>566. Reshape the Matrix # 题目 # In MATLAB, there is a very useful function called &amp;lsquo;reshape&amp;rsquo;, which can reshape a matrix into a new one with different size but keep its original data.
You&amp;rsquo;re given a matrix represented by a two-dimensional array, and two positive integers r and crepresenting the row number and column number of the wanted reshaped matrix, respectively.
The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0567.Permutation-in-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0567.Permutation-in-String/</guid><description>567. Permutation in String # 题目 # Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string&amp;rsquo;s permutations is the substring of the second string.
Example 1:
Input:s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot; Output:True Explanation: s2 contains one permutation of s1 (&amp;quot;ba&amp;quot;). Example 2:
Input:s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot; Output: False Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0572.Subtree-of-Another-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0572.Subtree-of-Another-Tree/</guid><description>572. Subtree of Another Tree # 题目 # Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node&amp;rsquo;s descendants. The tree s could also be considered as a subtree of itself.
Example 1:
Given tree s:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0575.Distribute-Candies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0575.Distribute-Candies/</guid><description>575. Distribute Candies # 题目 # Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.
Example 1:
Input: candies = [1,1,2,2,3,3] Output: 3 Explanation: There are three different kinds of candies (1, 2 and 3), and two candies for each kind.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0576.Out-of-Boundary-Paths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0576.Out-of-Boundary-Paths/</guid><description>576. Out of Boundary Paths # 题目 # There is an m x n grid with a ball. The ball is initially at the position [startRow, startColumn]. You are allowed to move the ball to one of the four adjacent four cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most maxMove moves to the ball.
Given the five integers m, n, maxMove, startRow, startColumn, return the number of paths to move the ball out of the grid boundary.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0581.Shortest-Unsorted-Continuous-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0581.Shortest-Unsorted-Continuous-Subarray/</guid><description>581. Shortest Unsorted Continuous Subarray # 题目 # Given an integer array nums, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order.
Return the shortest such subarray and output its length.
Example 1:
Input: nums = [2,6,4,8,10,9,15] Output: 5 Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0583.Delete-Operation-for-Two-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0583.Delete-Operation-for-Two-Strings/</guid><description>583. Delete Operation for Two Strings # 题目 # Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.
In one step, you can delete exactly one character in either string.
Example 1:
Input: word1 = &amp;quot;sea&amp;quot;, word2 = &amp;quot;eat&amp;quot; Output: 2 Explanation: You need one step to make &amp;quot;sea&amp;quot; to &amp;quot;ea&amp;quot; and another step to make &amp;quot;eat&amp;quot; to &amp;quot;ea&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0589.N-ary-Tree-Preorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0589.N-ary-Tree-Preorder-Traversal/</guid><description>589. N-ary Tree Preorder Traversal # 题目 # Given the root of an n-ary tree, return the preorder traversal of its nodes&amp;rsquo; values.
Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)
Example 1:
Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] Example 2:
Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [1,2,3,6,7,11,14,4,8,12,5,9,13,10] Constraints:
The number of nodes in the tree is in the range [0, 104].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0594.Longest-Harmonious-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0594.Longest-Harmonious-Subsequence/</guid><description>594. Longest Harmonious Subsequence # 题目 # We define a harmounious array as an array where the difference between its maximum value and its minimum value is exactly 1.
Now, given an integer array, you need to find the length of its longest harmonious subsequence among all its possible subsequences.
Example 1:
Input: [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3]. Note: The length of the input array will not exceed 20,000.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0598.Range-Addition-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0598.Range-Addition-II/</guid><description>598. Range Addition II # 题目 # Given an m * n matrix M initialized with all 0&amp;rsquo;s and several update operations.
Operations are represented by a 2D array, and each operation is represented by an array with two positive integers a and b, which means M[i][j] should be added by one for all 0 &amp;lt;= i &amp;lt; a and 0 &amp;lt;= j &amp;lt; b.
You need to count and return the number of maximum integers in the matrix after performing all the operations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0599.Minimum-Index-Sum-of-Two-Lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0500~0599/0599.Minimum-Index-Sum-of-Two-Lists/</guid><description>599. Minimum Index Sum of Two Lists # 题目 # Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.
You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0605.Can-Place-Flowers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0605.Can-Place-Flowers/</guid><description>605. Can Place Flowers # 题目 # You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.
Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0609.Find-Duplicate-File-in-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0609.Find-Duplicate-File-in-System/</guid><description>609. Find Duplicate File in System # 题目 # Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.
A group of duplicate files consists of at least two files that have the same content.
A single directory info string in the input list has the following format:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0611.Valid-Triangle-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0611.Valid-Triangle-Number/</guid><description>611. Valid Triangle Number # 题目 # Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.
题目大意 # 给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。
解题思路 # 题意很简单，最容易想到的暴力解法是三重循环，暴力枚举，时间复杂度 O(n^3)。三重循环中最内层的循环可以优化，因为 k 和 i，j 存在关联性。第二层循环 j 从 i + 1 开始循环，k 从 j + 1 = i + 2 开始循环。循环累加 k 的值，直到 nums[i] + nums[j] &amp;gt; nums[k]，那么 [nums[j + 1], nums[k - 1]] 这个区间内的值都满足条件。满足条件的解个数增加 k - j - 1 个。j 再次递增 + 1，此时最内层的 k 不用从 j + 1 开始增加，只用从上次 k 开始增加即可。因为如果 nums[i] + nums[j] &amp;gt; nums[k]，如果这个 nums[i] + nums[j + 1] &amp;gt; nums[m + 1] 不等式成立，那么 m 一定不小于 k。所以内层循环 k 和 j 加起来的时间复杂度是 O(n)，最外层 i 的循环是 O(n)，这样优化以后，整体时间复杂度是 O(n^2)。 可能有读者有疑问，三角形三条边的组成条件：任意两边之和大于第三边。a + b &amp;gt; c，a + c &amp;gt; b，b + c &amp;gt; a，此处为什么只判断了 a + b &amp;gt; c 呢？因为一开始进行了排序处理，使得 a ≤ b ≤ c，在这个前提下，a + c &amp;gt; b，b + c &amp;gt; a 是一定成立的。所以原问题便转化为只需关心 a + b &amp;gt; c 这一个不等式是否成立即可。此题的测试用例用有一种特殊情况，那就是其中一条边或者两条边长度为 0，那么 a + b &amp;gt; c 这个不等式一定不成立。综上，先排序预处理之后，只需要关心 a + b &amp;gt; c 这一个不等式是否成立即可。 代码 # package leetcode import &amp;#34;sort&amp;#34; func triangleNumber(nums []int) int { res := 0 sort.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0617.Merge-Two-Binary-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0617.Merge-Two-Binary-Trees/</guid><description>617. Merge Two Binary Trees # 题目 # You are given two binary trees root1 and root2.
Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0622.Design-Circular-Queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0622.Design-Circular-Queue/</guid><description>622. Design Circular Queue # 题目 # Design your implementation of the circular queue. The circular queue is a linear data structure in which the operations are performed based on FIFO (First In First Out) principle and the last position is connected back to the first position to make a circle. It is also called &amp;ldquo;Ring Buffer&amp;rdquo;.
One of the benefits of the circular queue is that we can make use of the spaces in front of the queue.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0623.Add-One-Row-to-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0623.Add-One-Row-to-Tree/</guid><description>623. Add One Row to Tree # 题目 # Given the root of a binary tree, then value v and depth d, you need to add a row of nodes with value v at the given depth d. The root node is at depth 1.
The adding rule is: given a positive integer depth d, for each NOT null tree nodes N in depth d-1, create two tree nodes with value v as N's left subtree root and right subtree root.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0628.Maximum-Product-of-Three-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0628.Maximum-Product-of-Three-Numbers/</guid><description>628. Maximum Product of Three Numbers # 题目 # Given an integer array, find three numbers whose product is maximum and output the maximum product.
Example 1:
Input: [1,2,3] Output: 6 Example 2:
Input: [1,2,3,4] Output: 24 Note:
The length of the given array will be in range [3,10^4] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won&amp;rsquo;t exceed the range of 32-bit signed integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0630.Course-Schedule-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0630.Course-Schedule-III/</guid><description>630. Course Schedule III # 题目 # There are n different online courses numbered from 1 to n. You are given an array courses where courses[i] = [durationi, lastDayi] indicate that the ith course should be taken continuously for durationi days and must be finished before or on lastDayi.
You will start on the 1st day and you cannot take two or more courses simultaneously.
Return the maximum number of courses that you can take.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0632.Smallest-Range-Covering-Elements-from-K-Lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0632.Smallest-Range-Covering-Elements-from-K-Lists/</guid><description>632. Smallest Range Covering Elements from K Lists # 题目 # You have k lists of sorted integers in ascending order. Find the smallest range that includes at least one number from each of the k lists.
We define the range [a,b] is smaller than range [c,d] if b-a &amp;lt; d-c or a &amp;lt; c if b-a == d-c.
Example 1:
Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]] Output: [20,24] Explanation: List 1: [4, 10, 15, 24,26], 24 is in range [20,24].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0633.Sum-of-Square-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0633.Sum-of-Square-Numbers/</guid><description>633. Sum of Square Numbers # 题目 # Given a non-negative integer c, your task is to decide whether there&amp;rsquo;re two integers a and b such that a^2 + b^2 = c.
Example 1:
Input: 5 Output: True Explanation: 1 * 1 + 2 * 2 = 5 Example 2:
Input: 3 Output: False 题目大意 # 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0636.Exclusive-Time-of-Functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0636.Exclusive-Time-of-Functions/</guid><description>636. Exclusive Time of Functions # 题目 # On a single threaded CPU, we execute some functions. Each function has a unique id between 0 and N-1.
We store logs in timestamp order that describe when a function is entered or exited.
Each log is a string with this format: &amp;quot;{function_id}:{&amp;quot;start&amp;quot; | &amp;quot;end&amp;quot;}:{timestamp}&amp;quot;. For example, &amp;quot;0:start:3&amp;quot; means the function with id 0 started at the beginning of timestamp 3.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0637.Average-of-Levels-in-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0637.Average-of-Levels-in-Binary-Tree/</guid><description>637. Average of Levels in Binary Tree # 题目 # Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.
Example 1:
Input: 3 / \ 9 20 / \ 15 7 Output: [3, 14.5, 11] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0638.Shopping-Offers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0638.Shopping-Offers/</guid><description>638. Shopping Offers # 题目 # In LeetCode Store, there are some kinds of items to sell. Each item has a price.
However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.
You are given the each item&amp;rsquo;s price, a set of special offers, and the number we need to buy for each item. The job is to output the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0643.Maximum-Average-Subarray-I/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0643.Maximum-Average-Subarray-I/</guid><description>643. Maximum Average Subarray I # 题目 # Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value.
Example 1:
Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Note:
1 &amp;lt;= k &amp;lt;= n &amp;lt;= 30,000. Elements of the given array will be in the range [-10,000, 10,000].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0645.Set-Mismatch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0645.Set-Mismatch/</guid><description>645. Set Mismatch # 题目 # The set S originally contains numbers from 1 to n. But unfortunately, due to the data error, one of the numbers in the set got duplicated to another number in the set, which results in repetition of one number and loss of another number.
Given an array nums representing the data status of this set after the error. Your task is to firstly find the number occurs twice and then find the number that is missing.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0647.Palindromic-Substrings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0647.Palindromic-Substrings/</guid><description>647. Palindromic Substrings # 题目 # Given a string, your task is to count how many palindromic substrings in this string.
The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
Example 1:
Input: &amp;quot;abc&amp;quot; Output: 3 Explanation: Three palindromic strings: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;. Example 2:
Input: &amp;quot;aaa&amp;quot; Output: 6 Explanation: Six palindromic strings: &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0648.Replace-Words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0648.Replace-Words/</guid><description>648. Replace Words # 题目 # In English, we have a concept called root, which can be followed by some other words to form another longer word - let&amp;rsquo;s call this word successor. For example, the root an, followed by other, which can form another word another.
Now, given a dictionary consisting of many roots and a sentence. You need to replace all the successor in the sentence with the root forming it.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0653.Two-Sum-IV-Input-is-a-BST/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0653.Two-Sum-IV-Input-is-a-BST/</guid><description>653. Two Sum IV - Input is a BST # 题目 # Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.
Example 1:
Input: 5 / \ 3 6 / \ \ 2 4 7 Target = 9 Output: True Example 2:
Input: 5 / \ 3 6 / \ \ 2 4 7 Target = 28 Output: False 题目大意 # 给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0658.Find-K-Closest-Elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0658.Find-K-Closest-Elements/</guid><description>658. Find K Closest Elements # 题目 # Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.
Example 1:
Input: [1,2,3,4,5], k=4, x=3 Output: [1,2,3,4] Example 2:
Input: [1,2,3,4,5], k=4, x=-1 Output: [1,2,3,4] Note:
The value k is positive and will always be smaller than the length of the sorted array.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0661.Image-Smoother/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0661.Image-Smoother/</guid><description>661. Image Smoother # 题目 # Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.
Example 1:
Input: [[1,1,1], [1,0,1], [1,1,1]] Output: [[0, 0, 0], [0, 0, 0], [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0662.Maximum-Width-of-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0662.Maximum-Width-of-Binary-Tree/</guid><description>662. Maximum Width of Binary Tree # 题目 # Given a binary tree, write a function to get the maximum width of the given tree. The width of a tree is the maximum width among all levels. The binary tree has the same structure as a full binary tree, but some nodes are null.
The width of one level is defined as the length between the end-nodes (the leftmost and right most non-null nodes in the level, where the null nodes between the end-nodes are also counted into the length calculation.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0665.Non-decreasing-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0665.Non-decreasing-Array/</guid><description>665. Non-decreasing Array # 题目 # Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most one element.
We define an array is non-decreasing if nums[i] &amp;lt;= nums[i + 1] holds for every i (0-based) such that (0 &amp;lt;= i &amp;lt;= n - 2).
Example 1:
Input: nums = [4,2,3] Output: true Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0667.Beautiful-Arrangement-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0667.Beautiful-Arrangement-II/</guid><description>667. Beautiful Arrangement II # 题目 # Given two integers n and k, you need to construct a list which contains n different positive integers ranging from 1 to n and obeys the following requirement:Suppose this list is [a1, a2, a3, &amp;hellip; , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, &amp;hellip; , |an-1 - an|] has exactly k distinct integers.
If there are multiple answers, print any of them.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0668.Kth-Smallest-Number-in-Multiplication-Table/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0668.Kth-Smallest-Number-in-Multiplication-Table/</guid><description>668. Kth Smallest Number in Multiplication Table # 题目 # Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?
Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.
Example 1:
Input: m = 3, n = 3, k = 5 Output: Explanation: The Multiplication Table: 1 2 3 2 4 6 3 6 9 The 5-th smallest number is 3 (1, 2, 2, 3, 3).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0669.Trim-a-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0669.Trim-a-Binary-Search-Tree/</guid><description>669. Trim a Binary Search Tree # 题目 # Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&amp;rsquo;s descendant should remain a descendant). It can be proven that there is a unique answer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0674.Longest-Continuous-Increasing-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0674.Longest-Continuous-Increasing-Subsequence/</guid><description>674. Longest Continuous Increasing Subsequence # 题目 # Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.
A continuous increasing subsequence is defined by two indices l and r (l &amp;lt; r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l &amp;lt;= i &amp;lt; r, nums[i] &amp;lt; nums[i + 1].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0676.Implement-Magic-Dictionary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0676.Implement-Magic-Dictionary/</guid><description>676. Implement Magic Dictionary # 题目 # Implement a magic directory with buildDict, and search methods.
For the method buildDict, you&amp;rsquo;ll be given a list of non-repetitive words to build a dictionary.
For the method search, you&amp;rsquo;ll be given a word, and judge whether if you modify exactly one character into anothercharacter in this word, the modified word is in the dictionary you just built.
Example 1:
Input: buildDict([&amp;quot;hello&amp;quot;, &amp;quot;leetcode&amp;quot;]), Output: Null Input: search(&amp;quot;hello&amp;quot;), Output: False Input: search(&amp;quot;hhllo&amp;quot;), Output: True Input: search(&amp;quot;hell&amp;quot;), Output: False Input: search(&amp;quot;leetcoded&amp;quot;), Output: False Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0677.Map-Sum-Pairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0677.Map-Sum-Pairs/</guid><description>677. Map Sum Pairs # 题目 # Design a map that allows you to do the following:
Maps a string key to a given value. Returns the sum of the values that have a key with a prefix equal to a given string. Implement the MapSum class:
MapSum() Initializes the MapSum object. void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0682.Baseball-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0682.Baseball-Game/</guid><description>682. Baseball Game # 题目 # You&amp;rsquo;re now a baseball game point recorder.
Given a list of strings, each string can be one of the 4 following types:
Integer (one round&amp;rsquo;s score): Directly represents the number of points you get in this round. &amp;ldquo;+&amp;rdquo; (one round&amp;rsquo;s score): Represents that the points you get in this round are the sum of the last two valid round&amp;rsquo;s points. &amp;ldquo;D&amp;rdquo; (one round&amp;rsquo;s score): Represents that the points you get in this round are the doubled data of the last valid round&amp;rsquo;s points.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0684.Redundant-Connection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0684.Redundant-Connection/</guid><description>684. Redundant Connection # 题目 # In this problem, a tree is an undirected graph that is connected and has no cycles.
The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, &amp;hellip;, N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0685.Redundant-Connection-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0685.Redundant-Connection-II/</guid><description>685. Redundant Connection II # 题目 # In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.
The given input is a directed graph that started as a rooted tree with N nodes (with distinct values 1, 2, &amp;hellip;, N), with one additional directed edge added.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0690.Employee-Importance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0690.Employee-Importance/</guid><description>690. Employee Importance # 题目 # You are given a data structure of employee information, which includes the employee&amp;rsquo;s unique id, their importance value and their direct subordinates&amp;rsquo; id.
For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0692.Top-K-Frequent-Words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0692.Top-K-Frequent-Words/</guid><description>692. Top K Frequent Words # 题目 # Given a non-empty list of words, return the k most frequent elements.
Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.
Example 1:
Input: [&amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;leetcode&amp;quot;, &amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;, &amp;quot;coding&amp;quot;], k = 2 Output: [&amp;quot;i&amp;quot;, &amp;quot;love&amp;quot;] Explanation: &amp;quot;i&amp;quot; and &amp;quot;love&amp;quot; are the two most frequent words.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0693.Binary-Number-with-Alternating-Bits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0693.Binary-Number-with-Alternating-Bits/</guid><description>693. Binary Number with Alternating Bits # 题目 # Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.
Example 1:
Input: 5 Output: True Explanation: The binary representation of 5 is: 101 Example 2:
Input: 7 Output: False Explanation: The binary representation of 7 is: 111. Example 3:
Input: 11 Output: False Explanation: The binary representation of 11 is: 1011.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0695.Max-Area-of-Island/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0695.Max-Area-of-Island/</guid><description>695. Max Area of Island # 题目 # Given a non-empty 2D array grid of 0&amp;rsquo;s and 1&amp;rsquo;s, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.
Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0696.Count-Binary-Substrings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0696.Count-Binary-Substrings/</guid><description>696. Count Binary Substrings # 题目 # Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0&amp;rsquo;s and 1&amp;rsquo;s, and all the 0&amp;rsquo;s and all the 1&amp;rsquo;s in these substrings are grouped consecutively.
Substrings that occur multiple times are counted the number of times they occur.
Example 1:
Input: &amp;quot;00110011&amp;quot; Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: &amp;quot;0011&amp;quot;, &amp;quot;01&amp;quot;, &amp;quot;1100&amp;quot;, &amp;quot;10&amp;quot;, &amp;quot;0011&amp;quot;, and &amp;quot;01&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0697.Degree-of-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0697.Degree-of-an-Array/</guid><description>697. Degree of an Array # 题目 # Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.
Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.
Example 1:
Input: [1, 2, 2, 3, 1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0699.Falling-Squares/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0600~0699/0699.Falling-Squares/</guid><description>699. Falling Squares # 题目 # On an infinite number line (x-axis), we drop given squares in the order they are given.
The i-th square dropped (positions[i] = (left, side_length)) is a square with the left-most point being positions[i][0] and sidelength positions[i][1].
The square is dropped with the bottom edge parallel to the number line, and from a higher height than all currently landed squares. We wait for each square to stick before dropping the next.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0700.Search-in-a-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0700.Search-in-a-Binary-Search-Tree/</guid><description>700. Search in a Binary Search Tree # 题目 # You are given the root of a binary search tree (BST) and an integer val.
Find the node in the BST that the node&amp;rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.
Example 1:
Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0701.Insert-into-a-Binary-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0701.Insert-into-a-Binary-Search-Tree/</guid><description>701. Insert into a Binary Search Tree # 题目 # You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.
Notice that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0703.Kth-Largest-Element-in-a-Stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0703.Kth-Largest-Element-in-a-Stream/</guid><description>703. Kth Largest Element in a Stream # 题目 # Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
Implement KthLargest class:
KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Returns the element representing the kth largest element in the stream.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0704.Binary-Search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0704.Binary-Search/</guid><description>704. Binary Search # 题目 # Given a sorted (in ascending order) integer array nums of n elements and a target value, write a function to search target in nums. If target exists, then return its index, otherwise return -1.
Example 1:
Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2:
Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0705.Design-HashSet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0705.Design-HashSet/</guid><description>705. Design HashSet # 题目 # Design a HashSet without using any built-in hash table libraries.
To be specific, your design should include these functions:
add(value): Insert a value into the HashSet. contains(value) : Return whether the value exists in the HashSet or not. remove(value): Remove a value in the HashSet. If the value does not exist in the HashSet, do nothing. Example:
MyHashSet hashSet = new MyHashSet(); hashSet.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0706.Design-HashMap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0706.Design-HashMap/</guid><description>706. Design HashMap # 题目 # Design a HashMap without using any built-in hash table libraries.
To be specific, your design should include these functions:
put(key, value) : Insert a (key, value) pair into the HashMap. If the value already exists in the HashMap, update the value. get(key): Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0707.Design-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0707.Design-Linked-List/</guid><description>707. Design Linked List # 题目 # Design your implementation of the linked list. You can choose to use the singly linked list or the doubly linked list. A node in a singly linked list should have two attributes: val and next. val is the value of the current node, and next is a pointer/reference to the next node. If you want to use the doubly linked list, you will need one more attribute prev to indicate the previous node in the linked list.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0709.To-Lower-Case/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0709.To-Lower-Case/</guid><description>709. To Lower Case # 题目 # Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.
Example 1:
Input: s = &amp;quot;Hello&amp;quot; Output: &amp;quot;hello&amp;quot; Example 2:
Input: s = &amp;quot;here&amp;quot; Output: &amp;quot;here&amp;quot; Example 3:
Input: s = &amp;quot;LOVELY&amp;quot; Output: &amp;quot;lovely&amp;quot; Constraints:
1 &amp;lt;= s.length &amp;lt;= 100 s consists of printable ASCII characters. 题目大意 # 给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0710.Random-Pick-with-Blacklist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0710.Random-Pick-with-Blacklist/</guid><description>710. Random Pick with Blacklist # 题目 # Given a blacklist B containing unique integers from [0, N), write a function to return a uniform random integer from [0, N) which is NOT in B.
Optimize it such that it minimizes the call to system’s Math.random().
Note:
1 &amp;lt;= N &amp;lt;= 1000000000 0 &amp;lt;= B.length &amp;lt; min(100000, N) [0, N) does NOT include N. See interval notation. Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0713.Subarray-Product-Less-Than-K/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0713.Subarray-Product-Less-Than-K/</guid><description>713. Subarray Product Less Than K # 题目 # Your are given an array of positive integers nums.
Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.
Example 1:
Input: nums = [10, 5, 2, 6], k = 100 Output: 8 Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0714.Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee/</guid><description>714. Best Time to Buy and Sell Stock with Transaction Fee # 题目 # Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.
You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0715.Range-Module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0715.Range-Module/</guid><description>715. Range Module # 题目 # A Range Module is a module that tracks ranges of numbers. Your task is to design and implement the following interfaces in an efficient manner.
addRange(int left, int right) Adds the half-open interval [left, right), tracking every real number in that interval. Adding an interval that partially overlaps with currently tracked numbers should add any numbers in the interval [left, right) that are not already tracked.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0717.1-bit-and-2-bit-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0717.1-bit-and-2-bit-Characters/</guid><description>717. 1-bit and 2-bit Characters # 题目: # We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).
Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.
Example 1:
Input: bits = [1, 0, 0] Output: True Explanation: The only way to decode it is two-bit character and one-bit character.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0718.Maximum-Length-of-Repeated-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0718.Maximum-Length-of-Repeated-Subarray/</guid><description>718. Maximum Length of Repeated Subarray # 题目 # Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.
Example 1:
Input: A: [1,2,3,2,1] B: [3,2,1,4,7] Output: 3 Explanation: The repeated subarray with maximum length is [3, 2, 1]. Note:
1 &amp;lt;= len(A), len(B) &amp;lt;= 1000 0 &amp;lt;= A[i], B[i] &amp;lt; 100 题目大意 # 给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0719.Find-K-th-Smallest-Pair-Distance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0719.Find-K-th-Smallest-Pair-Distance/</guid><description>719. Find K-th Smallest Pair Distance # 题目 # Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.
Example 1:
Input: nums = [1,3,1] k = 1 Output: 0 Explanation: Here are all the pairs: (1,3) -&amp;gt; 2 (1,1) -&amp;gt; 0 (3,1) -&amp;gt; 2 Then the 1st smallest distance pair is (1,1), and its distance is 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0720.Longest-Word-in-Dictionary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0720.Longest-Word-in-Dictionary/</guid><description>720. Longest Word in Dictionary # 题目 # Given a list of strings words representing an English Dictionary, find the longest word in words that can be built one character at a time by other words in words. If there is more than one possible answer, return the longest word with the smallest lexicographical order.
If there is no answer, return the empty string.
Example 1:
Input: words = [&amp;quot;w&amp;quot;,&amp;quot;wo&amp;quot;,&amp;quot;wor&amp;quot;,&amp;quot;worl&amp;quot;, &amp;quot;world&amp;quot;] Output: &amp;quot;world&amp;quot; Explanation: The word &amp;quot;world&amp;quot; can be built one character at a time by &amp;quot;w&amp;quot;, &amp;quot;wo&amp;quot;, &amp;quot;wor&amp;quot;, and &amp;quot;worl&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0721.Accounts-Merge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0721.Accounts-Merge/</guid><description>721. Accounts Merge # 题目 # Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emailsrepresenting emails of the account.
Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0724.Find-Pivot-Index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0724.Find-Pivot-Index/</guid><description>724. Find Pivot Index # 题目 # Given an array of integers nums, write a method that returns the &amp;ldquo;pivot&amp;rdquo; index of this array.
We define the pivot index as the index where the sum of all the numbers to the left of the index is equal to the sum of all the numbers to the right of the index.
If no such index exists, we should return -1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0725.Split-Linked-List-in-Parts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0725.Split-Linked-List-in-Parts/</guid><description>725. Split Linked List in Parts # 题目 # Given a (singly) linked list with head node root, write a function to split the linked list into k consecutive linked list &amp;ldquo;parts&amp;rdquo;.
The length of each part should be as equal as possible: no two parts should have a size differing by more than 1. This may lead to some parts being null.
The parts should be in order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal parts occurring later.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0726.Number-of-Atoms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0726.Number-of-Atoms/</guid><description>726. Number of Atoms # 题目 # Given a chemical formula (given as a string), return the count of each atom.
An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.
1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0728.Self-Dividing-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0728.Self-Dividing-Numbers/</guid><description>728. Self Dividing Numbers # 题目 # A self-dividing number is a number that is divisible by every digit it contains.
For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. A self-dividing number is not allowed to contain the digit zero.
Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0729.My-Calendar-I/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0729.My-Calendar-I/</guid><description>729. My Calendar I # 题目 # Implement a MyCalendar class to store your events. A new event can be added if adding the event will not cause a double booking.
Your class will have the method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &amp;lt;= x &amp;lt; end.
A double booking happens when two events have some non-empty intersection (ie.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0732.My-Calendar-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0732.My-Calendar-III/</guid><description>732. My Calendar III # 题目 # Implement a MyCalendarThree class to store your events. A new event can always be added.
Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &amp;lt;= x &amp;lt; end.
A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0733.Flood-Fill/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0733.Flood-Fill/</guid><description>733. Flood Fill # 题目 # An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).
Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, &amp;ldquo;flood fill&amp;rdquo; the image.
To perform a &amp;ldquo;flood fill&amp;rdquo;, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0735.Asteroid-Collision/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0735.Asteroid-Collision/</guid><description>735. Asteroid Collision # 题目 # We are given an array asteroids of integers representing asteroids in a row.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0739.Daily-Temperatures/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0739.Daily-Temperatures/</guid><description>739. Daily Temperatures # 题目 # Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.
For example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0744.Find-Smallest-Letter-Greater-Than-Target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0744.Find-Smallest-Letter-Greater-Than-Target/</guid><description>744. Find Smallest Letter Greater Than Target # 题目 # Given a list of sorted characters letters containing only lowercase letters, and given a target letter target, find the smallest element in the list that is larger than the given target.
Letters also wrap around. For example, if the target is target = 'z' and letters = ['a', 'b'], the answer is 'a'.
Examples:
Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;a&amp;quot; Output: &amp;quot;c&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;c&amp;quot; Output: &amp;quot;f&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;d&amp;quot; Output: &amp;quot;f&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;g&amp;quot; Output: &amp;quot;j&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;j&amp;quot; Output: &amp;quot;c&amp;quot; Input: letters = [&amp;quot;c&amp;quot;, &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;] target = &amp;quot;k&amp;quot; Output: &amp;quot;c&amp;quot; Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0745.Prefix-and-Suffix-Search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0745.Prefix-and-Suffix-Search/</guid><description>745. Prefix and Suffix Search # 题目 # Given many words, words[i] has weight i.
Design a class WordFilter that supports one function, WordFilter.f(String prefix, String suffix). It will return the word with given prefix and suffix with maximum weight. If no word exists, return -1.
Examples:
Input: WordFilter([&amp;quot;apple&amp;quot;]) WordFilter.f(&amp;quot;a&amp;quot;, &amp;quot;e&amp;quot;) // returns 0 WordFilter.f(&amp;quot;b&amp;quot;, &amp;quot;&amp;quot;) // returns -1 Note:
words has length in range [1, 15000].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0746.Min-Cost-Climbing-Stairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0746.Min-Cost-Climbing-Stairs/</guid><description>746. Min Cost Climbing Stairs # 题目 # On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).
Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.
Example 1:
Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0747.Largest-Number-At-Least-Twice-of-Others/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0747.Largest-Number-At-Least-Twice-of-Others/</guid><description>747. Largest Number At Least Twice of Others # 题目 # You are given an integer array nums where the largest integer is unique.
Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.
Example 1:
Input: nums = [3,6,1,0] Output: 1 Explanation: 6 is the largest integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0748.Shortest-Completing-Word/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0748.Shortest-Completing-Word/</guid><description>748. Shortest Completing Word # 题目 # Find the minimum length word from a given dictionary words, which has all the letters from the string licensePlate. Such a word is said to complete the given string licensePlate
Here, for letters we ignore case. For example, &amp;quot;P&amp;quot; on the licensePlate still matches &amp;quot;p&amp;quot; on the word.
It is guaranteed an answer exists. If there are multiple answers, return the one that occurs first in the array.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0752.Open-the-Lock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0752.Open-the-Lock/</guid><description>752. Open the Lock # 题目 # You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'. The wheels can rotate freely and wrap around: for example we can turn '9' to be '0', or '0' to be '9'. Each move consists of turning one wheel one slot.
The lock initially starts at '0000', a string representing the state of the 4 wheels.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0753.Cracking-the-Safe/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0753.Cracking-the-Safe/</guid><description>753. Cracking the Safe # 题目 # There is a box protected by a password. The password is a sequence of n digits where each digit can be one of the first k digits 0, 1, ..., k-1.
While entering a password, the last n digits entered will automatically be matched against the correct password.
For example, assuming the correct password is &amp;quot;345&amp;quot;, if you type &amp;quot;012345&amp;quot;, the box will open because the correct password matches the suffix of the entered password.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0756.Pyramid-Transition-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0756.Pyramid-Transition-Matrix/</guid><description>756. Pyramid Transition Matrix # 题目 # We are stacking blocks to form a pyramid. Each block has a color which is a one letter string.
We are allowed to place any color block C on top of two adjacent blocks of colors A and B, if and only if ABC is an allowed triple.
We start with a bottom row of bottom, represented as a single string. We also start with a list of allowed triples allowed.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0762.Prime-Number-of-Set-Bits-in-Binary-Representation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0762.Prime-Number-of-Set-Bits-in-Binary-Representation/</guid><description>762. Prime Number of Set Bits in Binary Representation # 题目 # Given two integers L and R, find the count of numbers in the range [L, R] (inclusive) having a prime number of set bits in their binary representation.
(Recall that the number of set bits an integer has is the number of 1s present when written in binary. For example, 21 written in binary is 10101 which has 3 set bits.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0763.Partition-Labels/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0763.Partition-Labels/</guid><description>763. Partition Labels # 题目 # A string S of lowercase letters is given. We want to partition this string into as many parts as possible so that each letter appears in at most one part, and return a list of integers representing the size of these parts.
Example 1:
Input: S = &amp;quot;ababcbacadefegdehijhklij&amp;quot; Output: [9,7,8] Explanation: The partition is &amp;quot;ababcbaca&amp;quot;, &amp;quot;defegde&amp;quot;, &amp;quot;hijhklij&amp;quot;. This is a partition so that each letter appears in at most one part.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0765.Couples-Holding-Hands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0765.Couples-Holding-Hands/</guid><description>765. Couples Holding Hands # 题目 # N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.
The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0766.Toeplitz-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0766.Toeplitz-Matrix/</guid><description>766. Toeplitz Matrix # 题目 # A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.
Now given an M x N matrix, return True if and only if the matrix is Toeplitz.
Example 1:
Input: matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2] ] Output: True Explanation: In the above grid, the diagonals are: &amp;quot;[9]&amp;quot;, &amp;quot;[5, 5]&amp;quot;, &amp;quot;[1, 1, 1]&amp;quot;, &amp;quot;[2, 2, 2]&amp;quot;, &amp;quot;[3, 3]&amp;quot;, &amp;quot;[4]&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0767.Reorganize-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0767.Reorganize-String/</guid><description>767. Reorganize String # 题目 # Given a string S, check if the letters can be rearranged so that two characters that are adjacent to each other are not the same.
If possible, output any possible result. If not possible, return the empty string.
Example 1:
Input: S = &amp;quot;aab&amp;quot; Output: &amp;quot;aba&amp;quot; Example 2:
Input: S = &amp;quot;aaab&amp;quot; Output: &amp;quot;&amp;quot; Note:
S will consist of lowercase letters and have length in range [1, 500].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0771.Jewels-and-Stones/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0771.Jewels-and-Stones/</guid><description>771. Jewels and Stones # 题目 # You&amp;rsquo;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels.
The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &amp;quot;a&amp;quot; is considered a different type of stone from &amp;quot;A&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0775.Global-and-Local-Inversions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0775.Global-and-Local-Inversions/</guid><description>775. Global and Local Inversions # 题目 # We have some permutation A of [0, 1, ..., N - 1], where N is the length of A.
The number of (global) inversions is the number of i &amp;lt; j with 0 &amp;lt;= i &amp;lt; j &amp;lt; N and A[i] &amp;gt; A[j].
The number of local inversions is the number of i with 0 &amp;lt;= i &amp;lt; N and A[i] &amp;gt; A[i+1].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0778.Swim-in-Rising-Water/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0778.Swim-in-Rising-Water/</guid><description>778. Swim in Rising Water # 题目 # On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).
Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0781.Rabbits-in-Forest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0781.Rabbits-in-Forest/</guid><description>781. Rabbits in Forest # 题目 # In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those answers are placed in an array.
Return the minimum number of rabbits that could be in the forest.
Examples:
Input: answers = [1, 1, 2] Output: 5 Explanation: The two rabbits that answered &amp;quot;1&amp;quot; could both be the same color, say red.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0783.Minimum-Distance-Between-BST-Nodes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0783.Minimum-Distance-Between-BST-Nodes/</guid><description>783. Minimum Distance Between BST Nodes # 题目 # Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.
Note: This question is the same as 530: https://leetcode.com/problems/minimum-absolute-difference-in-bst/
Example 1:
Input: root = [4,2,6,1,3] Output: 1 Example 2:
Input: root = [1,0,48,null,null,12,49] Output: 1 Constraints:
The number of nodes in the tree is in the range [2, 100].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0784.Letter-Case-Permutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0784.Letter-Case-Permutation/</guid><description>784. Letter Case Permutation # 题目 # Given a string S, we can transform every letter individually to be lowercase or uppercase to create another string. Return a list of all possible strings we could create.
Examples:
Input: S = &amp;quot;a1b2&amp;quot; Output: [&amp;quot;a1b2&amp;quot;, &amp;quot;a1B2&amp;quot;, &amp;quot;A1b2&amp;quot;, &amp;quot;A1B2&amp;quot;] Input: S = &amp;quot;3z4&amp;quot; Output: [&amp;quot;3z4&amp;quot;, &amp;quot;3Z4&amp;quot;] Input: S = &amp;quot;12345&amp;quot; Output: [&amp;quot;12345&amp;quot;] Note:
S will be a string with length between 1 and 12.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0785.Is-Graph-Bipartite/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0785.Is-Graph-Bipartite/</guid><description>785. Is Graph Bipartite? # 题目 # Given an undirected graph, return true if and only if it is bipartite.
Recall that a graph is bipartite if we can split it&amp;rsquo;s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.
The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0786.K-th-Smallest-Prime-Fraction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0786.K-th-Smallest-Prime-Fraction/</guid><description>786. K-th Smallest Prime Fraction # 题目 # A sorted list A contains 1, plus some number of primes. Then, for every p &amp;lt; q in the list, we consider the fraction p/q.
What is the K-th smallest fraction considered? Return your answer as an array of ints, where answer[0] = p and answer[1] = q.
Examples:
Input: A = [1, 2, 3, 5], K = 3 Output: [2, 5] Explanation: The fractions to be considered in sorted order are: 1/5, 1/3, 2/5, 1/2, 3/5, 2/3.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0791.Custom-Sort-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0791.Custom-Sort-String/</guid><description>791. Custom Sort String # 题目 # order and str are strings composed of lowercase letters. In order, no letter occurs more than once.
order was sorted in some custom order previously. We want to permute the characters of str so that they match the order that order was sorted. More specifically, if x occurs before y in order, then x should occur before y in the returned string.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0792.Number-of-Matching-Subsequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0792.Number-of-Matching-Subsequences/</guid><description>792. Number of Matching Subsequences # 题目 # Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.
A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
For example, &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot;. Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0793.Preimage-Size-of-Factorial-Zeroes-Function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0793.Preimage-Size-of-Factorial-Zeroes-Function/</guid><description>793. Preimage Size of Factorial Zeroes Function # 题目 # Let f(x) be the number of zeroes at the end of x!. (Recall that x! = 1 * 2 * 3 * ... * x, and by convention, 0! = 1.)
For example, f(3) = 0 because 3! = 6 has no zeroes at the end, while f(11) = 2 because 11! = 39916800 has 2 zeroes at the end.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0794.Valid-Tic-Tac-Toe-State/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0794.Valid-Tic-Tac-Toe-State/</guid><description>794. Valid Tic-Tac-Toe State # 题目 # Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.
The board is a 3 x 3 array that consists of characters ' &amp;lsquo;, &amp;lsquo;X&amp;rsquo;, and &amp;lsquo;O&amp;rsquo;. The ' ' character represents an empty square.
Here are the rules of Tic-Tac-Toe:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0795.Number-of-Subarrays-with-Bounded-Maximum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0700~0799/0795.Number-of-Subarrays-with-Bounded-Maximum/</guid><description>795. Number of Subarrays with Bounded Maximum # 题目 # We are given an array nums of positive integers, and two positive integers left and right (left &amp;lt;= right).
Return the number of (contiguous, non-empty) subarrays such that the value of the maximum array element in that subarray is at least left and at most right.
Example:Input: nums = [2, 1, 4, 3] left = 2 right = 3 Output: 3 Explanation: There are three subarrays that meet the requirements: [2], [2, 1], [3].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0802.Find-Eventual-Safe-States/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0802.Find-Eventual-Safe-States/</guid><description>802. Find Eventual Safe States # 题目 # In a directed graph, we start at some node and every turn, walk along a directed edge of the graph. If we reach a node that is terminal (that is, it has no outgoing directed edges), we stop.
Now, say our starting node is eventually safe if and only if we must eventually walk to a terminal node. More specifically, there exists a natural number K so that for any choice of where to walk, we must have stopped at a terminal node in less than K steps.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0803.Bricks-Falling-When-Hit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0803.Bricks-Falling-When-Hit/</guid><description>803. Bricks Falling When Hit # 题目 # We have a grid of 1s and 0s; the 1s in a cell represent bricks. A brick will not drop if and only if it is directly connected to the top of the grid, or at least one of its (4-way) adjacent bricks will not drop.
We will do some erasures sequentially. Each time we want to do the erasure at the location (i, j), the brick (if it exists) on that location will disappear, and then some other bricks may drop because of that erasure.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0807.Max-Increase-to-Keep-City-Skyline/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0807.Max-Increase-to-Keep-City-Skyline/</guid><description>807. Max Increase to Keep City Skyline # 题目 # There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.
A city&amp;rsquo;s skyline is the the outer contour formed by all the building when viewing the side of the city from a distance.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0810.Chalkboard-XOR-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0810.Chalkboard-XOR-Game/</guid><description>810. Chalkboard XOR Game # 题目 # We are given non-negative integers nums[i] which are written on a chalkboard. Alice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. (Also, we&amp;rsquo;ll say the bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0811.Subdomain-Visit-Count/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0811.Subdomain-Visit-Count/</guid><description>811. Subdomain Visit Count # 题目 # A website domain like &amp;ldquo;discuss.leetcode.com&amp;rdquo; consists of various subdomains. At the top level, we have &amp;ldquo;com&amp;rdquo;, at the next level, we have &amp;ldquo;leetcode.com&amp;rdquo;, and at the lowest level, &amp;ldquo;discuss.leetcode.com&amp;rdquo;. When we visit a domain like &amp;ldquo;discuss.leetcode.com&amp;rdquo;, we will also visit the parent domains &amp;ldquo;leetcode.com&amp;rdquo; and &amp;ldquo;com&amp;rdquo; implicitly.
Now, call a &amp;ldquo;count-paired domain&amp;rdquo; to be a count (representing the number of visits this domain received), followed by a space, followed by the address.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0812.Largest-Triangle-Area/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0812.Largest-Triangle-Area/</guid><description>812. Largest Triangle Area # 题目 # You have a list of points in the plane. Return the area of the largest triangle that can be formed by any 3 of the points.
Example: Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2 Explanation: The five points are show in the figure below. The red triangle is the largest. Notes:
3 &amp;lt;= points.length &amp;lt;= 50. No points will be duplicated.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0815.Bus-Routes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0815.Bus-Routes/</guid><description>815. Bus Routes # 题目 # We have a list of bus routes. Each routes[i] is a bus route that the i-th bus repeats forever. For example if routes[0] = [1, 5, 7], this means that the first bus (0-th indexed) travels in the sequence 1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;5-&amp;gt;7-&amp;gt;1-&amp;gt;&amp;hellip; forever.
We start at bus stop S (initially not on a bus), and we want to go to bus stop T. Travelling by buses only, what is the least number of buses we must take to reach our destination?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0816.Ambiguous-Coordinates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0816.Ambiguous-Coordinates/</guid><description>816. Ambiguous Coordinates # 题目 # We had some 2-dimensional coordinates, like &amp;quot;(1, 3)&amp;quot; or &amp;quot;(2, 0.5)&amp;quot;. Then, we removed all commas, decimal points, and spaces, and ended up with the string s. Return a list of strings representing all possibilities for what our original coordinates could have been.
Our original representation never had extraneous zeroes, so we never started with numbers like &amp;ldquo;00&amp;rdquo;, &amp;ldquo;0.0&amp;rdquo;, &amp;ldquo;0.00&amp;rdquo;, &amp;ldquo;1.0&amp;rdquo;, &amp;ldquo;001&amp;rdquo;, &amp;ldquo;00.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0817.Linked-List-Components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0817.Linked-List-Components/</guid><description>817. Linked List Components # 题目 # We are given head, the head node of a linked list containing unique integer values.
We are also given the list G, a subset of the values in the linked list.
Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.
Example 1:
Input: head: 0-&amp;gt;1-&amp;gt;2-&amp;gt;3 G = [0, 1, 3] Output: 2 Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0819.Most-Common-Word/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0819.Most-Common-Word/</guid><description>819. Most Common Word # 题目 # Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn&amp;rsquo;t banned, and that the answer is unique.
Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0820.Short-Encoding-of-Words/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0820.Short-Encoding-of-Words/</guid><description>820. Short Encoding of Words # 题目 # A valid encoding of an array of words is any reference string s and array of indices indices such that:
words.length == indices.length The reference string s ends with the '#' character. For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i]. Given an array of words, return the length of the shortest reference string s possible of any valid encoding of words*.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0821.Shortest-Distance-to-a-Character/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0821.Shortest-Distance-to-a-Character/</guid><description>821. Shortest Distance to a Character # 题目 # Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the shortest distance from s[i] to the character c in s.
Example 1:
Input: s = &amp;quot;loveleetcode&amp;quot;, c = &amp;quot;e&amp;quot; Output: [3,2,1,0,1,0,0,1,2,2,1,0] Example 2:
Input: s = &amp;quot;aaab&amp;quot;, c = &amp;quot;b&amp;quot; Output: [3,2,1,0] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0823.Binary-Trees-With-Factors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0823.Binary-Trees-With-Factors/</guid><description>823. Binary Trees With Factors # 题目 # Given an array of unique integers, arr, where each integer arr[i] is strictly greater than 1.
We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node&amp;rsquo;s value should be equal to the product of the values of its children.
Return the number of binary trees we can make. The answer may be too large so return the answer modulo 109 + 7.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0825.Friends-Of-Appropriate-Ages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0825.Friends-Of-Appropriate-Ages/</guid><description>825. Friends Of Appropriate Ages # 题目 # There are n persons on a social media website. You are given an integer array ages where ages[i] is the age of the ith person.
A Person x will not send a friend request to a person y (x != y) if any of the following conditions is true:
age[y] &amp;lt;= 0.5 * age+ 7 age[y] &amp;gt; age[x] age[y] &amp;gt; 100 &amp;amp;&amp;amp; age&amp;lt; 100 Otherwise, x will send a friend request to y.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0826.Most-Profit-Assigning-Work/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0826.Most-Profit-Assigning-Work/</guid><description>826. Most Profit Assigning Work # 题目 # We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job.
Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i].
Every worker can be assigned at most one job, but one job can be completed multiple times.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0828.Count-Unique-Characters-of-All-Substrings-of-a-Given-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0828.Count-Unique-Characters-of-All-Substrings-of-a-Given-String/</guid><description>828. Count Unique Characters of All Substrings of a Given String # 题目 # Let&amp;rsquo;s define a function countUniqueChars(s) that returns the number of unique characters on s, for example if s = &amp;quot;LEETCODE&amp;quot; then &amp;quot;L&amp;quot;, &amp;quot;T&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;O&amp;quot;,&amp;quot;D&amp;quot; are the unique characters since they appear only once in s, therefore countUniqueChars(s) = 5.On this problem given a string s we need to return the sum of countUniqueChars(t) where t is a substring of s.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0830.Positions-of-Large-Groups/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0830.Positions-of-Large-Groups/</guid><description>830. Positions of Large Groups # 题目 # In a string s of lowercase letters, these letters form consecutive groups of the same character.
For example, a string like s = &amp;quot;abbxxxxzyy&amp;quot; has the groups &amp;quot;a&amp;quot;, &amp;quot;bb&amp;quot;, &amp;quot;xxxx&amp;quot;, &amp;quot;z&amp;quot;, and &amp;quot;yy&amp;quot;.
A group is identified by an interval [start, end], where start and end denote the start and end indices (inclusive) of the group. In the above example, &amp;quot;xxxx&amp;quot; has the interval [3,6].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0832.Flipping-an-Image/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0832.Flipping-an-Image/</guid><description>832. Flipping an Image # 题目 # Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image.
To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1].
To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0834.Sum-of-Distances-in-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0834.Sum-of-Distances-in-Tree/</guid><description>834. Sum of Distances in Tree # 题目 # An undirected, connected tree with N nodes labelled 0...N-1 and N-1edges are given.
The ith edge connects nodes edges[i][0] and edges[i][1] together.
Return a list ans, where ans[i] is the sum of the distances between node iand all other nodes.
Example 1:
Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]] Output: [8,12,6,10,10,10] Explanation: Here is a diagram of the given tree: 0 / \ 1 2 /|\ 3 4 5 We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) equals 1 + 1 + 2 + 2 + 2 = 8.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0836.Rectangle-Overlap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0836.Rectangle-Overlap/</guid><description>836. Rectangle Overlap # 题目 # A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner.
Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.
Given two (axis-aligned) rectangles, return whether they overlap.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0838.Push-Dominoes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0838.Push-Dominoes/</guid><description>838. Push Dominoes # 题目 # There are N dominoes in a line, and we place each domino vertically upright.
In the beginning, we simultaneously push some of the dominoes either to the left or to the right.
After each second, each domino that is falling to the left pushes the adjacent domino on the left.
Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0839.Similar-String-Groups/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0839.Similar-String-Groups/</guid><description>839. Similar String Groups # 题目 # Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y.
For example, &amp;quot;tars&amp;quot; and &amp;quot;rats&amp;quot; are similar (swapping at positions 0 and 2), and &amp;quot;rats&amp;quot; and &amp;quot;arts&amp;quot; are similar, but &amp;quot;star&amp;quot; is not similar to &amp;quot;tars&amp;quot;, &amp;quot;rats&amp;quot;, or &amp;quot;arts&amp;quot;.
Together, these form two connected groups by similarity: {&amp;quot;tars&amp;quot;, &amp;quot;rats&amp;quot;, &amp;quot;arts&amp;quot;} and {&amp;quot;star&amp;quot;}.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0841.Keys-and-Rooms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0841.Keys-and-Rooms/</guid><description>841. Keys and Rooms # 题目 # There are N rooms and you start in room 0. Each room has a distinct number in 0, 1, 2, ..., N-1, and each room may have some keys to access the next room.
Formally, each room i has a list of keys rooms[i], and each key rooms[i][j] is an integer in [0, 1, ..., N-1] where N = rooms.length. A key rooms[i][j] = v opens the room with number v.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0842.Split-Array-into-Fibonacci-Sequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0842.Split-Array-into-Fibonacci-Sequence/</guid><description>842. Split Array into Fibonacci Sequence # 题目 # Given a string S of digits, such as S = &amp;quot;123456579&amp;quot;, we can split it into a Fibonacci-like sequence [123, 456, 579].
Formally, a Fibonacci-like sequence is a list F of non-negative integers such that:
0 &amp;lt;= F[i] &amp;lt;= 2^31 - 1, (that is, each integer fits a 32-bit signed integer type); F.length &amp;gt;= 3; and F[i] + F[i+1] = F[i+2] for all 0 &amp;lt;= i &amp;lt; F.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0844.Backspace-String-Compare/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0844.Backspace-String-Compare/</guid><description>844. Backspace String Compare # 题目 # Given two strings S and T, return if they are equal when both are typed into empty text editors. # means a backspace character.
Example 1:
Input: S = &amp;quot;ab#c&amp;quot;, T = &amp;quot;ad#c&amp;quot; Output: true Explanation: Both S and T become &amp;quot;ac&amp;quot;. Example 2:
Input: S = &amp;quot;ab##&amp;quot;, T = &amp;quot;c#d#&amp;quot; Output: true Explanation: Both S and T become &amp;quot;&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0845.Longest-Mountain-in-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0845.Longest-Mountain-in-Array/</guid><description>845. Longest Mountain in Array # 题目 # Let&amp;rsquo;s call any (contiguous) subarray B (of A) a mountain if the following properties hold:
B.length &amp;gt;= 3 There exists some 0 &amp;lt; i &amp;lt; B.length - 1 such that B[0] &amp;lt; B[1] &amp;lt; &amp;hellip; B[i-1] &amp;lt; B[i] &amp;gt; B[i+1] &amp;gt; &amp;hellip; &amp;gt; B[B.length - 1] (Note that B could be any subarray of A, including the entire array A.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0846.Hand-of-Straights/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0846.Hand-of-Straights/</guid><description>846. Hand of Straights # 题目 # Alice has some number of cards and she wants to rearrange the cards into groups so that each group is of size groupSize, and consists of groupSize consecutive cards.
Given an integer array hand where hand[i] is the value written on the ith card and an integer groupSize, return true if she can rearrange the cards, or false otherwise.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0850.Rectangle-Area-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0850.Rectangle-Area-II/</guid><description>850. Rectangle Area II # 题目 # We are given a list of (axis-aligned) rectangles. Each rectangle[i] = [x1, y1, x2, y2] , where (x1, y1) are the coordinates of the bottom-left corner, and (x2, y2) are the coordinates of the top-right corner of the ith rectangle.
Find the total area covered by all rectangles in the plane. Since the answer may be too large, return it modulo 10^9 + 7.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0851.Loud-and-Rich/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0851.Loud-and-Rich/</guid><description>851. Loud and Rich # 题目 # In a group of N people (labelled 0, 1, 2, ..., N-1), each person has different amounts of money, and different levels of quietness.
For convenience, we&amp;rsquo;ll call the person with label x, simply &amp;ldquo;person x&amp;rdquo;.
We&amp;rsquo;ll say that richer[i] = [x, y] if person x definitely has more money than person y. Note that richer may only be a subset of valid observations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0852.Peak-Index-in-a-Mountain-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0852.Peak-Index-in-a-Mountain-Array/</guid><description>852. Peak Index in a Mountain Array # 题目 # Let&amp;rsquo;s call an array A a mountain if the following properties hold:
A.length &amp;gt;= 3 There exists some 0 &amp;lt; i &amp;lt; A.length - 1 such that A[0] &amp;lt; A[1] &amp;lt; ... A[i-1] &amp;lt; A[i] &amp;gt; A[i+1] &amp;gt; ... &amp;gt; A[A.length - 1] Given an array that is definitely a mountain, return any i such that A[0] &amp;lt; A[1] &amp;lt; .</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0853.Car-Fleet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0853.Car-Fleet/</guid><description>853. Car Fleet # 题目 # N cars are going to the same destination along a one lane road. The destination is target miles away.
Each car i has a constant speed speed[i] (in miles per hour), and initial position position[i] miles towards the target along the road.
A car can never pass another car ahead of it, but it can catch up to it, and drive bumper to bumper at the same speed.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0856.Score-of-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0856.Score-of-Parentheses/</guid><description>856. Score of Parentheses # 题目 # Given a balanced parentheses string S, compute the score of the string based on the following rule:
() has score 1 AB has score A + B, where A and B are balanced parentheses strings. (A) has score 2 * A, where A is a balanced parentheses string.
Example 1:
Input: &amp;quot;()&amp;quot; Output: 1 Example 2:
Input: &amp;quot;(())&amp;quot; Output: 2 Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0859.Buddy-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0859.Buddy-Strings/</guid><description>859. Buddy Strings # 题目 # Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.
Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].
For example, swapping at indices 0 and 2 in &amp;ldquo;abcd&amp;rdquo; results in &amp;ldquo;cbad&amp;rdquo;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0862.Shortest-Subarray-with-Sum-at-Least-K/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0862.Shortest-Subarray-with-Sum-at-Least-K/</guid><description>862. Shortest Subarray with Sum at Least K # 题目 # Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K.
If there is no non-empty subarray with sum at least K, return -1.
Example 1:
Input: A = [1], K = 1 Output: 1 Example 2:
Input: A = [1,2], K = 4 Output: -1 Example 3:
Input: A = [2,-1,2], K = 3 Output: 3 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0863.All-Nodes-Distance-K-in-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0863.All-Nodes-Distance-K-in-Binary-Tree/</guid><description>863. All Nodes Distance K in Binary Tree # 题目 # We are given a binary tree (with root node root), a target node, and an integer value K.
Return a list of the values of all nodes that have a distance K from the target node. The answer can be returned in any order.
Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2 Output: [7,4,1] Explanation: The nodes that are a distance 2 from the target node (with value 5) have values 7, 4, and 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0864.Shortest-Path-to-Get-All-Keys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0864.Shortest-Path-to-Get-All-Keys/</guid><description>864. Shortest Path to Get All Keys # 题目 # We are given a 2-dimensional grid. &amp;quot;.&amp;quot; is an empty cell, &amp;quot;#&amp;quot; is a wall, &amp;quot;@&amp;quot; is the starting point, (&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;hellip;) are keys, and (&amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;hellip;) are locks.
We start at the starting point, and one move consists of walking one space in one of the 4 cardinal directions. We cannot walk outside the grid, or walk into a wall.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0867.Transpose-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0867.Transpose-Matrix/</guid><description>867. Transpose Matrix # 题目 # Given a matrix A, return the transpose of A.
The transpose of a matrix is the matrix flipped over it&amp;rsquo;s main diagonal, switching the row and column indices of the matrix.
Example 1:
Input: [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]] Example 2:
Input: [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]] Note:
1 &amp;lt;= A.length &amp;lt;= 1000 1 &amp;lt;= A[0].length &amp;lt;= 1000 题目大意 # 给定一个矩阵 A， 返回 A 的转置矩阵。矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0869.Reordered-Power-of-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0869.Reordered-Power-of-2/</guid><description>869. Reordered Power of 2 # 题目 # Starting with a positive integer N, we reorder the digits in any order (including the original order) such that the leading digit is not zero.
Return true if and only if we can do this in a way such that the resulting number is a power of 2.
Example 1:
Input:1 Output:true Example 2:
Input:10 Output:false Example 3:
Input:16 Output:true Example 4:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0870.Advantage-Shuffle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0870.Advantage-Shuffle/</guid><description>870. Advantage Shuffle # 题目 # Given two arrays A and B of equal size, the advantage of A with respect to B is the number of indices i for which A[i] &amp;gt; B[i].
Return any permutation of A that maximizes its advantage with respect to B.
Example 1:
Input:A = [2,7,11,15], B = [1,10,4,11] Output:[2,11,7,15] Example 2:
Input:A = [12,24,8,32], B = [13,25,32,11] Output:[24,32,8,12] Note:
1 &amp;lt;= A.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0872.Leaf-Similar-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0872.Leaf-Similar-Trees/</guid><description>872. Leaf-Similar Trees # 题目 # Consider all the leaves of a binary tree. From left to right order, the values of those leaves form a leaf value sequence.
For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).
Two binary trees are considered leaf-similar if their leaf value sequence is the same.
Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0874.Walking-Robot-Simulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0874.Walking-Robot-Simulation/</guid><description>874. Walking Robot Simulation # 题目 # A robot on an infinite XY-plane starts at point (0, 0) and faces north. The robot can receive one of three possible types of commands:
2: turn left 90 degrees, 1: turn right 90 degrees, or 1 &amp;lt;= k &amp;lt;= 9: move forward k units. Some of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0875.Koko-Eating-Bananas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0875.Koko-Eating-Bananas/</guid><description>875. Koko Eating Bananas # 题目 # Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours.
Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won&amp;rsquo;t eat any more bananas during this hour.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0876.Middle-of-the-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0876.Middle-of-the-Linked-List/</guid><description>876. Middle of the Linked List # 题目 # Given a non-empty, singly linked list with head node head, return a middle node of linked list.
If there are two middle nodes, return the second middle node.
Example 1:
Input: [1,2,3,4,5] Output: Node 3 from this list (Serialization: [3,4,5]) The returned node has value 3. (The judge's serialization of this node is [3,4,5]). Note that we returned a ListNode object ans, such that: ans.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0877.Stone-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0877.Stone-Game/</guid><description>877. Stone Game # 题目 # Alex and Lee play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].
The objective of the game is to end with the most stones. The total number of stones is odd, so there are no ties.
Alex and Lee take turns, with Alex starting first.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0878.Nth-Magical-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0878.Nth-Magical-Number/</guid><description>878. Nth Magical Number # 题目 # A positive integer is magical if it is divisible by either A or B.
Return the N-th magical number. Since the answer may be very large, return it modulo 10^9 + 7.
Example 1:
Input: N = 1, A = 2, B = 3 Output: 2 Example 2:
Input: N = 4, A = 2, B = 3 Output: 6 Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0880.Decoded-String-at-Index/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0880.Decoded-String-at-Index/</guid><description>880. Decoded String at Index # 题目 # An encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken:
If the character read is a letter, that letter is written onto the tape. If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0881.Boats-to-Save-People/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0881.Boats-to-Save-People/</guid><description>881. Boats to Save People # 题目 # The i-th person has weight people[i], and each boat can carry a maximum weight of limit.
Each boat carries at most 2 people at the same time, provided the sum of the weight of those people is at most limit.
Return the minimum number of boats to carry every given person. (It is guaranteed each person can be carried by a boat.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0884.Uncommon-Words-from-Two-Sentences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0884.Uncommon-Words-from-Two-Sentences/</guid><description>884. Uncommon Words from Two Sentences # 题目 # We are given two sentences A and B. (A sentence is a string of space separated words. Each word consists only of lowercase letters.)
A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.
Return a list of all uncommon words.
You may return the list in any order.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0885.Spiral-Matrix-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0885.Spiral-Matrix-III/</guid><description>885. Spiral Matrix III # 题目 # On a 2 dimensional grid with R rows and C columns, we start at (r0, c0) facing east.
Here, the north-west corner of the grid is at the first row and column, and the south-east corner of the grid is at the last row and column.
Now, we walk in a clockwise spiral shape to visit every position in this grid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0887.Super-Egg-Drop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0887.Super-Egg-Drop/</guid><description>887. Super Egg Drop # 题目 # You are given K eggs, and you have access to a building with N floors from 1 to N.
Each egg is identical in function, and if an egg breaks, you cannot drop it again.
You know that there exists a floor F with 0 &amp;lt;= F &amp;lt;= N such that any egg dropped at a floor higher than F will break, and any egg dropped at or below floor F will not break.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0888.Fair-Candy-Swap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0888.Fair-Candy-Swap/</guid><description>888. Fair Candy Swap # 题目 # Alice and Bob have candy bars of different sizes: A[i] is the size of the i-th bar of candy that Alice has, and B[j] is the size of the j-th bar of candy that Bob has.
Since they are friends, they would like to exchange one candy bar each so that after the exchange, they both have the same total amount of candy.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0890.Find-and-Replace-Pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0890.Find-and-Replace-Pattern/</guid><description>890. Find and Replace Pattern # 题目 # Given a list of strings words and a string pattern, return a list of words[i] that match pattern. You may return the answer in any order.
A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word.
Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0891.Sum-of-Subsequence-Widths/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0891.Sum-of-Subsequence-Widths/</guid><description>891. Sum of Subsequence Widths # 题目 # Given an array of integers A, consider all non-empty subsequences of A.
For any sequence S, let the width of S be the difference between the maximum and minimum element of S.
Return the sum of the widths of all subsequences of A.
As the answer may be very large, return the answer modulo 10^9 + 7.
Example 1:
Input: [2,1,3] Output: 6 Explanation: Subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0892.Surface-Area-of-3D-Shapes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0892.Surface-Area-of-3D-Shapes/</guid><description>892. Surface Area of 3D Shapes # 题目 # On a N * N grid, we place some 1 * 1 * 1 cubes.
Each value v = grid[i][j] represents a tower of v cubes placed on top of grid cell (i, j).
Return the total surface area of the resulting shapes.
Example 1:
Input: [[2]] Output: 10 Example 2:
Input: [[1,2],[3,4]] Output: 34 Example 3:
Input: [[1,0],[0,2]] Output: 16 Example 4:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0895.Maximum-Frequency-Stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0895.Maximum-Frequency-Stack/</guid><description>895. Maximum Frequency Stack # 题目 # Implement FreqStack, a class which simulates the operation of a stack-like data structure.
FreqStack has two functions:
push(int x), which pushes an integer x onto the stack. pop(), which removes and returns the most frequent element in the stack.
If there is a tie for most frequent element, the element closest to the top of the stack is removed and returned.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0896.Monotonic-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0896.Monotonic-Array/</guid><description>896. Monotonic Array # 题目 # An array is monotonic if it is either monotone increasing or monotone decreasing.
An array A is monotone increasing if for all i &amp;lt;= j, A[i] &amp;lt;= A[j]. An array A is monotone decreasing if for all i &amp;lt;= j, A[i] &amp;gt;= A[j].
Return true if and only if the given array A is monotonic.
Example 1:
Input: [1,2,2,3] Output: true Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0897.Increasing-Order-Search-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0897.Increasing-Order-Search-Tree/</guid><description>897. Increasing Order Search Tree # 题目 # Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.
Example 1:
Input: [5,3,6,2,4,null,8,1,null,null,null,7,9] 5 / \ 3 6 / \ \ 2 4 8 / / \ 1 7 9 Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] 1 \ 2 \ 3 \ 4 \ 5 \ 6 \ 7 \ 8 \ 9 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0898.Bitwise-ORs-of-Subarrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0800~0899/0898.Bitwise-ORs-of-Subarrays/</guid><description>898. Bitwise ORs of Subarrays # 题目 # We have an array A of non-negative integers.
For every (contiguous) subarray B = [A[i], A[i+1], ..., A[j]] (with i &amp;lt;= j), we take the bitwise OR of all the elements in B, obtaining a result A[i] | A[i+1] | ... | A[j].
Return the number of possible results. (Results that occur more than once are only counted once in the final answer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0901.Online-Stock-Span/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0901.Online-Stock-Span/</guid><description>901. Online Stock Span # 题目 # Write a class StockSpanner which collects daily price quotes for some stock, and returns the span of that stock&amp;rsquo;s price for the current day.
The span of the stock&amp;rsquo;s price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today&amp;rsquo;s price.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0904.Fruit-Into-Baskets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0904.Fruit-Into-Baskets/</guid><description>904. Fruit Into Baskets # 题目 # In a row of trees, the i-th tree produces fruit with type tree[i].
You start at any tree of your choice, then repeatedly perform the following steps:
Add one piece of fruit from this tree to your baskets. If you cannot, stop. Move to the next tree to the right of the current tree. If there is no tree to the right, stop.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0907.Sum-of-Subarray-Minimums/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0907.Sum-of-Subarray-Minimums/</guid><description>907. Sum of Subarray Minimums # 题目 # Given an array of integers A, find the sum of min(B), where B ranges over every (contiguous) subarray of A.
Since the answer may be large, return the answer modulo 10^9 + 7.
Example 1:
Input: [3,1,2,4] Output: 17 Explanation: Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0909.Snakes-and-Ladders/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0909.Snakes-and-Ladders/</guid><description>909. Snakes and Ladders # 题目 # On an N x N board, the numbers from 1 to N*N are written boustrophedonically starting from the bottom left of the board, and alternating direction each row. For example, for a 6 x 6 board, the numbers are written as follows:
You start on square 1 of the board (which is always in the last row and first column). Each move, starting from square x, consists of the following:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0910.Smallest-Range-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0910.Smallest-Range-II/</guid><description>910. Smallest Range II # 题目 # Given an array A of integers, for each integer A[i] we need to choose either x = -K or x = K, and add x to A[i] (only once).
After this process, we have some array B.
Return the smallest possible difference between the maximum value of B and the minimum value of B.
Example 1:
Input: A = [1], K = 0 Output: 0 Explanation: B = [1] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0911.Online-Election/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0911.Online-Election/</guid><description>911. Online Election # 题目 # In an election, the i-th vote was cast for persons[i] at time times[i].
Now, we would like to implement the following query function: TopVotedCandidate.q(int t) will return the number of the person that was leading the election at time t.
Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0914.X-of-a-Kind-in-a-Deck-of-Cards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0914.X-of-a-Kind-in-a-Deck-of-Cards/</guid><description>914. X of a Kind in a Deck of Cards # 题目 # In a deck of cards, each card has an integer written on it.
Return true if and only if you can choose X &amp;gt;= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:
Each group has exactly X cards. All the cards in each group have the same integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0916.Word-Subsets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0916.Word-Subsets/</guid><description>916. Word Subsets # 题目 # We are given two arrays A and B of words. Each word is a string of lowercase letters.
Now, say that word b is a subset of word a ****if every letter in b occurs in a, including multiplicity. For example, &amp;quot;wrr&amp;quot; is a subset of &amp;quot;warrior&amp;quot;, but is not a subset of &amp;quot;world&amp;quot;.
Now say a word a from A is universal if for every b in B, b is a subset of a.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0918.Maximum-Sum-Circular-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0918.Maximum-Sum-Circular-Subarray/</guid><description>918. Maximum Sum Circular Subarray # 题目 # Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.
Here, a circular array means the end of the array connects to the beginning of the array. (Formally, C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length, and C[i+A.length] = C[i] when i &amp;gt;= 0.)
Also, a subarray may only include each element of the fixed buffer A at most once.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0920.Number-of-Music-Playlists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0920.Number-of-Music-Playlists/</guid><description>920. Number of Music Playlists # 题目 # Your music player contains N different songs and she wants to listen to L ****(not necessarily different) songs during your trip. You create a playlist so that:
Every song is played at least once A song can only be played again only if K other songs have been played Return the number of possible playlists. As the answer can be very large, return it modulo 10^9 + 7.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0921.Minimum-Add-to-Make-Parentheses-Valid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0921.Minimum-Add-to-Make-Parentheses-Valid/</guid><description>921. Minimum Add to Make Parentheses Valid # 题目 # Given a string S of &amp;lsquo;(&amp;rsquo; and &amp;lsquo;)&amp;rsquo; parentheses, we add the minimum number of parentheses ( &amp;lsquo;(&amp;rsquo; or &amp;lsquo;)&amp;rsquo;, and in any positions ) so that the resulting parentheses string is valid.
Formally, a parentheses string is valid if and only if:
It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0922.Sort-Array-By-Parity-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0922.Sort-Array-By-Parity-II/</guid><description>922. Sort Array By Parity II # 题目 # Given an array A of non-negative integers, half of the integers in A are odd, and half of the integers are even.
Sort the array so that whenever A[i] is odd, i is odd; and whenever A[i] is even, i is even.
You may return any answer array that satisfies this condition.
Example 1:
Input: [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0923.3Sum-With-Multiplicity/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0923.3Sum-With-Multiplicity/</guid><description>923. 3Sum With Multiplicity # 题目 # Given an integer array A, and an integer target, return the number of tuples i, j, k such that i &amp;lt; j &amp;lt; k and A[i] + A[j] + A[k] == target.
As the answer can be very large, return it modulo 10^9 + 7.
Example 1:
Input: A = [1,1,2,2,3,3,4,4,5,5], target = 8 Output: 20 Explanation: Enumerating by the values (A[i], A[j], A[k]): (1, 2, 5) occurs 8 times; (1, 3, 4) occurs 8 times; (2, 2, 4) occurs 2 times; (2, 3, 3) occurs 2 times.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0924.Minimize-Malware-Spread/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0924.Minimize-Malware-Spread/</guid><description>924. Minimize Malware Spread # 题目 # In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0925.Long-Pressed-Name/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0925.Long-Pressed-Name/</guid><description>925. Long Pressed Name # 题目 # Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times.
You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0927.Three-Equal-Parts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0927.Three-Equal-Parts/</guid><description>927. Three Equal Parts # 题目 # Given an array A of 0s and 1s, divide the array into 3 non-empty parts such that all of these parts represent the same binary value.
If it is possible, return any [i, j] with i+1 &amp;lt; j, such that:
A[0], A[1], ..., A[i] is the first part; A[i+1], A[i+2], ..., A[j-1] is the second part, and A[j], A[j+1], ..., A[A.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0928.Minimize-Malware-Spread-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0928.Minimize-Malware-Spread-II/</guid><description>928. Minimize Malware Spread II # 题目 # (This problem is the same as Minimize Malware Spread, with the differences bolded.)
In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
Some nodes initial are initially infected by malware. Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0930.Binary-Subarrays-With-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0930.Binary-Subarrays-With-Sum/</guid><description>930. Binary Subarrays With Sum # 题目 # In an array A of 0s and 1s, how many non-empty subarrays have sum S?
Example 1:
Input: A = [1,0,1,0,1], S = 2 Output: 4 Explanation: The 4 subarrays are bolded below: [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] [1,0,1,0,1] Note:
A.length &amp;lt;= 30000 0 &amp;lt;= S &amp;lt;= A.length A[i] is either 0 or 1. 题目大意 # 给定一个数组，数组里面的元素只有 0 和 1 两种。问这个数组有多少个和为 S 的子数组。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0933.Number-of-Recent-Calls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0933.Number-of-Recent-Calls/</guid><description>933. Number of Recent Calls # 题目 # Write a class RecentCounter to count recent requests.
It has only one method: ping(int t), where t represents some time in milliseconds.
Return the number of pings that have been made from 3000 milliseconds ago until now.
Any ping with time in [t - 3000, t] will count, including the current ping.
It is guaranteed that every call to ping uses a strictly larger value of t than before.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0938.Range-Sum-of-BST/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0938.Range-Sum-of-BST/</guid><description>938. Range Sum of BST # 题目 # Given the root node of a binary search tree, return the sum of values of all nodes with a value in the range [low, high].
Example 1:
Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Example 2:
Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Constraints:
The number of nodes in the tree is in the range [1, 2 * 10^4].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0942.DI-String-Match/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0942.DI-String-Match/</guid><description>942. DI String Match # 题目 # Given a string S that only contains &amp;ldquo;I&amp;rdquo; (increase) or &amp;ldquo;D&amp;rdquo; (decrease), let N = S.length.
Return any permutation A of [0, 1, ..., N] such that for all i = 0, ..., N-1:
If S[i] == &amp;quot;I&amp;quot;, then A[i] &amp;lt; A[i+1] If S[i] == &amp;quot;D&amp;quot;, then A[i] &amp;gt; A[i+1] Example 1:
Input: &amp;quot;IDID&amp;quot; Output: [0,4,1,3,2] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0946.Validate-Stack-Sequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0946.Validate-Stack-Sequences/</guid><description>946. Validate Stack Sequences # 题目 # Given two sequences pushed and popped with distinct values, return true if and only if this could have been the result of a sequence of push and pop operations on an initially empty stack.
Example 1:
Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1] Output: true Explanation: We might do the following sequence: push(1), push(2), push(3), push(4), pop() -&amp;gt; 4, push(5), pop() -&amp;gt; 5, pop() -&amp;gt; 3, pop() -&amp;gt; 2, pop() -&amp;gt; 1 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0947.Most-Stones-Removed-with-Same-Row-or-Column/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0947.Most-Stones-Removed-with-Same-Row-or-Column/</guid><description>947. Most Stones Removed with Same Row or Column # 题目 # On a 2D plane, we place stones at some integer coordinate points. Each coordinate point may have at most one stone.
Now, a move consists of removing a stone that shares a column or row with another stone on the grid.
What is the largest possible number of moves we can make?
Example 1:
Input: stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] Output: 5 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0949.Largest-Time-for-Given-Digits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0949.Largest-Time-for-Given-Digits/</guid><description>949. Largest Time for Given Digits # 题目 # Given an array of 4 digits, return the largest 24 hour time that can be made.
The smallest 24 hour time is 00:00, and the largest is 23:59. Starting from 00:00, a time is larger if more time has elapsed since midnight.
Return the answer as a string of length 5. If no valid time can be made, return an empty string.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0952.Largest-Component-Size-by-Common-Factor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0952.Largest-Component-Size-by-Common-Factor/</guid><description>952. Largest Component Size by Common Factor # 题目 # Given a non-empty array of unique positive integers A, consider the following graph:
There are A.length nodes, labelled A[0] to A[A.length - 1]; There is an edge between A[i] and A[j] if and only if A[i]and A[j] share a common factor greater than 1. Return the size of the largest connected component in the graph.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0953.Verifying-an-Alien-Dictionary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0953.Verifying-an-Alien-Dictionary/</guid><description>953. Verifying an Alien Dictionary # 题目 # In an alien language, surprisingly they also use english lowercase letters, but possibly in a different order. The orderof the alphabet is some permutation of lowercase letters.
Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographicaly in this alien language.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0958.Check-Completeness-of-a-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0958.Check-Completeness-of-a-Binary-Tree/</guid><description>958. Check Completeness of a Binary Tree # 题目 # Given the root of a binary tree, determine if it is a complete binary tree.
In a  complete binary tree, every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0959.Regions-Cut-By-Slashes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0959.Regions-Cut-By-Slashes/</guid><description>959. Regions Cut By Slashes # 题目 # In a N x N grid composed of 1 x 1 squares, each 1 x 1 square consists of a /, \, or blank space. These characters divide the square into contiguous regions.
(Note that backslash characters are escaped, so a \ is represented as &amp;quot;\\&amp;quot;.)
Return the number of regions.
Example 1:
Input: [ &amp;quot; /&amp;quot;, &amp;quot;/ &amp;quot; ] Output: 2 Explanation: The 2x2 grid is as follows: Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0961.N-Repeated-Element-in-Size-2N-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0961.N-Repeated-Element-in-Size-2N-Array/</guid><description>961. N-Repeated Element in Size 2N Array # 题目 # In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times.
Return the element repeated N times.
Example 1:
Input: [1,2,3,3] Output: 3 Example 2:
Input: [2,1,2,5,3,2] Output: 2 Example 3:
Input: [5,1,5,2,5,3,5,4] Output: 5 Note:
4 &amp;lt;= A.length &amp;lt;= 10000 0 &amp;lt;= A[i] &amp;lt; 10000 A.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0966.Vowel-Spellchecker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0966.Vowel-Spellchecker/</guid><description>966. Vowel Spellchecker # 题目 # Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.
For a given query word, the spell checker handles two categories of spelling mistakes:
Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist. Example: wordlist = [&amp;quot;yellow&amp;quot;], query = &amp;quot;YellOw&amp;quot;: correct = &amp;quot;yellow&amp;quot; Example: wordlist = [&amp;quot;Yellow&amp;quot;], query = &amp;quot;yellow&amp;quot;: correct = &amp;quot;Yellow&amp;quot; Example: wordlist = [&amp;quot;yellow&amp;quot;], query = &amp;quot;yellow&amp;quot;: correct = &amp;quot;yellow&amp;quot; Vowel Errors: If after replacing the vowels (&amp;lsquo;a&amp;rsquo;, &amp;lsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, &amp;lsquo;u&amp;rsquo;) of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0968.Binary-Tree-Cameras/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0968.Binary-Tree-Cameras/</guid><description>968. Binary Tree Cameras # 题目 # Given a binary tree, we install cameras on the nodes of the tree.
Each camera at a node can monitor its parent, itself, and its immediate children.
Calculate the minimum number of cameras needed to monitor all nodes of the tree.
Example 1:
Input: [0,0,null,0,0] Output: 1 Explanation: One camera is enough to monitor all nodes if placed as shown. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0969.Pancake-Sorting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0969.Pancake-Sorting/</guid><description>969. Pancake Sorting # 题目 # Given an array A, we can perform a pancake flip: We choose some positive integer k &amp;lt;= A.length, then reverse the order of the first k elements of A. We want to perform zero or more pancake flips (doing them one after another in succession) to sort the array A.
Return the k-values corresponding to a sequence of pancake flips that sort A.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0970.Powerful-Integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0970.Powerful-Integers/</guid><description>970. Powerful Integers # 题目 # Given two positive integers x and y, an integer is powerful if it is equal to x^i + y^j for some integers i &amp;gt;= 0 and j &amp;gt;= 0.
Return a list of all powerful integers that have value less than or equal to bound.
You may return the answer in any order. In your answer, each value should occur at most once.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0971.Flip-Binary-Tree-To-Match-Preorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0971.Flip-Binary-Tree-To-Match-Preorder-Traversal/</guid><description>971. Flip Binary Tree To Match Preorder Traversal # 题目 # You are given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired  pre-order traversal of the binary tree.
Any node in the binary tree can be flipped by swapping its left and right subtrees.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0973.K-Closest-Points-to-Origin/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0973.K-Closest-Points-to-Origin/</guid><description>973. K Closest Points to Origin # 题目 # We have a list of points on the plane. Find the K closest points to the origin (0, 0).
(Here, the distance between two points on a plane is the Euclidean distance.)
You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)
Example 1:
Input: points = [[1,3],[-2,2]], K = 1 Output: [[-2,2]] Explanation: The distance between (1, 3) and the origin is sqrt(10).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0976.Largest-Perimeter-Triangle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0976.Largest-Perimeter-Triangle/</guid><description>976. Largest Perimeter Triangle # 题目 # Given an array A of positive lengths, return the largest perimeter of a triangle with non-zero area, formed from 3 of these lengths.
If it is impossible to form any triangle of non-zero area, return 0.
Example 1:
Input: [2,1,2] Output: 5 Example 2:
Input: [1,2,1] Output: 0 Example 3:
Input: [3,2,3,4] Output: 10 Example 4:
Input: [3,6,2,3] Output: 8 Note:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0977.Squares-of-a-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0977.Squares-of-a-Sorted-Array/</guid><description>977. Squares of a Sorted Array # 题目 # Given an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order.
Example 1:
Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Example 2:
Input: [-7,-3,2,3,11] Output: [4,9,9,49,121] Note:
1 &amp;lt;= A.length &amp;lt;= 10000 -10000 &amp;lt;= A[i] &amp;lt;= 10000 A is sorted in non-decreasing order. 题目大意 # 给一个已经有序的数组，返回的数组也必须是有序的，且数组中的每个元素是由原数组中每个数字的平方得到的。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0978.Longest-Turbulent-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0978.Longest-Turbulent-Subarray/</guid><description>978. Longest Turbulent Subarray # 题目 # A subarray A[i], A[i+1], ..., A[j] of A is said to be turbulent if and only if:
For i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1] when k is odd, and A[k] &amp;lt; A[k+1] when k is even; OR, for i &amp;lt;= k &amp;lt; j, A[k] &amp;gt; A[k+1] when k is even, and A[k] &amp;lt; A[k+1] when k is odd. That is, the subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0979.Distribute-Coins-in-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0979.Distribute-Coins-in-Binary-Tree/</guid><description>979. Distribute Coins in Binary Tree # 题目 # Given the root of a binary tree with N nodes, each node in the tree has node.val coins, and there are N coins total.
In one move, we may choose two adjacent nodes and move one coin from one node to another. (The move may be from parent to child, or from child to parent.)
Return the number of moves required to make every node have exactly one coin.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0980.Unique-Paths-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0980.Unique-Paths-III/</guid><description>980. Unique Paths III # 题目 # On a 2-dimensional grid, there are 4 types of squares:
1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0981.Time-Based-Key-Value-Store/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0981.Time-Based-Key-Value-Store/</guid><description>981. Time Based Key-Value Store # 题目 # Create a timebased key-value store class TimeMap, that supports two operations.
1. set(string key, string value, int timestamp)
Stores the key and value, along with the given timestamp. 2. get(string key, int timestamp)
Returns a value such that set(key, value, timestamp_prev) was called previously, with timestamp_prev &amp;lt;= timestamp. If there are multiple such values, it returns the one with the largest timestamp_prev.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0984.String-Without-AAA-or-BBB/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0984.String-Without-AAA-or-BBB/</guid><description>984. String Without AAA or BBB # 题目 # Given two integers A and B, return any string S such that:
S has length A + B and contains exactly A 'a' letters, and exactly B 'b'letters; The substring 'aaa' does not occur in S; The substring 'bbb' does not occur in S. Example 1:
Input: A = 1, B = 2 Output: &amp;quot;abb&amp;quot; Explanation: &amp;quot;abb&amp;quot;, &amp;quot;bab&amp;quot; and &amp;quot;bba&amp;quot; are all correct answers.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0985.Sum-of-Even-Numbers-After-Queries/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0985.Sum-of-Even-Numbers-After-Queries/</guid><description>985. Sum of Even Numbers After Queries # 题目 # We have an array A of integers, and an array queries of queries.
For the i-th query val = queries[i][0], index = queries[i][1], we add val to A[index]. Then, the answer to the i-th query is the sum of the even values of A.
(Here, the given index = queries[i][1] is a 0-based index, and each query permanently modifies the array A.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0986.Interval-List-Intersections/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0986.Interval-List-Intersections/</guid><description>986. Interval List Intersections # 题目 # Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.
Return the intersection of these two interval lists.
(Formally, a closed interval [a, b] (with a &amp;lt;= b) denotes the set of real numbers x with a &amp;lt;= x &amp;lt;= b. The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0987.Vertical-Order-Traversal-of-a-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0987.Vertical-Order-Traversal-of-a-Binary-Tree/</guid><description>987. Vertical Order Traversal of a Binary Tree # 题目 # Given the root of a binary tree, calculate the vertical order traversal of the binary tree.
For each node at position (row, col), its left and right children will be at positions (row + 1, col - 1) and (row + 1, col + 1) respectively. The root of the tree is at (0, 0).
The vertical order traversal of a binary tree is a list of top-to-bottom orderings for each column index starting from the leftmost column and ending on the rightmost column.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0989.Add-to-Array-Form-of-Integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0989.Add-to-Array-Form-of-Integer/</guid><description>989. Add to Array-Form of Integer # 题目 # For a non-negative integer X, the array-form of X is an array of its digits in left to right order. For example, if X = 1231, then the array form is [1,2,3,1].
Given the array-form A of a non-negative integer X, return the array-form of the integer X+K.
Example 1:
Input: A = [1,2,0,0], K = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0990.Satisfiability-of-Equality-Equations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0990.Satisfiability-of-Equality-Equations/</guid><description>990. Satisfiability of Equality Equations # 题目 # Given an array equations of strings that represent relationships between variables, each string equations[i] has length 4 and takes one of two different forms: &amp;quot;a==b&amp;quot; or &amp;quot;a!=b&amp;quot;. Here, a and b are lowercase letters (not necessarily different) that represent one-letter variable names.
Return true if and only if it is possible to assign integers to variable names so as to satisfy all the given equations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0991.Broken-Calculator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0991.Broken-Calculator/</guid><description>991. Broken Calculator # 题目 # On a broken calculator that has a number showing on its display, we can perform two operations:
Double: Multiply the number on the display by 2, or; Decrement: Subtract 1 from the number on the display. Initially, the calculator is displaying the number X.
Return the minimum number of operations needed to display the number Y.
Example 1:
Input: X = 2, Y = 3 Output: 2 Explanation: Use double operation and then decrement operation {2 -&amp;gt; 4 -&amp;gt; 3}.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0992.Subarrays-with-K-Different-Integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0992.Subarrays-with-K-Different-Integers/</guid><description>992. Subarrays with K Different Integers # 题目 # Given an array A of positive integers, call a (contiguous, not necessarily distinct) subarray of A good if the number of different integers in that subarray is exactly K.
(For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.)
Return the number of good subarrays of A.
Example 1:
Input: A = [1,2,1,2,3], K = 2 Output: 7 Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0993.Cousins-in-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0993.Cousins-in-Binary-Tree/</guid><description>993. Cousins in Binary Tree # 题目 # In a binary tree, the root node is at depth 0, and children of each depth k node are at depth k+1.
Two nodes of a binary tree are cousins if they have the same depth, but have different parents.
We are given the root of a binary tree with unique values, and the values x and y of two different nodes in the tree.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0995.Minimum-Number-of-K-Consecutive-Bit-Flips/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0995.Minimum-Number-of-K-Consecutive-Bit-Flips/</guid><description>995. Minimum Number of K Consecutive Bit Flips # 题目 # In an array A containing only 0s and 1s, a K-bit flip consists of choosing a (contiguous) subarray of length K and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0.
Return the minimum number of K-bit flips required so that there is no 0 in the array. If it is not possible, return -1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0996.Number-of-Squareful-Arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0996.Number-of-Squareful-Arrays/</guid><description>996. Number of Squareful Arrays # 题目 # Given an array A of non-negative integers, the array is squareful if for every pair of adjacent elements, their sum is a perfect square.
Return the number of permutations of A that are squareful. Two permutations A1 and A2 differ if and only if there is some index i such that A1[i] != A2[i].
Example 1:
Input: [1,17,8] Output: 2 Explanation: [1,8,17] and [17,8,1] are the valid permutations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0997.Find-the-Town-Judge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0997.Find-the-Town-Judge/</guid><description>997. Find the Town Judge # 题目 # In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.
If the town judge exists, then:
The town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0999.Available-Captures-for-Rook/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/0900~0999/0999.Available-Captures-for-Rook/</guid><description>999. Available Captures for Rook # 题目 # On an 8 x 8 chessboard, there is one white rook. There also may be empty squares, white bishops, and black pawns. These are given as characters &amp;lsquo;R&amp;rsquo;, &amp;lsquo;.&amp;rsquo;, &amp;lsquo;B&amp;rsquo;, and &amp;lsquo;p&amp;rsquo; respectively. Uppercase characters represent white pieces, and lowercase characters represent black pieces.
The rook moves as in the rules of Chess: it chooses one of four cardinal directions (north, east, west, and south), then moves in that direction until it chooses to stop, reaches the edge of the board, or captures an opposite colored pawn by moving to the same square it occupies.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1002.Find-Common-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1002.Find-Common-Characters/</guid><description>1002. Find Common Characters # 题目 # Given an array A of strings made only from lowercase letters, return a list of all characters that show up in all strings within the list (including duplicates). For example, if a character occurs 3 times in all strings but not 4 times, you need to include that character three times in the final answer.
You may return the answer in any order.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1003.Check-If-Word-Is-Valid-After-Substitutions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1003.Check-If-Word-Is-Valid-After-Substitutions/</guid><description>1003. Check If Word Is Valid After Substitutions # 题目 # We are given that the string &amp;ldquo;abc&amp;rdquo; is valid.
From any valid string V, we may split V into two pieces X and Y such that X + Y (X concatenated with Y) is equal to V. (X or Y may be empty.) Then, X + &amp;ldquo;abc&amp;rdquo; + Y is also valid.
If for example S = &amp;ldquo;abc&amp;rdquo;, then examples of valid strings are: &amp;ldquo;abc&amp;rdquo;, &amp;ldquo;aabcbc&amp;rdquo;, &amp;ldquo;abcabc&amp;rdquo;, &amp;ldquo;abcabcababcc&amp;rdquo;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1004.Max-Consecutive-Ones-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1004.Max-Consecutive-Ones-III/</guid><description>1004. Max Consecutive Ones III # 题目 # Given an array A of 0s and 1s, we may change up to K values from 0 to 1.
Return the length of the longest (contiguous) subarray that contains only 1s.
Example 1:
Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2 Output: 6 Explanation: [1,1,1,0,0,1,1,1,1,1,1] Bolded numbers were flipped from 0 to 1. The longest subarray is underlined. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1005.Maximize-Sum-Of-Array-After-K-Negations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1005.Maximize-Sum-Of-Array-After-K-Negations/</guid><description>1005. Maximize Sum Of Array After K Negations # 题目 # Given an array A of integers, we must modify the array in the following way: we choose an i and replace A[i] with -A[i], and we repeat this process K times in total. (We may choose the same index i multiple times.)
Return the largest possible sum of the array after modifying it in this way.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1006.Clumsy-Factorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1006.Clumsy-Factorial/</guid><description>1006. Clumsy Factorial # 题目 # Normally, the factorial of a positive integer n is the product of all positive integers less than or equal to n. For example, factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1.
We instead make a clumsy factorial: using the integers in decreasing order, we swap out the multiply operations for a fixed rotation of operations: multiply (*), divide (/), add (+) and subtract (-) in this order.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1009.Complement-of-Base-10-Integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1009.Complement-of-Base-10-Integer/</guid><description>1009. Complement of Base 10 Integer # 题目 # The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.
For example, The integer 5 is &amp;quot;101&amp;quot; in binary and its complement is &amp;quot;010&amp;quot; which is the integer 2. Given an integer n, return its complement.
Example 1:
Input: n = 5 Output: 2 Explanation: 5 is &amp;quot;101&amp;quot; in binary, with complement &amp;quot;010&amp;quot; in binary, which is 2 in base-10.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1010.Pairs-of-Songs-With-Total-Durations-Divisible-by-60/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1010.Pairs-of-Songs-With-Total-Durations-Divisible-by-60/</guid><description>1010. Pairs of Songs With Total Durations Divisible by 60 # 题目 # You are given a list of songs where the ith song has a duration of time[i] seconds.
Return the number of pairs of songs for which their total duration in seconds is divisible by 60. Formally, we want the number of indices i, j such that i &amp;lt; j with (time[i] + time[j]) % 60 == 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1011.Capacity-To-Ship-Packages-Within-D-Days/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1011.Capacity-To-Ship-Packages-Within-D-Days/</guid><description>1011. Capacity To Ship Packages Within D Days # 题目 # A conveyor belt has packages that must be shipped from one port to another within D days.
The i-th package on the conveyor belt has a weight of weights[i]. Each day, we load the ship with packages on the conveyor belt (in the order given by weights). We may not load more weight than the maximum weight capacity of the ship.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1017.Convert-to-Base-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1017.Convert-to-Base-2/</guid><description>1017. Convert to Base -2 # 题目 # Given a number N, return a string consisting of &amp;quot;0&amp;quot;s and &amp;quot;1&amp;quot;s that represents its value in base -2 (negative two).
The returned string must have no leading zeroes, unless the string is &amp;quot;0&amp;quot;.
Example 1:
Input: 2 Output: &amp;quot;110&amp;quot; Explantion: (-2) ^ 2 + (-2) ^ 1 = 2 Example 2:
Input: 3 Output: &amp;quot;111&amp;quot; Explantion: (-2) ^ 2 + (-2) ^ 1 + (-2) ^ 0 = 3 Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1018.Binary-Prefix-Divisible-By-5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1018.Binary-Prefix-Divisible-By-5/</guid><description>1018. Binary Prefix Divisible By 5 # 题目 # Given an array A of 0s and 1s, consider N_i: the i-th subarray from A[0] to A[i] interpreted as a binary number (from most-significant-bit to least-significant-bit.)
Return a list of booleans answer, where answer[i] is true if and only if N_i is divisible by 5.
Example 1:
Input: [0,1,1] Output: [true,false,false] Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1019.Next-Greater-Node-In-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1019.Next-Greater-Node-In-Linked-List/</guid><description>1019. Next Greater Node In Linked List # 题目 # We are given a linked list with head as the first node. Let&amp;rsquo;s number the nodes in the list: node_1, node_2, node_3, &amp;hellip; etc.
Each node may have a next larger value: for node_i, next_larger(node_i) is the node_j.val such that j &amp;gt; i, node_j.val &amp;gt; node_i.val, and j is the smallest possible choice. If such a j does not exist, the next larger value is 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1020.Number-of-Enclaves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1020.Number-of-Enclaves/</guid><description>1020. Number of Enclaves # 题目 # Given a 2D array A, each cell is 0 (representing sea) or 1 (representing land)
A move consists of walking from one land square 4-directionally to another land square, or off the boundary of the grid.
Return the number of land squares in the grid for which we cannot walk off the boundary of the grid in any number of moves.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1021.Remove-Outermost-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1021.Remove-Outermost-Parentheses/</guid><description>1021. Remove Outermost Parentheses # 题目 # A valid parentheses string is either empty (&amp;quot;&amp;quot;), &amp;ldquo;(&amp;rdquo; + A + &amp;ldquo;)&amp;rdquo;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, &amp;ldquo;&amp;rdquo;, &amp;ldquo;()&amp;rdquo;, &amp;ldquo;(())()&amp;rdquo;, and &amp;ldquo;(()(()))&amp;rdquo; are all valid parentheses strings.
A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1022.Sum-of-Root-To-Leaf-Binary-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1022.Sum-of-Root-To-Leaf-Binary-Numbers/</guid><description>1022. Sum of Root To Leaf Binary Numbers # 题目 # You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit.
For example, if the path is 0 -&amp;gt; 1 -&amp;gt; 1 -&amp;gt; 0 -&amp;gt; 1, then this could represent 01101 in binary, which is 13. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1025.Divisor-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1025.Divisor-Game/</guid><description>1025. Divisor Game # 题目 # Alice and Bob take turns playing a game, with Alice starting first.
Initially, there is a number N on the chalkboard. On each player&amp;rsquo;s turn, that player makes a move consisting of:
Choosing any x with 0 &amp;lt; x &amp;lt; N and N % x == 0. Replacing the number N on the chalkboard with N - x. Also, if a player cannot make a move, they lose the game.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1026.Maximum-Difference-Between-Node-and-Ancestor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1026.Maximum-Difference-Between-Node-and-Ancestor/</guid><description>1026. Maximum Difference Between Node and Ancestor # 题目 # Given the root of a binary tree, find the maximum value V for which there exists different nodes A and B where V = |A.val - B.val| and A is an ancestor of B.
(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1028.Recover-a-Tree-From-Preorder-Traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1028.Recover-a-Tree-From-Preorder-Traversal/</guid><description>1028. Recover a Tree From Preorder Traversal # 题目 # We run a preorder depth first search on the root of a binary tree.
At each node in this traversal, we output D dashes (where D is the depth of this node), then we output the value of this node. (If the depth of a node is D, the depth of its immediate child is D+1. The depth of the root node is 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1030.Matrix-Cells-in-Distance-Order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1030.Matrix-Cells-in-Distance-Order/</guid><description>1030. Matrix Cells in Distance Order # 题目 # We are given a matrix with R rows and C columns has cells with integer coordinates (r, c), where 0 &amp;lt;= r &amp;lt; R and 0 &amp;lt;= c &amp;lt; C.
Additionally, we are given a cell in that matrix with coordinates (r0, c0).
Return the coordinates of all cells in the matrix, sorted by their distance from (r0, c0) from smallest distance to largest distance.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1034.Coloring-A-Border/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1034.Coloring-A-Border/</guid><description>1034. Coloring A Border # 题目 # You are given an m x n integer matrix grid, and three integers row, col, and color. Each value in the grid represents the color of the grid square at that location.
Two squares belong to the same connected component if they have the same color and are next to each other in any of the 4 directions.
The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1037.Valid-Boomerang/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1037.Valid-Boomerang/</guid><description>1037. Valid Boomerang # 题目 # A boomerang is a set of 3 points that are all distinct and not in a straight line.
Given a list of three points in the plane, return whether these points are a boomerang.
Example 1:
Input: [[1,1],[2,3],[3,2]] Output: true Example 2:
Input: [[1,1],[2,2],[3,3]] Output: false Note:
points.length == 3 points[i].length == 2 0 &amp;lt;= points[i][j] &amp;lt;= 100 题目大意 # 回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1038.Binary-Search-Tree-to-Greater-Sum-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1038.Binary-Search-Tree-to-Greater-Sum-Tree/</guid><description>1038. Binary Search Tree to Greater Sum Tree # 题目 # Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST.
As a reminder, a binary search tree is a tree that satisfies these constraints:
The left subtree of a node contains only nodes with keys less than the node&amp;rsquo;s key.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1040.Moving-Stones-Until-Consecutive-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1040.Moving-Stones-Until-Consecutive-II/</guid><description>1040. Moving Stones Until Consecutive II # 题目 # On an infinite number line, the position of the i-th stone is given by stones[i]. Call a stone an endpoint stone if it has the smallest or largest position.
Each turn, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.
In particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1047.Remove-All-Adjacent-Duplicates-In-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1047.Remove-All-Adjacent-Duplicates-In-String/</guid><description>1047. Remove All Adjacent Duplicates In String # 题目 # Given a string S of lowercase letters, a duplicate removal consists of choosing two adjacent and equal letters, and removing them.
We repeatedly make duplicate removals on S until we no longer can.
Return the final string after all such duplicate removals have been made. It is guaranteed the answer is unique.
Example 1:
Input: &amp;quot;abbaca&amp;quot; Output: &amp;quot;ca&amp;quot; Explanation: For example, in &amp;quot;abbaca&amp;quot; we could remove &amp;quot;bb&amp;quot; since the letters are adjacent and equal, and this is the only possible move.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1048.Longest-String-Chain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1048.Longest-String-Chain/</guid><description>1048. Longest String Chain # 题目 # Given a list of words, each word consists of English lowercase letters.
Let&amp;rsquo;s say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2. For example, &amp;quot;abc&amp;quot; is a predecessor of &amp;quot;abac&amp;quot;.
A word chain is a sequence of words [word_1, word_2, ..., word_k] with k &amp;gt;= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1049.Last-Stone-Weight-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1049.Last-Stone-Weight-II/</guid><description>1049. Last Stone Weight II # 题目 # We have a collection of rocks, each rock has a positive integer weight.
Each turn, we choose any two rocks and smash them together. Suppose the stones have weights x and y with x &amp;lt;= y. The result of this smash is:
If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight yhas new weight y-x.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1051.Height-Checker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1051.Height-Checker/</guid><description>1051. Height Checker # 题目 # Students are asked to stand in non-decreasing order of heights for an annual photo.
Return the minimum number of students that must move in order for all students to be standing in non-decreasing order of height.
Notice that when a group of students is selected they can reorder in any possible way between themselves and the non selected students remain on their seats.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1052.Grumpy-Bookstore-Owner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1052.Grumpy-Bookstore-Owner/</guid><description>1052. Grumpy Bookstore Owner # 题目 # Today, the bookstore owner has a store open for customers.lengthminutes. Every minute, some number of customers (customers[i]) enter the store, and all those customers leave after the end of that minute.
On some minutes, the bookstore owner is grumpy. If the bookstore owner is grumpy on the i-th minute, grumpy[i] = 1, otherwise grumpy[i] = 0. When the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise they are satisfied.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1054.Distant-Barcodes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1054.Distant-Barcodes/</guid><description>1054. Distant Barcodes # 题目 # In a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i].
Rearrange the barcodes so that no two adjacent barcodes are equal. You may return any answer, and it is guaranteed an answer exists.
Example 1:
Input: [1,1,1,2,2,2] Output: [2,1,2,1,2,1] Example 2:
Input: [1,1,1,1,2,2,3,3] Output: [1,3,1,3,2,1,2,1] Note:
1 &amp;lt;= barcodes.length &amp;lt;= 10000 1 &amp;lt;= barcodes[i] &amp;lt;= 10000 题目大意 # 在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。请你重新排列这些条形码，使其中两个相邻的条形码 不能 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1073.Adding-Two-Negabinary-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1073.Adding-Two-Negabinary-Numbers/</guid><description>1073. Adding Two Negabinary Numbers # 题目 # Given two numbers arr1 and arr2 in base -2, return the result of adding them together.
Each number is given in array format: as an array of 0s and 1s, from most significant bit to least significant bit. For example, arr = [1,1,0,1]represents the number (-2)^3 + (-2)^2 + (-2)^0 = -3. A number arr in array format is also guaranteed to have no leading zeros: either arr == [0] or arr[0] == 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1074.Number-of-Submatrices-That-Sum-to-Target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1074.Number-of-Submatrices-That-Sum-to-Target/</guid><description>1074. Number of Submatrices That Sum to Target # 题目 # Given a matrix, and a target, return the number of non-empty submatrices that sum to target.
A submatrix x1, y1, x2, y2 is the set of all cells matrix[y] with x1 &amp;lt;= x &amp;lt;= x2 and y1 &amp;lt;= y &amp;lt;= y2.
Two submatrices (x1, y1, x2, y2) and (x1', y1', x2', y2') are different if they have some coordinate that is different: for example, if x1 !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1078.Occurrences-After-Bigram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1078.Occurrences-After-Bigram/</guid><description>1078. Occurrences After Bigram # 题目 # Given words first and second, consider occurrences in some text of the form &amp;ldquo;first second third&amp;rdquo;, where second comes immediately after first, and thirdcomes immediately after second.
For each such occurrence, add &amp;ldquo;third&amp;rdquo; to the answer, and return the answer.
Example 1:
Input: text = &amp;quot;alice is a good girl she is a good student&amp;quot;, first = &amp;quot;a&amp;quot;, second = &amp;quot;good&amp;quot; Output: [&amp;quot;girl&amp;quot;,&amp;quot;student&amp;quot;] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1079.Letter-Tile-Possibilities/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1079.Letter-Tile-Possibilities/</guid><description>1079. Letter Tile Possibilities # 题目 # You have a set of tiles, where each tile has one letter tiles[i] printed on it. Return the number of possible non-empty sequences of letters you can make.
Example 1:
Input: &amp;quot;AAB&amp;quot; Output: 8 Explanation: The possible sequences are &amp;quot;A&amp;quot;, &amp;quot;B&amp;quot;, &amp;quot;AA&amp;quot;, &amp;quot;AB&amp;quot;, &amp;quot;BA&amp;quot;, &amp;quot;AAB&amp;quot;, &amp;quot;ABA&amp;quot;, &amp;quot;BAA&amp;quot;. Example 2:
Input: &amp;quot;AAABBC&amp;quot; Output: 188 Note:
1 &amp;lt;= tiles.length &amp;lt;= 7 tiles consists of uppercase English letters.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1089.Duplicate-Zeros/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1089.Duplicate-Zeros/</guid><description>1089. Duplicate Zeros # 题目 # Given a fixed length array arr of integers, duplicate each occurrence of zero, shifting the remaining elements to the right.
Note that elements beyond the length of the original array are not written.
Do the above modifications to the input array in place, do not return anything from your function.
Example 1:
Input: [1,0,2,3,0,4,5,0] Output: null Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1091.Shortest-Path-in-Binary-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1091.Shortest-Path-in-Binary-Matrix/</guid><description>1091. Shortest Path in Binary Matrix # 题目 # In an N by N square grid, each cell is either empty (0) or blocked (1).
A clear path from top-left to bottom-right has length k if and only if it is composed of cells C_1, C_2, ..., C_k such that:
Adjacent cells C_i and C_{i+1} are connected 8-directionally (ie., they are different and share an edge or corner) C_1 is at location (0, 0) (ie.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1093.Statistics-from-a-Large-Sample/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1000~1099/1093.Statistics-from-a-Large-Sample/</guid><description>1093. Statistics from a Large Sample # 题目 # We sampled integers between 0 and 255, and stored the results in an array count: count[k] is the number of integers we sampled equal to k.
Return the minimum, maximum, mean, median, and mode of the sample respectively, as an array of floating point numbers. The mode is guaranteed to be unique.
(Recall that the median of a sample is:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1104.Path-In-Zigzag-Labelled-Binary-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1104.Path-In-Zigzag-Labelled-Binary-Tree/</guid><description>1104. Path In Zigzag Labelled Binary Tree # 题目 # In an infinite binary tree where every node has two children, the nodes are labelled in row order.
In the odd numbered rows (ie., the first, third, fifth,&amp;hellip;), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,&amp;hellip;), the labelling is right to left.
Given the label of a node in this tree, return the labels in the path from the root of the tree to the node with that label.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1105.Filling-Bookcase-Shelves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1105.Filling-Bookcase-Shelves/</guid><description>1105. Filling Bookcase Shelves # 题目 # We have a sequence of books: the i-th book has thickness books[i][0]and height books[i][1].
We want to place these books in order onto bookcase shelves that have total width shelf_width.
We choose some of the books to place on this shelf (such that the sum of their thickness is &amp;lt;= shelf_width), then build another level of shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1108.Defanging-an-IP-Address/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1108.Defanging-an-IP-Address/</guid><description>1108. Defanging an IP Address # 题目 # Given a valid (IPv4) IP address, return a defanged version of that IP address.
A defanged IP address replaces every period &amp;quot;.&amp;quot; with &amp;quot;[.]&amp;quot;.
Example 1:
Input: address = &amp;quot;1.1.1.1&amp;quot; Output: &amp;quot;1[.]1[.]1[.]1&amp;quot; Example 2:
Input: address = &amp;quot;255.100.50.0&amp;quot; Output: &amp;quot;255[.]100[.]50[.]0&amp;quot; Constraints:
The given address is a valid IPv4 address. 题目大意 # 给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。所谓无效化 IP 地址，其实就是用 &amp;ldquo;[.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1110.Delete-Nodes-And-Return-Forest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1110.Delete-Nodes-And-Return-Forest/</guid><description>1110. Delete Nodes And Return Forest # 题目 # Given the root of a binary tree, each node in the tree has a distinct value.
After deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).
Return the roots of the trees in the remaining forest. You may return the result in any order.
Example 1:
Input: root = [1,2,3,4,5,6,7], to_delete = [3,5] Output: [[1,2,null,4],[6],[7]] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1111.Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1111.Maximum-Nesting-Depth-of-Two-Valid-Parentheses-Strings/</guid><description>1111. Maximum Nesting Depth of Two Valid Parentheses Strings # 题目 # A string is a valid parentheses string (denoted VPS) if and only if it consists of &amp;quot;(&amp;quot; and &amp;quot;)&amp;quot; characters only, and:
It is the empty string, or It can be written as AB (A concatenated with B), where A and B are VPS&amp;rsquo;s, or It can be written as (A), where A is a VPS.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1122.Relative-Sort-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1122.Relative-Sort-Array/</guid><description>1122. Relative Sort Array # 题目 # Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.
Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that don&amp;rsquo;t appear in arr2 should be placed at the end of arr1 in ascending order.
Example 1:
Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1123.Lowest-Common-Ancestor-of-Deepest-Leaves/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1123.Lowest-Common-Ancestor-of-Deepest-Leaves/</guid><description>1123. Lowest Common Ancestor of Deepest Leaves # 题目 # Given a rooted binary tree, return the lowest common ancestor of its deepest leaves.
Recall that:
The node of a binary tree is a leaf if and only if it has no children The depth of the root of the tree is 0, and if the depth of a node is d, the depth of each of its children is d+1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1128.Number-of-Equivalent-Domino-Pairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1128.Number-of-Equivalent-Domino-Pairs/</guid><description>1128. Number of Equivalent Domino Pairs # 题目 # Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a==c and b==d), or (a==d and b==c) - that is, one domino can be rotated to be equal to another domino.
Return the number of pairs (i, j) for which 0 &amp;lt;= i &amp;lt; j &amp;lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1137.N-th-Tribonacci-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1137.N-th-Tribonacci-Number/</guid><description>1137. N-th Tribonacci Number # 题目 # The Tribonacci sequence Tn is defined as follows:
T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &amp;gt;= 0.
Given n, return the value of Tn.
Example 1:
Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1143.Longest-Common-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1143.Longest-Common-Subsequence/</guid><description>1143. Longest Common Subsequence # 题目 # Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.
A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.
For example, &amp;quot;ace&amp;quot; is a subsequence of &amp;quot;abcde&amp;quot;. A common subsequence of two strings is a subsequence that is common to both strings.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1145.Binary-Tree-Coloring-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1145.Binary-Tree-Coloring-Game/</guid><description>1145. Binary Tree Coloring Game # 题目 # Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n.
Initially, the first player names a value x with 1 &amp;lt;= x &amp;lt;= n, and the second player names a value y with 1 &amp;lt;= y &amp;lt;= n and y !</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1154.Day-of-the-Year/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1154.Day-of-the-Year/</guid><description>1154. Day of the Year # 题目 # Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.
Example 1:
Input: date = &amp;quot;2019-01-09&amp;quot; Output: 9 Explanation: Given date is the 9th day of the year in 2019. Example 2:
Input: date = &amp;quot;2019-02-10&amp;quot; Output: 41 Example 3:
Input: date = &amp;quot;2003-03-01&amp;quot; Output: 60 Example 4:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1157.Online-Majority-Element-In-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1157.Online-Majority-Element-In-Subarray/</guid><description>1157. Online Majority Element In Subarray # 题目 # Implementing the class MajorityChecker, which has the following API:
MajorityChecker(int[] arr) constructs an instance of MajorityChecker with the given array arr; int query(int left, int right, int threshold) has arguments such that: 0 &amp;lt;= left &amp;lt;= right &amp;lt; arr.length representing a subarray of arr; 2 * threshold &amp;gt; right - left + 1, ie. the threshold is always a strict majority of the length of the subarray Each query(.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1160.Find-Words-That-Can-Be-Formed-by-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1160.Find-Words-That-Can-Be-Formed-by-Characters/</guid><description>1160. Find Words That Can Be Formed by Characters # 题目 # You are given an array of strings words and a string chars.
A string is good if it can be formed by characters from chars (each character can only be used once).
Return the sum of lengths of all good strings in words.
Example 1:
Input: words = [&amp;quot;cat&amp;quot;,&amp;quot;bt&amp;quot;,&amp;quot;hat&amp;quot;,&amp;quot;tree&amp;quot;], chars = &amp;quot;atach&amp;quot; Output: 6 Explanation: The strings that can be formed are &amp;quot;cat&amp;quot; and &amp;quot;hat&amp;quot; so the answer is 3 + 3 = 6.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1170.Compare-Strings-by-Frequency-of-the-Smallest-Character/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1170.Compare-Strings-by-Frequency-of-the-Smallest-Character/</guid><description>1170. Compare Strings by Frequency of the Smallest Character # 题目 # Let&amp;rsquo;s define a function f(s) over a non-empty string s, which calculates the frequency of the smallest character in s. For example, if s = &amp;quot;dcce&amp;quot; then f(s) = 2 because the smallest character is &amp;quot;c&amp;quot; and its frequency is 2.
Now, given string arrays queries and words, return an integer array answer, where each answer[i] is the number of words such that f(queries[i]) &amp;lt; f(W), where W is a word in words.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1171.Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1171.Remove-Zero-Sum-Consecutive-Nodes-from-Linked-List/</guid><description>1171. Remove Zero Sum Consecutive Nodes from Linked List # 题目 # Given the head of a linked list, we repeatedly delete consecutive sequences of nodes that sum to 0 until there are no such sequences.
After doing so, return the head of the final linked list. You may return any such answer.
(Note that in the examples below, all sequences are serializations of ListNode objects.)
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1175.Prime-Arrangements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1175.Prime-Arrangements/</guid><description>1175. Prime Arrangements # 题目 # Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)
(Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.)
Since the answer may be large, return the answer modulo 10^9 + 7.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1178.Number-of-Valid-Words-for-Each-Puzzle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1178.Number-of-Valid-Words-for-Each-Puzzle/</guid><description>1178. Number of Valid Words for Each Puzzle # 题目 # With respect to a given puzzle string, a word is valid if both the following conditions are satisfied:
word contains the first letter of puzzle. For each letter in word, that letter is in puzzle.For example, if the puzzle is &amp;ldquo;abcdefg&amp;rdquo;, then valid words are &amp;ldquo;faced&amp;rdquo;, &amp;ldquo;cabbage&amp;rdquo;, and &amp;ldquo;baggage&amp;rdquo;; while invalid words are &amp;ldquo;beefed&amp;rdquo; (doesn&amp;rsquo;t include &amp;ldquo;a&amp;rdquo;) and &amp;ldquo;based&amp;rdquo; (includes &amp;ldquo;s&amp;rdquo; which isn&amp;rsquo;t in the puzzle).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1184.Distance-Between-Bus-Stops/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1184.Distance-Between-Bus-Stops/</guid><description>1184. Distance Between Bus Stops # 题目 # A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.
The bus goes along both directions i.e. clockwise and counterclockwise.
Return the shortest distance between the given start and destination stops.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1185.Day-of-the-Week/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1185.Day-of-the-Week/</guid><description>1185. Day of the Week # 题目 # Given a date, return the corresponding day of the week for that date.
The input is given as three integers representing the day, month and year respectively.
Return the answer as one of the following values {&amp;quot;Sunday&amp;quot;, &amp;quot;Monday&amp;quot;, &amp;quot;Tuesday&amp;quot;, &amp;quot;Wednesday&amp;quot;, &amp;quot;Thursday&amp;quot;, &amp;quot;Friday&amp;quot;, &amp;quot;Saturday&amp;quot;}.
Example 1:
Input: day = 31, month = 8, year = 2019 Output: &amp;quot;Saturday&amp;quot; Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1189.Maximum-Number-of-Balloons/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1189.Maximum-Number-of-Balloons/</guid><description>1189. Maximum Number of Balloons # 题目 # Given a string text, you want to use the characters of text to form as many instances of the word &amp;ldquo;balloon&amp;rdquo; as possible.
You can use each character in text at most once. Return the maximum number of instances that can be formed.
Example 1:
Input: text = &amp;quot;nlaebolko&amp;quot; Output: 1 Example 2:
Input: text = &amp;quot;loonbalxballpoon&amp;quot; Output: 2 Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1190.Reverse-Substrings-Between-Each-Pair-of-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1100~1199/1190.Reverse-Substrings-Between-Each-Pair-of-Parentheses/</guid><description>1190. Reverse Substrings Between Each Pair of Parentheses # 题目 # You are given a string s that consists of lower case English letters and brackets.
Reverse the strings in each pair of matching parentheses, starting from the innermost one.
Your result should not contain any brackets.
Example 1:
Input: s = &amp;quot;(abcd)&amp;quot; Output: &amp;quot;dcba&amp;quot; Example 2:
Input: s = &amp;quot;(u(love)i)&amp;quot; Output: &amp;quot;iloveu&amp;quot; Explanation: The substring &amp;quot;love&amp;quot; is reversed first, then the whole string is reversed.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1200.Minimum-Absolute-Difference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1200.Minimum-Absolute-Difference/</guid><description>1200. Minimum Absolute Difference # 题目 # Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements.
Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows
a, b are from arr a &amp;lt; b b - a equals to the minimum absolute difference of any two elements in arr Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1201.Ugly-Number-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1201.Ugly-Number-III/</guid><description>1201. Ugly Number III # 题目 # Write a program to find the n-th ugly number.
Ugly numbers are positive integers which are divisible by a or b or c.
Example 1:
Input: n = 3, a = 2, b = 3, c = 5 Output: 4 Explanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4. Example 2:
Input: n = 4, a = 2, b = 3, c = 4 Output: 6 Explanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1202.Smallest-String-With-Swaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1202.Smallest-String-With-Swaps/</guid><description>1202. Smallest String With Swaps # 题目 # You are given a string s, and an array of pairs of indices in the string pairs where pairs[i] = [a, b] indicates 2 indices(0-indexed) of the string.
You can swap the characters at any pair of indices in the given pairs any number of times.
Return the lexicographically smallest string that s can be changed to after using the swaps.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1203.Sort-Items-by-Groups-Respecting-Dependencies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1203.Sort-Items-by-Groups-Respecting-Dependencies/</guid><description>1203. Sort Items by Groups Respecting Dependencies # 题目 # There are n items each belonging to zero or one of m groups where group[i] is the group that the i-th item belongs to and it&amp;rsquo;s equal to -1 if the i-th item belongs to no group. The items and the groups are zero indexed. A group can have no item belonging to it.
Return a sorted list of the items such that:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1207.Unique-Number-of-Occurrences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1207.Unique-Number-of-Occurrences/</guid><description>1207. Unique Number of Occurrences # 题目 # Given an array of integers arr, write a function that returns true if and only if the number of occurrences of each value in the array is unique.
Example 1:
Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1208.Get-Equal-Substrings-Within-Budget/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1208.Get-Equal-Substrings-Within-Budget/</guid><description>1208. Get Equal Substrings Within Budget # 题目 # You are given two strings s and t of the same length. You want to change s to t. Changing the i-th character of s to i-th character of t costs |s[i] - t[i]| that is, the absolute difference between the ASCII values of the characters.
You are also given an integer maxCost.
Return the maximum length of a substring of s that can be changed to be the same as the corresponding substring of twith a cost less than or equal to maxCost.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1209.Remove-All-Adjacent-Duplicates-in-String-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1209.Remove-All-Adjacent-Duplicates-in-String-II/</guid><description>1209. Remove All Adjacent Duplicates in String II # 题目 # Given a string s, a k duplicate removal consists of choosing k adjacent and equal letters from s and removing them causing the left and the right side of the deleted substring to concatenate together.
We repeatedly make k duplicate removals on s until we no longer can.
Return the final string after all such duplicate removals have been made.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1217.Minimum-Cost-to-Move-Chips-to-The-Same-Position/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1217.Minimum-Cost-to-Move-Chips-to-The-Same-Position/</guid><description>1217. Minimum Cost to Move Chips to The Same Position # 题目 # There are some chips, and the i-th chip is at position chips[i].
You can perform any of the two following types of moves any number of times (possibly zero) on any chip:
Move the i-th chip by 2 units to the left or to the right with a cost of 0. Move the i-th chip by 1 unit to the left or to the right with a cost of 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1221.Split-a-String-in-Balanced-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1221.Split-a-String-in-Balanced-Strings/</guid><description>1221. Split a String in Balanced Strings # 题目 # Balanced strings are those who have equal quantity of &amp;lsquo;L&amp;rsquo; and &amp;lsquo;R&amp;rsquo; characters.
Given a balanced string s split it in the maximum amount of balanced strings.
Return the maximum amount of splitted balanced strings.
Example 1:
Input: s = &amp;quot;RLRRLLRLRL&amp;quot; Output: 4 Explanation: s can be split into &amp;quot;RL&amp;quot;, &amp;quot;RRLL&amp;quot;, &amp;quot;RL&amp;quot;, &amp;quot;RL&amp;quot;, each substring contains same number of 'L' and 'R'.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1232.Check-If-It-Is-a-Straight-Line/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1232.Check-If-It-Is-a-Straight-Line/</guid><description>1232. Check If It Is a Straight Line # 题目 # You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane.
Example 1:
Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] Output: true Example 2:
Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] Output: false Constraints:
2 &amp;lt;= coordinates.length &amp;lt;= 1000 coordinates[i].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1234.Replace-the-Substring-for-Balanced-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1234.Replace-the-Substring-for-Balanced-String/</guid><description>1234. Replace the Substring for Balanced String # 题目 # You are given a string containing only 4 kinds of characters 'Q', 'W', 'E' and 'R'.
A string is said to be balanced **if each of its characters appears n/4 times where n is the length of the string.
Return the minimum length of the substring that can be replaced with any other string of the same length to make the original string s balanced.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1235.Maximum-Profit-in-Job-Scheduling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1235.Maximum-Profit-in-Job-Scheduling/</guid><description>1235. Maximum Profit in Job Scheduling # 题目 # We have n jobs, where every job is scheduled to be done from startTime[i] to endTime[i], obtaining a profit of profit[i].
You&amp;rsquo;re given the startTime , endTime and profit arrays, you need to output the maximum profit you can take such that there are no 2 jobs in the subset with overlapping time range.
If you choose a job that ends at time X you will be able to start another job that starts at time X.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1239.Maximum-Length-of-a-Concatenated-String-with-Unique-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1239.Maximum-Length-of-a-Concatenated-String-with-Unique-Characters/</guid><description>1239. Maximum Length of a Concatenated String with Unique Characters # 题目 # Given an array of strings arr. String s is a concatenation of a sub-sequence of arr which have unique characters.
Return the maximum possible length of s.
Example 1:
Input: arr = [&amp;quot;un&amp;quot;,&amp;quot;iq&amp;quot;,&amp;quot;ue&amp;quot;] Output: 4 Explanation: All possible concatenations are &amp;quot;&amp;quot;,&amp;quot;un&amp;quot;,&amp;quot;iq&amp;quot;,&amp;quot;ue&amp;quot;,&amp;quot;uniq&amp;quot; and &amp;quot;ique&amp;quot;. Maximum length is 4. Example 2:
Input: arr = [&amp;quot;cha&amp;quot;,&amp;quot;r&amp;quot;,&amp;quot;act&amp;quot;,&amp;quot;ers&amp;quot;] Output: 6 Explanation: Possible solutions are &amp;quot;chaers&amp;quot; and &amp;quot;acters&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1249.Minimum-Remove-to-Make-Valid-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1249.Minimum-Remove-to-Make-Valid-Parentheses/</guid><description>1249. Minimum Remove to Make Valid Parentheses # 题目 # Given a string s of '(' , ')' and lowercase English characters.
Your task is to remove the minimum number of parentheses ( '(' or ')', in any positions ) so that the resulting parentheses string is valid and return any valid string.
Formally, a parentheses string is valid if and only if:
It is the empty string, contains only lowercase characters, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1252.Cells-with-Odd-Values-in-a-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1252.Cells-with-Odd-Values-in-a-Matrix/</guid><description>1252. Cells with Odd Values in a Matrix # 题目 # Given n and m which are the dimensions of a matrix initialized by zeros and given an array indices where indices[i] = [ri, ci]. For each pair of [ri, ci] you have to increment all cells in row ri and column ci by 1.
Return the number of cells with odd values in the matrix after applying the increment to all indices.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1254.Number-of-Closed-Islands/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1254.Number-of-Closed-Islands/</guid><description>1254. Number of Closed Islands # 题目 # Given a 2D grid consists of 0s (land) and 1s (water). An island is a maximal 4-directionally connected group of 0s and a closed island is an island totally (all left, top, right, bottom) surrounded by 1s.
Return the number of closed islands.
Example 1:
Input: grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]] Output: 2 Explanation: Islands in gray are closed because they are completely surrounded by water (group of 1s).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1260.Shift-2D-Grid/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1260.Shift-2D-Grid/</guid><description>1260. Shift 2D Grid # 题目 # Given a 2D grid of size m x n and an integer k. You need to shift the grid k times.
In one shift operation:
Element at grid[i][j] moves to grid[i][j + 1]. Element at grid[i][n - 1] moves to grid[i + 1][0]. Element at grid[m - 1][n - 1] moves to grid[0][0]. Return the 2D grid after applying shift operation k times.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1266.Minimum-Time-Visiting-All-Points/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1266.Minimum-Time-Visiting-All-Points/</guid><description>1266. Minimum Time Visiting All Points # 题目 # On a plane there are n points with integer coordinates points[i] = [xi, yi]. Your task is to find the minimum time in seconds to visit all points.
You can move according to the next rules:
In one second always you can either move vertically, horizontally by one unit or diagonally (it means to move one unit vertically and one unit horizontally in one second).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1268.Search-Suggestions-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1268.Search-Suggestions-System/</guid><description>1268. Search Suggestions System # 题目 # Given an array of strings products and a string searchWord. We want to design a system that suggests at most three product names from products after each character of searchWord is typed. Suggested products should have common prefix with the searchWord. If there are more than three products with a common prefix return the three lexicographically minimums products.
Return list of lists of the suggested products after each character of searchWord is typed.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1275.Find-Winner-on-a-Tic-Tac-Toe-Game/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1275.Find-Winner-on-a-Tic-Tac-Toe-Game/</guid><description>1275. Find Winner on a Tic Tac Toe Game # 题目 # Tic-tac-toe is played by two players A and B on a 3 x 3 grid.
Here are the rules of Tic-Tac-Toe:
Players take turns placing characters into empty squares (&amp;rdquo; &amp;ldquo;). The first player A always places &amp;ldquo;X&amp;rdquo; characters, while the second player B always places &amp;ldquo;O&amp;rdquo; characters. &amp;ldquo;X&amp;rdquo; and &amp;ldquo;O&amp;rdquo; characters are always placed into empty squares, never on filled ones.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1281.Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1281.Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/</guid><description>1281. Subtract the Product and Sum of Digits of an Integer # 题目 # Given an integer number n, return the difference between the product of its digits and the sum of its digits.
Example 1:
Input: n = 234 Output: 15 Explanation: Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 - 9 = 15 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1283.Find-the-Smallest-Divisor-Given-a-Threshold/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1283.Find-the-Smallest-Divisor-Given-a-Threshold/</guid><description>1283. Find the Smallest Divisor Given a Threshold # 题目 # Given an array of integers nums and an integer threshold, we will choose a positive integer divisor and divide all the array by it and sum the result of the division. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.
Each result of division is rounded to the nearest integer greater than or equal to that element.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1287.Element-Appearing-More-Than-25-In-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1287.Element-Appearing-More-Than-25-In-Sorted-Array/</guid><description>1287. Element Appearing More Than 25% In Sorted Array # 题目 # Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time.
Return that integer.
Example 1:
Input: arr = [1,2,2,6,6,6,6,7,10] Output: 6 Constraints:
1 &amp;lt;= arr.length &amp;lt;= 10^4 0 &amp;lt;= arr[i] &amp;lt;= 10^5 题目大意 # 给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。请你找到并返回这个整数。
提示：</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1290.Convert-Binary-Number-in-a-Linked-List-to-Integer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1290.Convert-Binary-Number-in-a-Linked-List-to-Integer/</guid><description>1290. Convert Binary Number in a Linked List to Integer # 题目 # Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.
Return the decimal value of the number in the linked list.
Example 1:
Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1293.Shortest-Path-in-a-Grid-with-Obstacles-Elimination/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1293.Shortest-Path-in-a-Grid-with-Obstacles-Elimination/</guid><description>1293. Shortest Path in a Grid with Obstacles Elimination # 题目 # You are given an m x n integer matrix grid where each cell is either 0 (empty) or 1 (obstacle). You can move up, down, left, or right from and to an empty cell in one step.
Return the minimum number of steps to walk from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1) given that you can eliminate at most k obstacles.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1295.Find-Numbers-with-Even-Number-of-Digits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1295.Find-Numbers-with-Even-Number-of-Digits/</guid><description>1295. Find Numbers with Even Number of Digits # 题目 # Given an array nums of integers, return how many of them contain an even number of digits.
Example 1:
Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1296.Divide-Array-in-Sets-of-K-Consecutive-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1296.Divide-Array-in-Sets-of-K-Consecutive-Numbers/</guid><description>1296. Divide Array in Sets of K Consecutive Numbers # 题目 # Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.
Return true if it is possible. Otherwise, return false.
Example 1:
Input: nums = [1,2,3,3,4,4,5,6], k = 4 Output: true Explanation: Array can be divided into [1,2,3,4] and [3,4,5,6]. Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1299.Replace-Elements-with-Greatest-Element-on-Right-Side/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1200~1299/1299.Replace-Elements-with-Greatest-Element-on-Right-Side/</guid><description>1299. Replace Elements with Greatest Element on Right Side # 题目 # Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1.
After doing so, return the array.
Example 1:
Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Constraints:
1 &amp;lt;= arr.length &amp;lt;= 10^4 1 &amp;lt;= arr[i] &amp;lt;= 10^5 题目大意 # 给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。完成所有替换操作后，请你返回这个数组。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1300.Sum-of-Mutated-Array-Closest-to-Target/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1300.Sum-of-Mutated-Array-Closest-to-Target/</guid><description>1300. Sum of Mutated Array Closest to Target # 题目 # Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.
In case of a tie, return the minimum such integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1302.Deepest-Leaves-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1302.Deepest-Leaves-Sum/</guid><description>1302. Deepest Leaves Sum # 题目 # Given a binary tree, return the sum of values of its deepest leaves.
Example 1:
Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8] Output: 15 Constraints:
The number of nodes in the tree is between 1 and 10^4. The value of nodes is between 1 and 100. 题目大意 # 给你一棵二叉树，请你返回层数最深的叶子节点的和。
提示：
树中节点数目在 1 到 10^4 之间。 每个节点的值在 1 到 100 之间。 解题思路 # 给你一棵二叉树，请你返回层数最深的叶子节点的和。 这一题不难，DFS 遍历把最底层的叶子节点和都加起来即可。 代码 # func deepestLeavesSum(root *TreeNode) int { maxLevel, sum := 0, 0 dfsDeepestLeavesSum(root, 0, &amp;amp;maxLevel, &amp;amp;sum) return sum } func dfsDeepestLeavesSum(root *TreeNode, level int, maxLevel, sum *int) { if root == nil { return } if level &amp;gt; *maxLevel { *maxLevel, *sum = level, root.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1304.Find-N-Unique-Integers-Sum-up-to-Zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1304.Find-N-Unique-Integers-Sum-up-to-Zero/</guid><description>1304. Find N Unique Integers Sum up to Zero # 题目 # Given an integer n, return any array containing n unique integers such that they add up to 0.
Example 1:
Input: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2:
Input: n = 3 Output: [-1,0,1] Example 3:
Input: n = 1 Output: [0] Constraints:
1 &amp;lt;= n &amp;lt;= 1000 题目大意 # 给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1305.All-Elements-in-Two-Binary-Search-Trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1305.All-Elements-in-Two-Binary-Search-Trees/</guid><description>1305. All Elements in Two Binary Search Trees # 题目 # Given two binary search trees root1 and root2.
Return a list containing all the integers from both trees sorted in ascending order.
Example 1:
Input: root1 = [2,1,4], root2 = [1,0,3] Output: [0,1,1,2,3,4] Example 2:
Input: root1 = [0,-10,10], root2 = [5,1,7,0,2] Output: [-10,0,0,1,2,5,7,10] Example 3:
Input: root1 = [], root2 = [5,1,7,0,2] Output: [0,1,2,5,7] Example 4:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1306.Jump-Game-III/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1306.Jump-Game-III/</guid><description>1306. Jump Game III # 题目 # Given an array of non-negative integers arr, you are initially positioned at start index of the array. When you are at index i, you can jump to i + arr[i] or i - arr[i], check if you can reach to any index with value 0.
Notice that you can not jump outside of the array at any time.
Example 1:
Input: arr = [4,2,3,0,3,1,2], start = 5 Output: true Explanation: All possible ways to reach at index 3 with value 0 are: index 5 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 index 5 -&amp;gt; index 6 -&amp;gt; index 4 -&amp;gt; index 1 -&amp;gt; index 3 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1310.XOR-Queries-of-a-Subarray/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1310.XOR-Queries-of-a-Subarray/</guid><description>1310. XOR Queries of a Subarray # 题目 # Given the array arr of positive integers and the array queries where queries[i] = [Li,Ri], for each query i compute the XOR of elements from Li to Ri (that is, arr[Li]xor arr[Li+1]xor ...xor arr[Ri]). Return an array containing the result for the given queries.
Example 1:
Input: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]] Output: [2,7,14,8] Explanation: The binary representation of the elements in the array are: 1 = 0001 3 = 0011 4 = 0100 8 = 1000 The XOR values for queries are: [0,1] = 1 xor 3 = 2 [1,2] = 3 xor 4 = 7 [0,3] = 1 xor 3 xor 4 xor 8 = 14 [3,3] = 8 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1313.Decompress-Run-Length-Encoded-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1313.Decompress-Run-Length-Encoded-List/</guid><description>1313. Decompress Run-Length Encoded List # 题目 # We are given a list nums of integers representing a list compressed with run-length encoding.
Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i &amp;gt;= 0). For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list.
Return the decompressed list.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1317.Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1317.Convert-Integer-to-the-Sum-of-Two-No-Zero-Integers/</guid><description>1317. Convert Integer to the Sum of Two No-Zero Integers # 题目 # Given an integer n. No-Zero integer is a positive integer which doesn&amp;rsquo;t contain any 0 in its decimal representation.
Return a list of two integers [A, B] where:
A and B are No-Zero integers. A + B = n It&amp;rsquo;s guarateed that there is at least one valid solution. If there are many valid solutions you can return any of them.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1319.Number-of-Operations-to-Make-Network-Connected/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1319.Number-of-Operations-to-Make-Network-Connected/</guid><description>1319. Number of Operations to Make Network Connected # 题目 # There are n computers numbered from 0 to n-1 connected by ethernet cables connections forming a network where connections[i] = [a, b] represents a connection between computers a and b. Any computer can reach any other computer directly or indirectly through the network.
Given an initial computer network connections. You can extract certain cables between two directly connected computers, and place them between any pair of disconnected computers to make them directly connected.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1329.Sort-the-Matrix-Diagonally/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1329.Sort-the-Matrix-Diagonally/</guid><description>1329. Sort the Matrix Diagonally # 题目 # A matrix diagonal is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix&amp;rsquo;s end. For example, the matrix diagonal starting from mat[2][0], where mat is a 6 x 3 matrix, includes cells mat[2][0], mat[3][1], and mat[4][2].
Given an m x n matrix mat of integers, sort each matrix diagonal in ascending order and return the resulting matrix.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1332.Remove-Palindromic-Subsequences/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1332.Remove-Palindromic-Subsequences/</guid><description>1332. Remove Palindromic Subsequences # 题目 # Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.
Return the minimum number of steps to make the given string empty.
A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.
A string is called palindrome if is one that reads the same backward as well as forward.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1337.The-K-Weakest-Rows-in-a-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1337.The-K-Weakest-Rows-in-a-Matrix/</guid><description>1337. The K Weakest Rows in a Matrix # 题目 # Given a m * n matrix mat of ones (representing soldiers) and zeros (representing civilians), return the indexes of the k weakest rows in the matrix ordered from the weakest to the strongest.
A row i is weaker than row j, if the number of soldiers in row i is less than the number of soldiers in row j, or they have the same number of soldiers but i is less than j.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1353.Maximum-Number-of-Events-That-Can-Be-Attended/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1353.Maximum-Number-of-Events-That-Can-Be-Attended/</guid><description>1353. Maximum Number of Events That Can Be Attended # 题目 # Given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at startDayi and ends at endDayi.
You can attend an event i at any day d where startTimei &amp;lt;= d &amp;lt;= endTimei. Notice that you can only attend one event at any time d.
Return the maximum number of events you can attend.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1380.Lucky-Numbers-in-a-Matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1380.Lucky-Numbers-in-a-Matrix/</guid><description>1380. Lucky Numbers in a Matrix # 题目 # Given a m * n matrix of distinct numbers, return all lucky numbers in the matrix in any order.
A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.
Example 1:
Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1383.Maximum-Performance-of-a-Team/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1383.Maximum-Performance-of-a-Team/</guid><description>1383. Maximum Performance of a Team # 题目 # You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.
Choose at most k different engineers out of the n engineers to form a team with the maximum performance.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1385.Find-the-Distance-Value-Between-Two-Arrays/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1385.Find-the-Distance-Value-Between-Two-Arrays/</guid><description>1385. Find the Distance Value Between Two Arrays # 题目 # Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays.
The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where |arr1[i]-arr2[j]| &amp;lt;= d.
Example 1:
Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 Output: 2 Explanation: For arr1[0]=4 we have: |4-10|=6 &amp;gt; d=2 |4-9|=5 &amp;gt; d=2 |4-1|=3 &amp;gt; d=2 |4-8|=4 &amp;gt; d=2 For arr1[1]=5 we have: |5-10|=5 &amp;gt; d=2 |5-9|=4 &amp;gt; d=2 |5-1|=4 &amp;gt; d=2 |5-8|=3 &amp;gt; d=2 For arr1[2]=8 we have: |8-10|=2 &amp;lt;= d=2 |8-9|=1 &amp;lt;= d=2 |8-1|=7 &amp;gt; d=2 |8-8|=0 &amp;lt;= d=2 Example 2:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1389.Create-Target-Array-in-the-Given-Order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1389.Create-Target-Array-in-the-Given-Order/</guid><description>1389. Create Target Array in the Given Order # 题目 # Given two arrays of integers nums and index. Your task is to create target array under the following rules:
Initially target array is empty. From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array. Repeat the previous step until there are no elements to read in nums and index.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1396.Design-Underground-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1300~1399/1396.Design-Underground-System/</guid><description>1396. Design Underground System # 题目 # Implement the UndergroundSystem class:
void checkIn(int id, string stationName, int t) A customer with a card id equal to id, gets in the station stationName at time t. A customer can only be checked into one place at a time. void checkOut(int id, string stationName, int t) A customer with a card id equal to id, gets out from the station stationName at time t.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1423.Maximum-Points-You-Can-Obtain-from-Cards/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1423.Maximum-Points-You-Can-Obtain-from-Cards/</guid><description>1423. Maximum Points You Can Obtain from Cards # 题目 # There are several cards arranged in a row, and each card has an associated number of points The points are given in the integer array cardPoints.
In one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.
Your score is the sum of the points of the cards you have taken.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1437.Check-If-All-1s-Are-at-Least-Length-K-Places-Away/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1437.Check-If-All-1s-Are-at-Least-Length-K-Places-Away/</guid><description>1437. Check If All 1&amp;rsquo;s Are at Least Length K Places Away # 题目 # Given an array nums of 0s and 1s and an integer k, return True if all 1&amp;rsquo;s are at least k places away from each other, otherwise return False.
Example 1:
Input: nums = [1,0,0,0,1,0,0,1], k = 2 Output: true Explanation: Each of the 1s are at least 2 places away from each other.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1438.Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1438.Longest-Continuous-Subarray-With-Absolute-Diff-Less-Than-or-Equal-to-Limit/</guid><description>1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit # 题目 # Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit*.*
Example 1:
Input: nums = [8,2,4,7], limit = 4 Output: 2 Explanation: All subarrays are: [8] with maximum absolute diff |8-8| = 0 &amp;lt;= 4.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1439.Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1439.Find-the-Kth-Smallest-Sum-of-a-Matrix-With-Sorted-Rows/</guid><description>1439. Find the Kth Smallest Sum of a Matrix With Sorted Rows # 题目 # You are given an m * n matrix, mat, and an integer k, which has its rows sorted in non-decreasing order.
You are allowed to choose exactly 1 element from each row to form an array. Return the Kth smallest array sum among all possible arrays.
Example 1:
Input: mat = [[1,3,11],[2,4,6]], k = 5 Output: 7 Explanation: Choosing one element from each row, the first k smallest sum are: [1,2], [1,4], [3,2], [3,4], [1,6].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1442.Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1442.Count-Triplets-That-Can-Form-Two-Arrays-of-Equal-XOR/</guid><description>1442. Count Triplets That Can Form Two Arrays of Equal XOR # 题目 # Given an array of integers arr.
We want to select three indices i, j and k where (0 &amp;lt;= i &amp;lt; j &amp;lt;= k &amp;lt; arr.length).
Let&amp;rsquo;s define a and b as follows:
a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1] b = arr[j] ^ arr[j + 1] ^ .</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1446.Consecutive-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1446.Consecutive-Characters/</guid><description>1446. Consecutive Characters # 题目 # The power of the string is the maximum length of a non-empty substring that contains only one unique character.
Given a string s, return the power of s.
Example 1:
Input: s = &amp;quot;leetcode&amp;quot; Output: 2 Explanation: The substring &amp;quot;ee&amp;quot; is of length 2 with the character 'e' only. Example 2:
Input: s = &amp;quot;abbcccddddeeeeedcba&amp;quot; Output: 5 Explanation: The substring &amp;quot;eeeee&amp;quot; is of length 5 with the character 'e' only.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1455.Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1455.Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/</guid><description>1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence # 题目 # Given a sentence that consists of some words separated by a single space, and a searchWord.
You have to check if searchWord is a prefix of any word in sentence.
Return the index of the word in sentence where searchWord is a prefix of this word (1-indexed).
If searchWord is a prefix of more than one word, return the index of the first word (minimum index).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1461.Check-If-a-String-Contains-All-Binary-Codes-of-Size-K/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1461.Check-If-a-String-Contains-All-Binary-Codes-of-Size-K/</guid><description>1461. Check If a String Contains All Binary Codes of Size K # 题目 # Given a binary string s and an integer k.
Return True if every binary code of length k is a substring of s. Otherwise, return False.
Example 1:
Input: s = &amp;quot;00110110&amp;quot;, k = 2 Output: true Explanation: The binary codes of length 2 are &amp;quot;00&amp;quot;, &amp;quot;01&amp;quot;, &amp;quot;10&amp;quot; and &amp;quot;11&amp;quot;. They can be all found as substrings at indicies 0, 1, 3 and 2 respectively.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1463.Cherry-Pickup-II/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1463.Cherry-Pickup-II/</guid><description>1463. Cherry Pickup II # 题目 # Given a rows x cols matrix grid representing a field of cherries. Each cell in grid represents the number of cherries that you can collect.
You have two robots that can collect cherries for you, Robot #1 is located at the top-left corner (0,0) , and Robot #2 is located at the top-right corner (0, cols-1) of the grid.
Return the maximum number of cherries collection using both robots by following the rules below:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1464.Maximum-Product-of-Two-Elements-in-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1464.Maximum-Product-of-Two-Elements-in-an-Array/</guid><description>1464. Maximum Product of Two Elements in an Array # 题目 # Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).
Example 1:
Input: nums = [3,4,5,2] Output: 12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1465.Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1465.Maximum-Area-of-a-Piece-of-Cake-After-Horizontal-and-Vertical-Cuts/</guid><description>1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts # 题目 # Given a rectangular cake with height h and width w, and two arrays of integers horizontalCuts and verticalCuts where horizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, verticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1470.Shuffle-the-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1470.Shuffle-the-Array/</guid><description>1470. Shuffle the Array # 题目 # Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn].
Return the array in the form [x1,y1,x2,y2,...,xn,yn].
Example 1:
Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2:
Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] Example 3:
Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] Constraints:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1480.Running-Sum-of-1d-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1480.Running-Sum-of-1d-Array/</guid><description>1480. Running Sum of 1d Array # 题目 # Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]).
Return the running sum of nums.
Example 1:
Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2:
Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1482.Minimum-Number-of-Days-to-Make-m-Bouquets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1482.Minimum-Number-of-Days-to-Make-m-Bouquets/</guid><description>1482. Minimum Number of Days to Make m Bouquets # 题目 # Given an integer array bloomDay, an integer m and an integer k.
We need to make m bouquets. To make a bouquet, you need to use k adjacent flowers from the garden.
The garden consists of n flowers, the ith flower will bloom in the bloomDay[i] and then can be used in exactly one bouquet.
Return the minimum number of days you need to wait to be able to make m bouquets from the garden.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1486.XOR-Operation-in-an-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1400~1499/1486.XOR-Operation-in-an-Array/</guid><description>1486. XOR Operation in an Array # 题目 # Given an integer n and an integer start.
Define an array nums where nums[i] = start + 2*i (0-indexed) and n == nums.length.
Return the bitwise XOR of all elements of nums.
Example 1:
Input: n = 5, start = 0 Output: 8 Explanation:Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1512.Number-of-Good-Pairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1512.Number-of-Good-Pairs/</guid><description>1512. Number of Good Pairs # 题目 # Given an array of integers nums.
A pair (i,j) is called good if nums[i] == nums[j] and i &amp;lt; j.
Return the number of good pairs.
Example 1:
Input: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. Example 2:
Input: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array are good.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1518.Water-Bottles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1518.Water-Bottles/</guid><description>1518. Water Bottles # 题目 # Given numBottles full water bottles, you can exchange numExchange empty water bottles for one full water bottle.
The operation of drinking a full water bottle turns it into an empty bottle.
Return the maximum number of water bottles you can drink.
Example 1:
Input: numBottles = 9, numExchange = 3 Output: 13 Explanation: You can exchange 3 empty bottles to get 1 full water bottle.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1539.Kth-Missing-Positive-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1539.Kth-Missing-Positive-Number/</guid><description>1539. Kth Missing Positive Number # 题目 # Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.
Find the kth positive integer that is missing from this array.
Example 1:
Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Example 2:
Input: arr = [1,2,3,4], k = 2 Output: 6 Explanation: The missing positive integers are [5,6,7,.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1551.Minimum-Operations-to-Make-Array-Equal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1551.Minimum-Operations-to-Make-Array-Equal/</guid><description>1551. Minimum Operations to Make Array Equal # 题目 # You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e. 0 &amp;lt;= i &amp;lt; n).
In one operation, you can select two indices x and y where 0 &amp;lt;= x, y &amp;lt; n and subtract 1 from arr[x] and add 1 to arr[y] (i.e. perform arr[x] -=1 and arr[y] += 1).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1572.Matrix-Diagonal-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1572.Matrix-Diagonal-Sum/</guid><description>1572. Matrix Diagonal Sum # 题目 # Given a square matrix mat, return the sum of the matrix diagonals.
Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.
Example 1:
Input: mat = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation:Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1573.Number-of-Ways-to-Split-a-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1573.Number-of-Ways-to-Split-a-String/</guid><description>1573. Number of Ways to Split a String # 题目 # Given a binary string s (a string consisting only of &amp;lsquo;0&amp;rsquo;s and &amp;lsquo;1&amp;rsquo;s), we can split s into 3 non-empty strings s1, s2, s3 (s1+ s2+ s3 = s).
Return the number of ways s can be split such that the number of characters &amp;lsquo;1&amp;rsquo; is the same in s1, s2, and s3.
Since the answer may be too large, return it modulo 10^9 + 7.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1576.Replace-All-s-to-Avoid-Consecutive-Repeating-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1576.Replace-All-s-to-Avoid-Consecutive-Repeating-Characters/</guid><description>1576. Replace All ?&amp;rsquo;s to Avoid Consecutive Repeating Characters # 题目 # Given a string s containing only lowercase English letters and the '?' character, convert all the '?' characters into lowercase letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non '?' characters.
It is guaranteed that there are no consecutive repeating characters in the given string except for '?</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1579.Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1500~1599/1579.Remove-Max-Number-of-Edges-to-Keep-Graph-Fully-Traversable/</guid><description>1579. Remove Max Number of Edges to Keep Graph Fully Traversable # 题目 # Alice and Bob have an undirected graph of n nodes and 3 types of edges:
Type 1: Can be traversed by Alice only. Type 2: Can be traversed by Bob only. Type 3: Can by traversed by both Alice and Bob. Given an array edges where edges[i] = [typei, ui, vi] represents a bidirectional edge of type typei between nodes ui and vi, find the maximum number of edges you can remove so that after removing the edges, the graph can still be fully traversed by both Alice and Bob.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1600.Throne-Inheritance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1600.Throne-Inheritance/</guid><description>1600. Throne Inheritance # 题目 # A kingdom consists of a king, his children, his grandchildren, and so on. Every once in a while, someone in the family dies or a child is born.
The kingdom has a well-defined order of inheritance that consists of the king as the first member. Let&amp;rsquo;s define the recursive function Successor(x, curOrder), which given a person x and the inheritance order so far, returns who should be the next person after x in the order of inheritance.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1603.Design-Parking-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1603.Design-Parking-System/</guid><description>1603. Design Parking System # 题目 # Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.
Implement the ParkingSystem class:
ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1608.Special-Array-With-X-Elements-Greater-Than-or-Equal-X/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1608.Special-Array-With-X-Elements-Greater-Than-or-Equal-X/</guid><description>1608. Special Array With X Elements Greater Than or Equal X # 题目 # You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.
Notice that x does not have to be an element in nums.
Return x if the array is special, otherwise, return -1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1609.Even-Odd-Tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1609.Even-Odd-Tree/</guid><description>1609. Even Odd Tree # 题目 # A binary tree is named Even-Odd if it meets the following conditions:
The root of the binary tree is at level index 0, its children are at level index 1, their children are at level index 2, etc. For every even-indexed level, all nodes at the level have odd integer values in strictly increasing order (from left to right). For every odd-indexed level, all nodes at the level have even integer values in strictly decreasing order (from left to right).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1614.Maximum-Nesting-Depth-of-the-Parentheses/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1614.Maximum-Nesting-Depth-of-the-Parentheses/</guid><description>1614. Maximum Nesting Depth of the Parentheses # 题目 # A string is a valid parentheses string (denoted VPS) if it meets one of the following:
It is an empty string &amp;quot;&amp;quot;, or a single character not equal to &amp;quot;(&amp;quot; or &amp;quot;)&amp;quot;, It can be written as AB (A concatenated with B), where A and B are VPS&amp;rsquo;s, or It can be written as (A), where A is a VPS.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1619.Mean-of-Array-After-Removing-Some-Elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1619.Mean-of-Array-After-Removing-Some-Elements/</guid><description>1619. Mean of Array After Removing Some Elements # 题目 # Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.
Answers within 10-5 of the actual answer will be considered accepted.
Example 1:
Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] Output: 2.00000 Explanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1624.Largest-Substring-Between-Two-Equal-Characters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1624.Largest-Substring-Between-Two-Equal-Characters/</guid><description>1624. Largest Substring Between Two Equal Characters # 题目 # Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.
A substring is a contiguous sequence of characters within a string.
Example 1:
Input: s = &amp;quot;aa&amp;quot; Output: 0 Explanation: The optimal substring here is an empty substring between the two 'a's.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1629.Slowest-Key/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1629.Slowest-Key/</guid><description>1629. Slowest Key # 题目 # A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.
You are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1631.Path-With-Minimum-Effort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1631.Path-With-Minimum-Effort/</guid><description>1631. Path With Minimum Effort # 题目 # You are a hiker preparing for an upcoming hike. You are given heights, a 2D array of size rows x columns, where heights[row][col] represents the height of cell (row, col). You are situated in the top-left cell, (0, 0), and you hope to travel to the bottom-right cell, (rows-1, columns-1) (i.e., 0-indexed). You can move up, down, left, or right, and you wish to find a route that requires the minimum effort.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1636.Sort-Array-by-Increasing-Frequency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1636.Sort-Array-by-Increasing-Frequency/</guid><description>1636. Sort Array by Increasing Frequency # 题目 # Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.
Return the sorted array.
Example 1:
Input: nums = [1,1,2,2,2,3] Output: [3,1,1,2,2,2] Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1640.Check-Array-Formation-Through-Concatenation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1640.Check-Array-Formation-Through-Concatenation/</guid><description>1640. Check Array Formation Through Concatenation # 题目 # You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].
Return true if it is possible to form the array arr from pieces.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1641.Count-Sorted-Vowel-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1641.Count-Sorted-Vowel-Strings/</guid><description>1641. Count Sorted Vowel Strings # 题目 # Given an integer n, return the number of strings of length n that consist only of vowels (a, e*,* i*,* o*,* u*) and are **lexicographically sorted**.*
A string s is lexicographically sorted if for all valid i, s[i] is the same as or comes before s[i+1] in the alphabet.
Example 1:
Input: n = 1 Output: 5 Explanation: The 5 sorted strings that consist of vowels only are [&amp;quot;a&amp;quot;,&amp;quot;e&amp;quot;,&amp;quot;i&amp;quot;,&amp;quot;o&amp;quot;,&amp;quot;u&amp;quot;].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1642.Furthest-Building-You-Can-Reach/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1642.Furthest-Building-You-Can-Reach/</guid><description>1642. Furthest Building You Can Reach # 题目 # You are given an integer array heights representing the heights of buildings, some bricks, and some ladders.
You start your journey from building 0 and move to the next building by possibly using bricks or ladders.
While moving from building i to building i+1 (0-indexed),
If the current building&amp;rsquo;s height is greater than or equal to the next building&amp;rsquo;s height, you do not need a ladder or bricks.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1646.Get-Maximum-in-Generated-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1646.Get-Maximum-in-Generated-Array/</guid><description>1646. Get Maximum in Generated Array # 题目 # You are given an integer n. An array nums of length n + 1 is generated in the following way:
nums[0] = 0 nums[1] = 1 nums[2 * i] = nums[i] when 2 &amp;lt;= 2 * i &amp;lt;= n nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 &amp;lt;= 2 * i + 1 &amp;lt;= n Return ****the maximum integer in the array nums.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1647.Minimum-Deletions-to-Make-Character-Frequencies-Unique/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1647.Minimum-Deletions-to-Make-Character-Frequencies-Unique/</guid><description>1647. Minimum Deletions to Make Character Frequencies Unique # 题目 # A string s is called good if there are no two different characters in s that have the same frequency.
Given a string s, return the minimum number of characters you need to delete to make s good.
The frequency of a character in a string is the number of times it appears in the string. For example, in the string &amp;quot;aab&amp;quot;, the frequency of 'a' is 2, while the frequency of 'b' is 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1648.Sell-Diminishing-Valued-Colored-Balls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1648.Sell-Diminishing-Valued-Colored-Balls/</guid><description>1648. Sell Diminishing-Valued Colored Balls # 题目 # You have an inventory of different colored balls, and there is a customer that wants orders balls of any color.
The customer weirdly values the colored balls. Each colored ball&amp;rsquo;s value is the number of balls of that color you currently have in your inventory. For example, if you own 6 yellow balls, the customer would pay 6 for the first yellow ball.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1649.Create-Sorted-Array-through-Instructions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1649.Create-Sorted-Array-through-Instructions/</guid><description>1649. Create Sorted Array through Instructions # 题目 # Given an integer array instructions, you are asked to create a sorted array from the elements in instructions. You start with an empty container nums. For each element from left to right in instructions, insert it into nums. The cost of each insertion is the minimum of the following:
The number of elements currently in nums that are strictly less than instructions[i].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1652.Defuse-the-Bomb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1652.Defuse-the-Bomb/</guid><description>1652. Defuse the Bomb # 题目 # You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.
To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.
If k &amp;gt; 0, replace the ith number with the sum of the next k numbers.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1653.Minimum-Deletions-to-Make-String-Balanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1653.Minimum-Deletions-to-Make-String-Balanced/</guid><description>1653. Minimum Deletions to Make String Balanced # 题目 # You are given a string s consisting only of characters 'a' and 'b'.
You can delete any number of characters in s to make s balanced. s is balanced if there is no pair of indices (i,j) such that i &amp;lt; j and s[i] = 'b' and s[j]= 'a'.
Return the minimum number of deletions needed to make s balanced.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1654.Minimum-Jumps-to-Reach-Home/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1654.Minimum-Jumps-to-Reach-Home/</guid><description>1654. Minimum Jumps to Reach Home # 题目 # A certain bug&amp;rsquo;s home is on the x-axis at position x. Help them get there from position 0.
The bug jumps according to the following rules:
It can jump exactly a positions forward (to the right). It can jump exactly b positions backward (to the left). It cannot jump backward twice in a row. It cannot jump to any forbidden positions.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1655.Distribute-Repeating-Integers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1655.Distribute-Repeating-Integers/</guid><description>1655. Distribute Repeating Integers # 题目 # You are given an array of n integers, nums, where there are at most 50 unique values in the array. You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. Determine if it is possible to distribute nums such that:
The ith customer gets exactly quantity[i] integers, The integers the ith customer gets are all equal, and Every customer is satisfied.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1656.Design-an-Ordered-Stream/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1656.Design-an-Ordered-Stream/</guid><description>1656. Design an Ordered Stream # 题目 # There is a stream of n (id, value) pairs arriving in an arbitrary order, where id is an integer between 1 and n and value is a string. No two pairs have the same id.
Design a stream that returns the values in increasing order of their IDs by returning a chunk (list) of values after each insertion. The concatenation of all the chunks should result in a list of the sorted values.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1657.Determine-if-Two-Strings-Are-Close/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1657.Determine-if-Two-Strings-Are-Close/</guid><description>1657. Determine if Two Strings Are Close # 题目 # Two strings are considered close if you can attain one from the other using the following operations:
Operation 1: Swap any two existing characters. For example, abcde -&amp;gt; aecdb Operation 2: Transform every occurrence of one existing character into another existing character, and do the same with the other character. For example, aacabb -&amp;gt; bbcbaa (all a's turn into b's, and all b's turn into a's) You can use the operations on either string as many times as necessary.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1658.Minimum-Operations-to-Reduce-X-to-Zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1658.Minimum-Operations-to-Reduce-X-to-Zero/</guid><description>1658. Minimum Operations to Reduce X to Zero # 题目 # You are given an integer array nums and an integer x. In one operation, you can either remove the leftmost or the rightmost element from the array nums and subtract its value from x. Note that this modifies the array for future operations.
Return the minimum number of operations to reduce x to exactly 0 if it&amp;rsquo;s possible, otherwise, return 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1659.Maximize-Grid-Happiness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1659.Maximize-Grid-Happiness/</guid><description>1659. Maximize Grid Happiness # 题目 # You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.
You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1662.Check-If-Two-String-Arrays-are-Equivalent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1662.Check-If-Two-String-Arrays-are-Equivalent/</guid><description>1662. Check If Two String Arrays are Equivalent # 题目 # Given two string arrays word1 and word2, return **true if the two arrays represent the same string, and false otherwise.
A string is represented by an array if the array elements concatenated in order forms the string.
Example 1:
Input: word1 = [&amp;quot;ab&amp;quot;, &amp;quot;c&amp;quot;], word2 = [&amp;quot;a&amp;quot;, &amp;quot;bc&amp;quot;] Output: true Explanation: word1 represents string &amp;quot;ab&amp;quot; + &amp;quot;c&amp;quot; -&amp;gt; &amp;quot;abc&amp;quot; word2 represents string &amp;quot;a&amp;quot; + &amp;quot;bc&amp;quot; -&amp;gt; &amp;quot;abc&amp;quot; The strings are the same, so return true.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1663.Smallest-String-With-A-Given-Numeric-Value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1663.Smallest-String-With-A-Given-Numeric-Value/</guid><description>1663. Smallest String With A Given Numeric Value # 题目 # The numeric value of a lowercase character is defined as its position (1-indexed) in the alphabet, so the numeric value of a is 1, the numeric value of b is 2, the numeric value of c is 3, and so on.
The numeric value of a string consisting of lowercase characters is defined as the sum of its characters&amp;rsquo; numeric values.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1664.Ways-to-Make-a-Fair-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1664.Ways-to-Make-a-Fair-Array/</guid><description>1664. Ways to Make a Fair Array # 题目 # You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal.
For example, if nums = [6,1,7,4,1]:
Choosing to remove index 1 results in nums = [6,7,4,1]. Choosing to remove index 2 results in nums = [6,1,4,1]. Choosing to remove index 4 results in nums = [6,1,7,4].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1665.Minimum-Initial-Energy-to-Finish-Tasks/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1665.Minimum-Initial-Energy-to-Finish-Tasks/</guid><description>1665. Minimum Initial Energy to Finish Tasks # 题目 # You are given an array tasks where tasks[i] = [actuali, minimumi]:
actuali is the actual amount of energy you spend to finish the ith task. minimumi is the minimum amount of energy you require to begin the ith task. For example, if the task is [10, 12] and your current energy is 11, you cannot start this task.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1668.Maximum-Repeating-Substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1668.Maximum-Repeating-Substring/</guid><description>1668. Maximum Repeating Substring # 题目 # For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word's maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word's maximum k-repeating value is 0.
Given strings sequence and word, return the maximum k-repeating value of word in sequence.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1669.Merge-In-Between-Linked-Lists/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1669.Merge-In-Between-Linked-Lists/</guid><description>1669. Merge In Between Linked Lists # 题目 # You are given two linked lists: list1 and list2 of sizes n and m respectively.
Remove list1's nodes from the ath node to the bth node, and put list2 in their place.
The blue edges and nodes in the following figure incidate the result:
Build the result list and return its head.
Example 1:
Input: list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002] Output: [0,1,2,1000000,1000001,1000002,5] Explanation: We remove the nodes 3 and 4 and put the entire list2 in their place.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1670.Design-Front-Middle-Back-Queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1670.Design-Front-Middle-Back-Queue/</guid><description>1670. Design Front Middle Back Queue # 题目 # Design a queue that supports push and pop operations in the front, middle, and back.
Implement the FrontMiddleBack class:
FrontMiddleBack() Initializes the queue. void pushFront(int val) Adds val to the front of the queue. void pushMiddle(int val) Adds val to the middle of the queue. void pushBack(int val) Adds val to the back of the queue. int popFront() Removes the front element of the queue and returns it.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1672.Richest-Customer-Wealth/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1672.Richest-Customer-Wealth/</guid><description>1672. Richest Customer Wealth # 题目 # You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the ith customer has in the jth bank. Return the wealth that the richest customer has.
A customer&amp;rsquo;s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth.
Example 1:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1673.Find-the-Most-Competitive-Subsequence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1673.Find-the-Most-Competitive-Subsequence/</guid><description>1673. Find the Most Competitive Subsequence # 题目 # Given an integer array nums and a positive integer k, return the most competitive subsequence of nums of size k.
An array&amp;rsquo;s subsequence is a resulting sequence obtained by erasing some (possibly zero) elements from the array.
We define that a subsequence a is more competitive than a subsequence b (of the same length) if in the first position where a and b differ, subsequence a has a number less than the corresponding number in b.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1674.Minimum-Moves-to-Make-Array-Complementary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1674.Minimum-Moves-to-Make-Array-Complementary/</guid><description>1674. Minimum Moves to Make Array Complementary # 题目 # You are given an integer array nums of even length n and an integer limit. In one move, you can replace any integer from nums with another integer between 1 and limit, inclusive.
The array nums is complementary if for all indices i (0-indexed), nums[i] + nums[n - 1 - i] equals the same number. For example, the array [1,2,3,4] is complementary because for all indices i, nums[i] + nums[n - 1 - i] = 5.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1675.Minimize-Deviation-in-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1675.Minimize-Deviation-in-Array/</guid><description>1675. Minimize Deviation in Array # 题目 # You are given an array nums of n positive integers.
You can perform two types of operations on any element of the array any number of times:
If the element is even, divide it by 2. For example, if the array is [1,2,3,4], then you can do this operation on the last element, and the array will be [1,2,3,2].</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1678.Goal-Parser-Interpretation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1678.Goal-Parser-Interpretation/</guid><description>1678. Goal Parser Interpretation # 题目 # You own a Goal Parser that can interpret a string command. The command consists of an alphabet of &amp;quot;G&amp;quot;, &amp;quot;()&amp;quot; and/or &amp;quot;(al)&amp;quot; in some order. The Goal Parser will interpret &amp;quot;G&amp;quot; as the string &amp;quot;G&amp;quot;, &amp;quot;()&amp;quot; as the string &amp;quot;o&amp;quot;, and &amp;quot;(al)&amp;quot; as the string &amp;quot;al&amp;quot;. The interpreted strings are then concatenated in the original order.
Given the string command, return the Goal Parser&amp;rsquo;s interpretation of command.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1679.Max-Number-of-K-Sum-Pairs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1679.Max-Number-of-K-Sum-Pairs/</guid><description>1679. Max Number of K-Sum Pairs # 题目 # You are given an integer array nums and an integer k.
In one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.
Return the maximum number of operations you can perform on the array.
Example 1:
Input: nums = [1,2,3,4], k = 5 Output: 2 Explanation: Starting with nums = [1,2,3,4]: - Remove numbers 1 and 4, then nums = [2,3] - Remove numbers 2 and 3, then nums = [] There are no more pairs that sum up to 5, hence a total of 2 operations.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1680.Concatenation-of-Consecutive-Binary-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1680.Concatenation-of-Consecutive-Binary-Numbers/</guid><description>1680. Concatenation of Consecutive Binary Numbers # 题目 # Given an integer n, return the decimal value of the binary string formed by concatenating the binary representations of 1 to n in order, modulo 109 + 7.
Example 1:
Input: n = 1 Output: 1 Explanation: &amp;quot;1&amp;quot; in binary corresponds to the decimal value 1. Example 2:
Input: n = 3 Output: 27 Explanation: In binary, 1, 2, and 3 corresponds to &amp;quot;1&amp;quot;, &amp;quot;10&amp;quot;, and &amp;quot;11&amp;quot;.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1681.Minimum-Incompatibility/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1681.Minimum-Incompatibility/</guid><description>1681. Minimum Incompatibility # 题目 # You are given an integer array nums and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.
A subset&amp;rsquo;s incompatibility is the difference between the maximum and minimum elements in that array.
Return the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1684.Count-the-Number-of-Consistent-Strings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1684.Count-the-Number-of-Consistent-Strings/</guid><description>1684. Count the Number of Consistent Strings # 题目 # You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed.
Return the number of consistent strings in the array words.
Example 1:
Input: allowed = &amp;quot;ab&amp;quot;, words = [&amp;quot;ad&amp;quot;,&amp;quot;bd&amp;quot;,&amp;quot;aaab&amp;quot;,&amp;quot;baa&amp;quot;,&amp;quot;badab&amp;quot;] Output: 2 Explanation: Strings &amp;quot;aaab&amp;quot; and &amp;quot;baa&amp;quot; are consistent since they only contain characters 'a' and 'b'.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1685.Sum-of-Absolute-Differences-in-a-Sorted-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1685.Sum-of-Absolute-Differences-in-a-Sorted-Array/</guid><description>1685. Sum of Absolute Differences in a Sorted Array # 题目 # You are given an integer array nums sorted in non-decreasing order.
Build and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.
In other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 &amp;lt;= j &amp;lt; nums.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1688.Count-of-Matches-in-Tournament/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1688.Count-of-Matches-in-Tournament/</guid><description>1688. Count of Matches in Tournament # 题目 # You are given an integer n, the number of teams in a tournament that has strange rules:
If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round. If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1689.Partitioning-Into-Minimum-Number-Of-Deci-Binary-Numbers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1689.Partitioning-Into-Minimum-Number-Of-Deci-Binary-Numbers/</guid><description>1689. Partitioning Into Minimum Number Of Deci-Binary Numbers # 题目 # A decimal number is called deci-binary if each of its digits is either 0 or 1 without any leading zeros. For example, 101 and 1100 are deci-binary, while 112 and 3001 are not.
Given a string n that represents a positive decimal integer, return the minimum number of positive deci-binary numbers needed so that they sum up to n*.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1690.Stone-Game-VII/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1690.Stone-Game-VII/</guid><description>1690. Stone Game VII # 题目 # Alice and Bob take turns playing a game, with Alice starting first.
There are n stones arranged in a row. On each player&amp;rsquo;s turn, they can remove either the leftmost stone or the rightmost stone from the row and receive points equal to the sum of the remaining stones&amp;rsquo; values in the row. The winner is the one with the higher score when there are no stones left to remove.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1691.Maximum-Height-by-Stacking-Cuboids/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1691.Maximum-Height-by-Stacking-Cuboids/</guid><description>1691. Maximum Height by Stacking Cuboids # 题目 # Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.
You can place cuboid i on cuboid j if widthi &amp;lt;= widthj and lengthi &amp;lt;= lengthj and heighti &amp;lt;= heightj. You can rearrange any cuboid&amp;rsquo;s dimensions by rotating it to put it on another cuboid.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1694.Reformat-Phone-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1694.Reformat-Phone-Number/</guid><description>1694. Reformat Phone Number # 题目 # You are given a phone number as a string number. number consists of digits, spaces ' ', and/or dashes '-'.
You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1695.Maximum-Erasure-Value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1695.Maximum-Erasure-Value/</guid><description>1695. Maximum Erasure Value # 题目 # You are given an array of positive integers nums and want to erase a subarray containing unique elements. The score you get by erasing the subarray is equal to the sum of its elements.
Return the maximum score you can get by erasing exactly one subarray.
An array b is called to be a subarray of a if it forms a contiguous subsequence of a, that is, if it is equal to a[l],a[l+1],.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1696.Jump-Game-VI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1600~1699/1696.Jump-Game-VI/</guid><description>1696. Jump Game VI # 题目 # You are given a 0-indexed integer array nums and an integer k.
You are initially standing at index 0. In one move, you can jump at most k steps forward without going outside the boundaries of the array. That is, you can jump from index i to any index in the range [i + 1, min(n - 1, i + k)] inclusive.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1700.Number-of-Students-Unable-to-Eat-Lunch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1700.Number-of-Students-Unable-to-Eat-Lunch/</guid><description>1700. Number of Students Unable to Eat Lunch # 题目 # The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches.
The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1704.Determine-if-String-Halves-Are-Alike/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1704.Determine-if-String-Halves-Are-Alike/</guid><description>1704. Determine if String Halves Are Alike # 题目 # You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.
Two strings are alike if they have the same number of vowels ('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'). Notice that s contains uppercase and lowercase letters.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1705.Maximum-Number-of-Eaten-Apples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1705.Maximum-Number-of-Eaten-Apples/</guid><description>1705. Maximum Number of Eaten Apples # 题目 # There is a special kind of apple tree that grows apples every day for n days. On the ith day, the tree grows apples[i] apples that will rot after days[i] days, that is on day i + days[i] the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by apples[i] == 0 and days[i] == 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1710.Maximum-Units-on-a-Truck/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1710.Maximum-Units-on-a-Truck/</guid><description>1710. Maximum Units on a Truck # 题目 # You are assigned to put some amount of boxes onto one truck. You are given a 2D array boxTypes, where boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]:
numberOfBoxesi is the number of boxes of type i. numberOfUnitsPerBoxiis the number of units in each box of the type i. You are also given an integer truckSize, which is the maximum number of boxes that can be put on the truck.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1716.Calculate-Money-in-Leetcode-Bank/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1716.Calculate-Money-in-Leetcode-Bank/</guid><description>1716. Calculate Money in Leetcode Bank # 题目 # Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.
He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1720.Decode-XORed-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1720.Decode-XORed-Array/</guid><description>1720. Decode XORed Array # 题目 # There is a hidden integer array arr that consists of n non-negative integers.
It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].
You are given the encoded array. You are also given an integer first, that is the first element of arr, i.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1721.Swapping-Nodes-in-a-Linked-List/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1721.Swapping-Nodes-in-a-Linked-List/</guid><description>1721. Swapping Nodes in a Linked List # 题目 # You are given the head of a linked list, and an integer k.
Return the head of the linked list after swapping the values of the kth node from the beginning and the kth node from the end (the list is 1-indexed).
Example 1:
Input: head = [1,2,3,4,5], k = 2 Output: [1,4,3,2,5] Example 2:
Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5 Output: [7,9,6,6,8,7,3,0,9,5] Example 3:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1725.Number-Of-Rectangles-That-Can-Form-The-Largest-Square/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1725.Number-Of-Rectangles-That-Can-Form-The-Largest-Square/</guid><description>1725. Number Of Rectangles That Can Form The Largest Square # 题目 # You are given an array rectangles where rectangles[i] = [li, wi] represents the ith rectangle of length li and width wi.
You can cut the ith rectangle to form a square with a side length of k if both k &amp;lt;= li and k &amp;lt;= wi. For example, if you have a rectangle [4,6], you can cut it to get a square with a side length of at most 4.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1732.Find-the-Highest-Altitude/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1732.Find-the-Highest-Altitude/</guid><description>1732. Find the Highest Altitude # 题目 # There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.
You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 &amp;lt;= i &amp;lt; n).</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1734.Decode-XORed-Permutation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1734.Decode-XORed-Permutation/</guid><description>1734. Decode XORed Permutation # 题目 # There is an integer array perm that is a permutation of the first n positive integers, where n is always odd.
It was encoded into another integer array encoded of length n - 1, such that encoded[i] = perm[i] XOR perm[i + 1]. For example, if perm = [1,3,2], then encoded = [2,1].
Given the encoded array, return the original array perm.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1736.Latest-Time-by-Replacing-Hidden-Digits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1736.Latest-Time-by-Replacing-Hidden-Digits/</guid><description>1736. Latest Time by Replacing Hidden Digits # 题目 # You are given a string time in the form of hh:mm, where some of the digits in the string are hidden (represented by ?).
The valid times are those inclusively between 00:00 and 23:59.
Return the latest valid time you can get from time by replacing the hidden digits.
Example 1:
Input: time = &amp;quot;2?:?0&amp;quot; Output: &amp;quot;23:50&amp;quot; Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1738.Find-Kth-Largest-XOR-Coordinate-Value/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1738.Find-Kth-Largest-XOR-Coordinate-Value/</guid><description>1738. Find Kth Largest XOR Coordinate Value # 题目 # You are given a 2D matrix of size m x n, consisting of non-negative integers. You are also given an integer k.
The value of coordinate (a, b) of the matrix is the XOR of all matrix[i][j] where 0 &amp;lt;= i &amp;lt;= a &amp;lt; m and 0 &amp;lt;= j &amp;lt;= b &amp;lt; n (0-indexed).
Find the kth largest value (1-indexed) of all the coordinates of matrix.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1742.Maximum-Number-of-Balls-in-a-Box/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1742.Maximum-Number-of-Balls-in-a-Box/</guid><description>1742. Maximum Number of Balls in a Box # 题目 # You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity.
Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball&amp;rsquo;s number.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1744.Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1744.Can-You-Eat-Your-Favorite-Candy-on-Your-Favorite-Day/</guid><description>1744. Can You Eat Your Favorite Candy on Your Favorite Day? # 题目 # You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the ith type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].
You play a game with the following rules:
You start eating candies on day 0. You cannot eat any candy of type i unless you have eaten all candies of type i - 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1748.Sum-of-Unique-Elements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1748.Sum-of-Unique-Elements/</guid><description>1748. Sum of Unique Elements # 题目 # You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array.
Return the sum of all the unique elements of nums.
Example 1:
Input: nums = [1,2,3,2] Output: 4 Explanation: The unique elements are [1,3], and the sum is 4. Example 2:
Input: nums = [1,1,1,1,1] Output: 0 Explanation: There are no unique elements, and the sum is 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1752.Check-if-Array-Is-Sorted-and-Rotated/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1752.Check-if-Array-Is-Sorted-and-Rotated/</guid><description>1752. Check if Array Is Sorted and Rotated # 题目 # Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false.
There may be duplicates in the original array.
Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1758.Minimum-Changes-To-Make-Alternating-Binary-String/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1758.Minimum-Changes-To-Make-Alternating-Binary-String/</guid><description>1758. Minimum Changes To Make Alternating Binary String # 题目 # You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.
The string is called alternating if no two adjacent characters are equal. For example, the string &amp;quot;010&amp;quot; is alternating, while the string &amp;quot;0100&amp;quot; is not.
Return the minimum number of operations needed to make s alternating.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1763.Longest-Nice-Substring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1763.Longest-Nice-Substring/</guid><description>1763. Longest Nice Substring # 题目 # A string s is nice if, for every letter of the alphabet that s contains, it appears both in uppercase and lowercase. For example, &amp;quot;abABB&amp;quot; is nice because 'A' and 'a' appear, and 'B' and 'b' appear. However, &amp;quot;abA&amp;quot; is not because 'b' appears, but 'B' does not.
Given a string s, return the longest substring of s that is nice. If there are multiple, return the substring of the earliest occurrence.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1791.Find-Center-of-Star-Graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1700~1799/1791.Find-Center-of-Star-Graph/</guid><description>1791.Find Center of Star Graph # 题目 # There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.
You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1816.Truncate-Sentence/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1816.Truncate-Sentence/</guid><description>1816. Truncate Sentence # 题目 # A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).
For example, &amp;ldquo;Hello World&amp;rdquo;, &amp;ldquo;HELLO&amp;rdquo;, and &amp;ldquo;hello world hello world&amp;rdquo; are all sentences. You are given a sentence s and an integer k. You want to truncate s such that it contains only the first k words.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1818.Minimum-Absolute-Sum-Difference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1818.Minimum-Absolute-Sum-Difference/</guid><description>1818. Minimum Absolute Sum Difference # 题目 # You are given two positive integer arrays nums1 and nums2, both of length n.
The absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 &amp;lt;= i &amp;lt; n (0-indexed).
You can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1846.Maximum-Element-After-Decreasing-and-Rearranging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1846.Maximum-Element-After-Decreasing-and-Rearranging/</guid><description>1846. Maximum Element After Decreasing and Rearranging # 题目 # You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:
The value of the first element in arr must be 1. The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) &amp;lt;= 1 for each i where 1 &amp;lt;= i &amp;lt; arr.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1877.Minimize-Maximum-Pair-Sum-in-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1800~1899/1877.Minimize-Maximum-Pair-Sum-in-Array/</guid><description>1877. Minimize Maximum Pair Sum in Array # 题目 # The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.
For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8. Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1900~1999/1984.Minimum-Difference-Between-Highest-and-Lowest-of-K-Scores/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/1900~1999/1984.Minimum-Difference-Between-Highest-and-Lowest-of-K-Scores/</guid><description>1984. Minimum Difference Between Highest and Lowest of K Scores # 题目 # You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.
Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.
Return the minimum possible difference.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2021.Brightest-Position-on-Street/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2021.Brightest-Position-on-Street/</guid><description>2021. Brightest Position on Street # 题目 # A perfectly straight street is represented by a number line. The street has street lamp(s) on it and is represented by a 2D integer array lights. Each lights[i] = [positioni, rangei] indicates that there is a street lamp at position positioni that lights up the area from [positioni - rangei, positioni + rangei] (inclusive).
The brightness of a position p is defined as the number of street lamp that light up the position p.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2022.Convert-1D-Array-Into-2D-Array/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2022.Convert-1D-Array-Into-2D-Array/</guid><description>2022. Convert 1D Array Into 2D Array # 题目 # You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original.
The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2037.Minimum-Number-of-Moves-to-Seat-Everyone/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2037.Minimum-Number-of-Moves-to-Seat-Everyone/</guid><description>2037. Minimum Number of Moves to Seat Everyone # 题目 # There are n seats and n students in a room. You are given an array seats of length n, where seats[i] is the position of the ith seat. You are also given the array students of length n, where students[j] is the position of the jth student.
You may perform the following move any number of times:</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2038.Remove-Colored-Pieces-if-Both-Neighbors-are-the-Same-Color/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2038.Remove-Colored-Pieces-if-Both-Neighbors-are-the-Same-Color/</guid><description>2038. Remove Colored Pieces if Both Neighbors are the Same Color # 题目 # There are n pieces arranged in a line, and each piece is colored either by &amp;lsquo;A&amp;rsquo; or by &amp;lsquo;B&amp;rsquo;. You are given a string colors of length n where colors[i] is the color of the ith piece.
Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2043.Simple-Bank-System/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2043.Simple-Bank-System/</guid><description>2043. Simple Bank System # 题目 # You have been tasked with writing a program for a popular bank that will automate all its incoming transactions (transfer, deposit, and withdraw). The bank has n accounts numbered from 1 to n. The initial balance of each account is stored in a 0-indexed integer array balance, with the (i + 1)th account having an initial balance of balance[i].
Execute all the valid transactions.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2096.Step-By-Step-Directions-From-a-Binary-Tree-Node-to-Another/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2000~2099/2096.Step-By-Step-Directions-From-a-Binary-Tree-Node-to-Another/</guid><description>2096. Step-By-Step Directions From a Binary Tree Node to Another # 题目 # You are given the root of a binary tree with n nodes. Each node is uniquely assigned a value from 1 to n. You are also given an integer startValue representing the value of the start node s, and a different integer destValue representing the value of the destination node t.
Find the shortest path starting from node s and ending at node t.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2164.Sort-Even-and-Odd-Indices-Independently/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2164.Sort-Even-and-Odd-Indices-Independently/</guid><description>2164. Sort Even and Odd Indices Independently # 题目 # You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:
Sort the values at odd indices of nums in non-increasing order. For example, if nums = [4,**1**,2,**3**] before this step, it becomes [4,**3**,2,**1**] after. The values at odd indices 1 and 3 are sorted in non-increasing order. Sort the values at even indices of nums in non-decreasing order.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2165.Smallest-Value-of-the-Rearranged-Number/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2165.Smallest-Value-of-the-Rearranged-Number/</guid><description>2165. Smallest Value of the Rearranged Number # 题目 # You are given an integer num. Rearrange the digits of num such that its value is minimized and it does not contain any leading zeros.
Return the rearranged number with minimal value.
Note that the sign of the number does not change after rearranging the digits.
Example 1:
Input: num = 310 Output: 103 Explanation: The possible arrangements for the digits of 310 are 013, 031, 103, 130, 301, 310.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2166.Design-Bitset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2166.Design-Bitset/</guid><description>2166. Design Bitset # 题目 # A Bitset is a data structure that compactly stores bits.
Implement the Bitset class:
Bitset(int size) Initializes the Bitset with size bits, all of which are 0. void fix(int idx) Updates the value of the bit at the index idx to 1. If the value was already 1, no change occurs. void unfix(int idx) Updates the value of the bit at the index idx to 0.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2167.Minimum-Time-to-Remove-All-Cars-Containing-Illegal-Goods/</guid><description>2167. Minimum Time to Remove All Cars Containing Illegal Goods # 题目 # You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods.
As the train conductor, you would like to get rid of all the cars containing illegal goods.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2169.Count-Operations-to-Obtain-Zero/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2169.Count-Operations-to-Obtain-Zero/</guid><description>2169. Count Operations to Obtain Zero # 题目 # You are given two non-negative integers num1 and num2.
In one operation, if num1 &amp;gt;= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.
For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2170.Minimum-Operations-to-Make-the-Array-Alternating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2170.Minimum-Operations-to-Make-the-Array-Alternating/</guid><description>2170. Minimum Operations to Make the Array Alternating # 题目 # You are given a 0-indexed array nums consisting of n positive integers.
The array nums is called alternating if:
nums[i - 2] == nums[i], where 2 &amp;lt;= i &amp;lt;= n - 1. nums[i - 1] != nums[i], where 1 &amp;lt;= i &amp;lt;= n - 1. In one operation, you can choose an index i and change nums[i] into any positive integer.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2171.Removing-Minimum-Number-of-Magic-Beans/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2171.Removing-Minimum-Number-of-Magic-Beans/</guid><description>2171. Removing Minimum Number of Magic Beans # 题目 # You are given an array of positive integers beans, where each integer represents the number of magic beans found in a particular magic bag.
Remove any number of beans (possibly none) from each bag such that the number of beans in each remaining non-empty bag (still containing at least one bean) is equal. Once a bean has been removed from a bag, you are not allowed to return it to any of the bags.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2180.Count-Integers-With-Even-Digit-Sum/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2180.Count-Integers-With-Even-Digit-Sum/</guid><description>2180. Count Integers With Even Digit Sum # 题目 # Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.
The digit sum of a positive integer is the sum of all its digits.
Example 1:
Input: num = 4 Output: 2 Explanation: The only integers less than or equal to 4 whose digit sums are even are 2 and 4.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2181.Merge-Nodes-in-Between-Zeros/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2181.Merge-Nodes-in-Between-Zeros/</guid><description>2181. Merge Nodes in Between Zeros # 题目 # You are given the head of a linked list, which contains a series of integers separated by 0's. The beginning and end of the linked list will have Node.val == 0.
For every two consecutive 0's, merge all the nodes lying in between them into a single node whose value is the sum of all the merged nodes. The modified list should not contain any 0's.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2182.Construct-String-With-Repeat-Limit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2182.Construct-String-With-Repeat-Limit/</guid><description>2182. Construct String With Repeat Limit # 题目 # You are given a string s and an integer repeatLimit. Construct a new string repeatLimitedString using the characters of s such that no letter appears more than repeatLimit times in a row. You do not have to use all characters from s.
Return the lexicographically largest repeatLimitedString possible.
A string a is lexicographically larger than a string b if in the first position where a and b differ, string a has a letter that appears later in the alphabet than the corresponding letter in b.</description></item><item><title/><link>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2183.Count-Array-Pairs-Divisible-by-K/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://Seth9976.github.io/LeetCode-Go/ChapterFour/2100~2199/2183.Count-Array-Pairs-Divisible-by-K/</guid><description>2183. Count Array Pairs Divisible by K # 题目 # Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that:
0 &amp;lt;= i &amp;lt; j &amp;lt;= n - 1 and nums[i] * nums[j] is divisible by k. Example 1:
Input: nums = [1,2,3,4,5], k = 2 Output: 7 Explanation: The 7 pairs of indices whose corresponding products are divisible by 2 are (0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4).</description></item></channel></rss>